<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Short Notes: On a Curious Prefix-Sum Problem | Markus Thill </title> <meta name="author" content="Markus Thill"> <meta name="description" content="A deceptively simple recurrence leads to an unexpected challenge when computing its prefix sums. Solving it efficiently requires looking at the problem from a different angle."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?v=a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?v=f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?v=62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?v=591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8D%95&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?v=d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://markusthill.github.io/blog/2026/pe-818p100-generalized-parity-recurrence/"> <script src="/assets/js/theme.js?v=48c9b5bd7f2e0605e39e579400e22553"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?v=5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Markus</span> Thill </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/"> </a> </li> <li class="nav-item "> <a class="nav-link" href="/about">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/index.html">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/projects/">projects</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Short Notes: On a Curious Prefix-Sum Problem</h1> <p class="post-meta"> Created on January 10, 2026 </p> <p class="post-tags"> <a href="/blog/2026"> <i class="fa-solid fa-calendar fa-sm"></i> 2026 </a>   ·   <a href="/blog/tag/recurrence-relations"> <i class="fa-solid fa-hashtag fa-sm"></i> recurrence-relations</a>   <a href="/blog/tag/prefix-sums"> <i class="fa-solid fa-hashtag fa-sm"></i> prefix-sums</a>   <a href="/blog/tag/discrete-math"> <i class="fa-solid fa-hashtag fa-sm"></i> discrete-math</a>   <a href="/blog/tag/algorithms"> <i class="fa-solid fa-hashtag fa-sm"></i> algorithms</a>   <a href="/blog/tag/optimization"> <i class="fa-solid fa-hashtag fa-sm"></i> optimization</a>   <a href="/blog/tag/python"> <i class="fa-solid fa-hashtag fa-sm"></i> python</a>   ·   <a href="/blog/category/programming"> <i class="fa-solid fa-tag fa-sm"></i> programming</a>   <a href="/blog/category/algorithms"> <i class="fa-solid fa-tag fa-sm"></i> algorithms</a>   <a href="/blog/category/mathematics"> <i class="fa-solid fa-tag fa-sm"></i> mathematics</a> </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"><a href="#problem-description">Problem Description</a></li> <li class="toc-entry toc-h2"><a href="#formal-problem-statement">Formal Problem Statement</a></li> <li class="toc-entry toc-h2"><a href="#from-the-recurrence-to-prefix-sum-relations">From the Recurrence to Prefix-Sum Relations</a></li> <li class="toc-entry toc-h2"> <a href="#deriving-a-formula-for-s2n">Deriving a Formula for \(S(2n)\)</a> <ul> <li class="toc-entry toc-h3"><a href="#even-index-contribution">Even-index contribution</a></li> <li class="toc-entry toc-h3"><a href="#odd-index-contribution">Odd-index contribution</a></li> <li class="toc-entry toc-h3"><a href="#combining-both-parts">Combining both parts</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#deriving-a-formula-for-s2n1">Deriving a Formula for \(S(2n+1)\)</a></li> <li class="toc-entry toc-h2"><a href="#summary-of-the-induced-prefix-sum-recurrences">Summary of the Induced Prefix-Sum Recurrences</a></li> <li class="toc-entry toc-h2"> <a href="#a-binary-state-algorithm-for-computing-sn">A Binary-State Algorithm for Computing \(S(N)\)</a> <ul> <li class="toc-entry toc-h3"><a href="#state-representation">State Representation</a></li> <li class="toc-entry toc-h3"><a href="#binary-decomposition-of-the-index">Binary Decomposition of the Index</a></li> <li class="toc-entry toc-h3"><a href="#precomputation-step">Precomputation Step</a></li> <li class="toc-entry toc-h3"><a href="#even-transition-bit-0">Even Transition (bit \(0\))</a></li> <li class="toc-entry toc-h3"><a href="#odd-transition-bit-1">Odd Transition (bit \(1\))</a></li> <li class="toc-entry toc-h3"><a href="#termination-and-result">Termination and Result</a></li> <li class="toc-entry toc-h3"><a href="#interpretation">Interpretation</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#from-theory-to-code">From Theory to Code</a> <ul> <li class="toc-entry toc-h3"><a href="#a-naive-reference-implementation">A Naive Reference Implementation</a></li> <li class="toc-entry toc-h3"><a href="#an-optimized-prefix-sum-algorithm">An Optimized Prefix-Sum Algorithm</a></li> <li class="toc-entry toc-h3"><a href="#demonstrating-the-power-of-the-optimized-algorithm">Demonstrating the Power of the Optimized Algorithm</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#summary">Summary</a></li> </ul> </div> <hr> <div id="markdown-content"> <p><br></p> <h2 id="problem-description">Problem Description</h2> <p>You are given a sequence of numbers defined by a simple-looking recurrence.</p> <p>The sequence starts with a single initial value \(a_1\). Three fixed constants \(q\), \(r\), and \(t\) determine how all further values are generated.</p> <p>For every integer \(n \ge 1\), the sequence is defined by</p> \[\begin{aligned} a_{2n} &amp;= q\,a_n, \\ a_{2n+1} &amp;= r\,a_n + t\,a_{n+1}, \end{aligned}\] <p>where:</p> <ul> <li>\(a_n\) denotes the value of the sequence at position \(n\),</li> <li>\(q\) controls how values at even indices are produced,</li> <li>\(r\) and \(t\) control how values at odd indices depend on earlier terms.</li> </ul> <p>From this sequence, define the prefix sum</p> \[S(N) = a_1 + a_2 + a_3 + \dots + a_N,\] <p>which represents the sum of the first \(N\) sequence values.</p> <p>For small values of \(N\), computing \(S(N)\) is straightforward: one can generate the sequence term by term and keep a running sum.</p> <p>Now comes the riddle:</p> <blockquote> <p>Suppose \(N\) is so large that iterating from \(1\) to \(N\) is completely infeasible—think of values like \(10^{12}\), \(10^{15}\), or even larger.</p> <p>Is it still possible to compute the exact value of \(S(N)\), and if so, how?</p> </blockquote> <p>At first glance, the task seems impossible: the definition of \(S(N)\) involves \(N\) terms, and \(N\) may be astronomically large.</p> <p>The challenge is to uncover a hidden structure in the recurrence that makes this computation feasible without ever touching most of the terms involved.</p> <p>Before diving into the solution, here is a brief roadmap of how we will approach the problem:</p> <ol> <li>We first analyze the recurrence algebraically and derive closed relations for the prefix sums.</li> <li>These relations reveal a binary self-similarity that allows us to reduce large indices recursively.</li> <li>We then translate this structure into an efficient $O(\log N)$ algorithm.</li> <li>Finally, we implement the method in code, verify it against a naive solution, and demonstrate its power on enormous values of $N$.</li> </ol> <p><br></p> <h2 id="formal-problem-statement">Formal Problem Statement</h2> <p>Let $(a_n)_{n\ge 1}$ be a sequence defined by constants</p> \[a_1,q,r,t \in \mathbb{R} \;(\text{or } \mathbb{Z})\] <p>and the recurrence</p> \[\begin{aligned} a_{2n} &amp;= q\,a_n, \\ a_{2n+1} &amp;= r\,a_n + t\,a_{n+1}, \qquad (n \ge 1). \end{aligned}\] <p>Define the prefix sums \(S(n) := \sum_{k=1}^{n} a_k, \qquad S(0):=0.\)</p> <blockquote> <p><strong>Problem.</strong> Compute \(S(N)\) for a given \(N \ge 1\).</p> </blockquote> <p>Throughout this discussion, “exact” means exact arithmetic with respect to the chosen number system. In particular:</p> <ul> <li>If $a_1,q,r,t$ are integers, then all values of $a_n$ and $S(N)$ are integers, and the algorithm computes them exactly using arbitrary-precision arithmetic.</li> <li>If floating-point values are used instead, the algorithm still applies, but the result is subject to the usual floating-point rounding behavior.</li> </ul> <p><br></p> <h2 id="from-the-recurrence-to-prefix-sum-relations">From the Recurrence to Prefix-Sum Relations</h2> <p>We now turn to the key analytical step: translating the defining recurrence of the sequence into corresponding recurrences for its prefix sums. The central objective is to express \(S(2n)\) and \(S(2n+1)\) in terms of <em>smaller indices</em>, involving only \(S(n)\), \(S(n-1)\), and a small amount of local sequence information. This is precisely what will later allow an efficient algorithm.</p> <hr> <p><br></p> <h2 id="deriving-a-formula-for-s2n">Deriving a Formula for \(S(2n)\)</h2> <p>Because the recurrence defining $(a_n)$ distinguishes between even and odd indices, it is natural to analyze the prefix sums by separating contributions from even and odd positions. We begin directly from the definition:</p> \[S(2n) = \sum_{k=1}^{2n} a_k.\] <p>Since the recurrence distinguishes between even and odd indices, it is natural to split the sum accordingly:</p> \[S(2n) = \sum_{k=1}^{n} a_{2k} \;+\; \sum_{k=0}^{n-1} a_{2k+1}.\] <p><br></p> <h3 id="even-index-contribution">Even-index contribution</h3> <p>Using the recurrence \(a_{2k}=q\,a_k\), the even part simplifies immediately:</p> \[\sum_{k=1}^{n} a_{2k} = \sum_{k=1}^{n} q\,a_k = q \sum_{k=1}^{n} a_k = q\,S(n).\] <p><br></p> <h3 id="odd-index-contribution">Odd-index contribution</h3> <p>For the odd indices, first separate the base term:</p> \[\sum_{k=0}^{n-1} a_{2k+1} = a_1 + \sum_{k=1}^{n-1} a_{2k+1}.\] <p>For \(k \ge 1\), substitute the recurrence \(a_{2k+1}=r\,a_k+t\,a_{k+1}\):</p> \[\sum_{k=1}^{n-1} a_{2k+1} = r\sum_{k=1}^{n-1} a_k \;+\; t\sum_{k=1}^{n-1} a_{k+1}.\] <p>Both sums can be rewritten in terms of prefix sums:</p> \[\sum_{k=1}^{n-1} a_k = S(n-1), \qquad \sum_{k=1}^{n-1} a_{k+1} = \sum_{j=2}^{n} a_j = S(n)-a_1.\] <p>Combining these expressions gives</p> \[\sum_{k=0}^{n-1} a_{2k+1} = a_1 + rS(n-1) + t\bigl(S(n)-a_1\bigr) = rS(n-1) + tS(n) + (1-t)a_1.\] <p><br></p> <h3 id="combining-both-parts">Combining both parts</h3> <p>Adding the even and odd contributions yields the closed recurrence</p> \[S(2n) = qS(n) + rS(n-1) + tS(n) + (1-t)a_1 = (q+t)S(n) + rS(n-1) + (1-t)a_1.\] <p>Notably, \(S(2n)\) depends only on prefix sums at smaller indices and a constant term determined by \(a_1\).</p> <hr> <p><br></p> <h2 id="deriving-a-formula-for-s2n1">Deriving a Formula for \(S(2n+1)\)</h2> <p>The odd case follows immediately from the definition:</p> \[S(2n+1) = S(2n) + a_{2n+1}.\] <p>Substituting the recurrence for \(a_{2n+1}\) gives</p> \[S(2n+1) = S(2n) + r\,a_n + t\,a_{n+1}.\] <p>Inserting the expression for \(S(2n)\) obtained above leads to</p> \[S(2n+1) = (q+t)S(n) + rS(n-1) + (1-t)a_1 \;+\; r\,a_n + t\,a_{n+1}.\] <hr> <p><br></p> <h2 id="summary-of-the-induced-prefix-sum-recurrences">Summary of the Induced Prefix-Sum Recurrences</h2> <p>We have derived the following identities for all \(n \ge 1\):</p> \[\begin{aligned} S(2n) &amp;= (q+t)\,S(n) + r\,S(n-1) + (1-t)\,a_1, \\ S(2n+1) &amp;= (q+t)\,S(n) + r\,S(n-1) + (1-t)\,a_1 \;+\; r\,a_n + t\,a_{n+1}. \end{aligned}\] <p>The key observation is the asymmetry between the two cases:</p> <ul> <li>The <strong>even</strong> prefix sum \(S(2n)\) closes purely in terms of prefix sums.</li> <li>The <strong>odd</strong> prefix sum \(S(2n+1)\) additionally depends on the local pair \((a_n,a_{n+1})\).</li> </ul> <p>This structure is exactly what enables an efficient algorithm.</p> <hr> <p><br></p> <h2 id="a-binary-state-algorithm-for-computing-sn">A Binary-State Algorithm for Computing \(S(N)\)</h2> <p>The identities above suggest a strategy based on repeatedly halving the index. Instead of summing \(N\) terms, we process the binary representation of \(N\) and update a constant-size state at each step.</p> <p><br></p> <h3 id="state-representation">State Representation</h3> <p>At any stage, we maintain the state</p> \[\bigl(S(n-1),\; S(n),\; a_n,\; a_{n+1}\bigr),\] <p>which contains precisely the information required to compute \(S(2n),\; S(2n+1)\) and the next sequence values. The initial state corresponds to \(n=1\):</p> \[\bigl(S(0), S(1), a_1, a_2\bigr) = \bigl(0,\; a_1,\; a_1,\; q\,a_1\bigr),\] <p>since \(a_2=a_{2\cdot 1}=q\,a_1\).</p> <p><br></p> <h3 id="binary-decomposition-of-the-index">Binary Decomposition of the Index</h3> <p>Write the target index \(N\) in binary:</p> \[N = (1 b_{k-1} b_{k-2} \dots b_0)_2.\] <p>The leading \(1\) initializes the state at \(n=1\). Each subsequent bit determines the transition:</p> <ul> <li>bit \(0\) corresponds to \(n \mapsto 2n\),</li> <li>bit \(1\) corresponds to \(n \mapsto 2n+1\).</li> </ul> <p>Processing the bits from left to right repeatedly reduces the problem size by a factor of two.</p> <p><br></p> <h3 id="precomputation-step">Precomputation Step</h3> <p>From the current state, compute the quantities</p> \[\begin{aligned} S(2n) &amp;= (q+t)S(n) + rS(n-1) + (1-t)a_1, \\ S(2n+1) &amp;= S(2n) + r\,a_n + t\,a_{n+1}, \end{aligned}\] <p>as well as the sequence values</p> \[\begin{aligned} a_{2n} &amp;= q\,a_n, \\ a_{2n+1} &amp;= r\,a_n + t\,a_{n+1}, \\ a_{2n+2} &amp;= q\,a_{n+1}. \end{aligned}\] <p>All of these depend only on the current state and can be computed in constant time.</p> <p><br></p> <h3 id="even-transition-bit-0">Even Transition (bit \(0\))</h3> <p>If the next bit is \(0\), update \(n \mapsto 2n\). The new state is</p> <p>\(\bigl(S(2n)-a_{2n},\; S(2n),\; a_{2n},\; a_{2n+1}\bigr),\) using the identity \(S(2n-1)=S(2n)-a_{2n}\).</p> <p><br></p> <h3 id="odd-transition-bit-1">Odd Transition (bit \(1\))</h3> <p>If the next bit is \(1\), update \(n \mapsto 2n+1\). The new state is</p> \[\bigl(S(2n),\; S(2n+1),\; a_{2n+1},\; a_{2n+2}\bigr).\] <p><br></p> <h3 id="termination-and-result">Termination and Result</h3> <p>After all binary digits of \(N\) have been processed, the maintained index equals \(n=N\). The desired prefix sum is therefore \(S(N)\).</p> <hr> <p><br></p> <h3 id="interpretation">Interpretation</h3> <p>The entire computation runs in \(O(\log N)\) time. Only a constant-size state is maintained, and each binary digit of \(N\) triggers a single constant-time update. The apparent necessity of summing \(N\) terms disappears once the binary self-similarity of the recurrence is made explicit.</p> <hr> <p><br></p> <h2 id="from-theory-to-code">From Theory to Code</h2> <h3 id="a-naive-reference-implementation">A Naive Reference Implementation</h3> <p>Before turning to the optimized algorithm, it is useful to establish a simple baseline. For small values of \(N\), the most straightforward approach is to <strong>explicitly generate the sequence</strong> using its defining recurrence and then compute the prefix sums by a single pass over the resulting list. While this method runs in \(O(N)\) time and quickly becomes infeasible for large \(N\), it has two important roles:</p> <ul> <li>it makes the recurrence concrete and easy to experiment with, and</li> <li>it serves as a reliable <strong>reference implementation</strong> for verifying the correctness of the optimized method later on.</li> </ul> <p>The following code implements this direct approach.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Sequence</span>


<span class="k">def</span> <span class="nf">build_sequence_naive</span><span class="p">(</span><span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">a1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">Build a[1..N+1] for the parity recurrence (naive O(N) reference).

    Recurrence:
        a_{2n}   = q * a_n
        a_{2n+1} = r * a_n + t * a_{n+1}

    We compute up to a_{N+1} so that the step for odd indices (2n+1) can safely
    reference a_{n+1} for all n needed.

    Args:
        N: Target maximum index (must satisfy N &gt;= 1).
        a1: Initial value a_1.
        q, r, t: Recurrence constants.

    Returns:
        A list `a` of length N+2 using 1-based indexing:
            - a[0] is unused (kept as 0),
            - a[k] == a_k for k = 1..N+1.
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">N must be &gt;= 1</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># 1-based array: keep index 0 unused for clarity.
</span>    <span class="c1"># We compute up to N+1 because the recurrence needs a_{n+1}.
</span>    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a1</span>

    <span class="c1"># Fill values in increasing n. Each step writes a_{2n} and a_{2n+1}.
</span>    <span class="c1"># The upper bound ensures we don't write beyond N+1.
</span>    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">prefix_sums_naive</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">Compute prefix sums S(k) = sum_{i=1}^k a_i from a 1-based sequence.

    Args:
        a: 1-based sequence array with a[0] unused.

    Returns:
        1-based prefix sums array S with:
            - S[0] = 0,
            - S[k] = sum_{i=1}^k a[i].
    </span><span class="sh">"""</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">running</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
        <span class="n">running</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">running</span>
    <span class="k">return</span> <span class="n">S</span>
</code></pre></div></div> <p>The first function, <code class="language-plaintext highlighter-rouge">build_sequence_naive</code>, constructs the sequence values \(a_1,a_2,\dots,a_{N+1}\) directly from the recurrence by iterating over all indices up to \(N\). The second function, <code class="language-plaintext highlighter-rouge">prefix_sums_naive</code>, then computes the prefix sums \(S(k)=\sum_{i=1}^k a_i\) in a single linear pass. Together, these two routines implement the most direct solution to the problem: explicit sequence generation followed by explicit summation. This approach is simple and transparent, but its runtime grows linearly with \(N\), which makes it unsuitable for very large inputs. The following example demonstrates how the naive implementation can be used for moderate values of \(N\). We generate the sequence, inspect the first few terms, and finally compute the prefix sum \(S(N)\).</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">10_000</span>
<span class="n">a1</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="o">-</span><span class="mi">33</span>

<span class="n">a</span> <span class="o">=</span> <span class="nf">build_sequence_naive</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">a1</span><span class="o">=</span><span class="n">a1</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>

<span class="c1"># Show the first few terms a_1..a_20 (ignore a[0]).
</span><span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">21</span><span class="p">])</span>

<span class="c1"># Prefix sums S(k) = sum_{i=1}^k a_i in O(N).
</span><span class="n">S</span> <span class="o">=</span> <span class="nf">prefix_sums_naive</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="c1"># This is S(N).
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">S(N):</span><span class="sh">"</span><span class="p">,</span> <span class="n">S</span><span class="p">[</span><span class="n">N</span><span class="p">])</span>
</code></pre></div></div> <p>In this example, we fix concrete values for the parameters \(a_1\), \(q\), \(r\), and \(t\), and choose a moderately large bound \(N = 10\,000\). The sequence is first generated explicitly up to index \(N+1\) using the naive construction. Printing the first few terms provides a quick sanity check that the recurrence is applied as expected. Afterwards, the prefix sums are computed in linear time, and the final value \(S(N)\) is obtained by a simple array lookup. For values of \(N\) on this scale, this approach works well and is easy to understand—but it already hints at why a different strategy is needed when \(N\) becomes much larger. Before moving on to the optimized algorithm, it is helpful to <em>see</em> what this recurrence produces.</p> <p>The following plot shows the sequence values \(a_n\) and their corresponding prefix sums \(S(n)\) for a fixed choice of parameters and a moderate range of indices. Even at this scale, the behavior is far from simple: the sequence oscillates, changes magnitude rapidly, and the prefix sums reflect a complex accumulation of these effects. This visual complexity hints at why a naive summation strategy quickly becomes unwieldy—and why exploiting the structure of the recurrence is essential.</p> <p><br></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2026-01-10-pe-818p100-generalized-parity-recurrence/2026-01-10-pe-818p100-generalized-parity-recurrence-480.webp 480w,/assets/img/2026-01-10-pe-818p100-generalized-parity-recurrence/2026-01-10-pe-818p100-generalized-parity-recurrence-800.webp 800w,/assets/img/2026-01-10-pe-818p100-generalized-parity-recurrence/2026-01-10-pe-818p100-generalized-parity-recurrence-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2026-01-10-pe-818p100-generalized-parity-recurrence/2026-01-10-pe-818p100-generalized-parity-recurrence.png" class="img-fluid rounded z-depth-1 imgcenter" width="95%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <b>Figure 1:</b> The parity-defined sequence $a_n$ (top) and its prefix sums $S(n)$ (bottom) for fixed parameters. Even at moderate sizes, the behavior is highly irregular. </figcaption> </figure> <p><br></p> <h3 id="an-optimized-prefix-sum-algorithm">An Optimized Prefix-Sum Algorithm</h3> <p>The naive approach makes the difficulty of the problem clear: explicitly generating the sequence and summing its terms requires time proportional to \(N\), which quickly becomes infeasible.</p> <p>We now turn to an optimized algorithm that avoids this bottleneck entirely. Instead of iterating over all indices up to \(N\), the method exploits the parity-based structure of the recurrence derived earlier.</p> <p>The key idea is to process the binary representation of \(N\) from left to right, maintaining only a <strong>constant-size state</strong> that contains just enough information to update the prefix sum when the index is doubled or incremented by one. At each step, the problem size is effectively cut in half.</p> <p>At a high level, the algorithm can be summarized as follows:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>initialize state at n = 1
for each remaining binary digit of N (left to right):
    precompute S(2n), S(2n+1), a_{2n}, a_{2n+1}, a_{2n+2}
    if bit == 0:
        update state to n = 2n
    else:
        update state to n = 2n + 1
return S(N)
</code></pre></div></div> <p>The full implementation below is a direct and faithful translation of this idea.</p> <p>As a result, the number of operations grows only with the number of binary digits of \(N\), making it possible to compute \(S(N)\) even for astronomically large values of \(N\). The following implementation is a direct translation of the derivation above into code.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>


<span class="k">def</span> <span class="nf">prefix_sum_a</span><span class="p">(</span>
    <span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">a1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">q</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">r</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">t</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Compute the prefix sum S(N) for a parity-defined recurrence in O(log N).

    We consider a sequence $(a_n)_{n</span><span class="se">\\</span><span class="s">ge 1}$ defined by constants $q, r, t$:

    $$
    </span><span class="se">\\</span><span class="s">begin{aligned}
    a_{2n}   &amp;= q</span><span class="se">\\</span><span class="s">,a_n, </span><span class="se">\\\\</span><span class="s">
    a_{2n+1} &amp;= r</span><span class="se">\\</span><span class="s">,a_n + t</span><span class="se">\\</span><span class="s">,a_{n+1},
    </span><span class="se">\\</span><span class="s">end{aligned}
    </span><span class="se">\\</span><span class="s">qquad (n</span><span class="se">\\</span><span class="s">ge 1),
    $$

    with given initial value $a_1 = a1$.

    The associated prefix sums are

    $$
    S(n) = </span><span class="se">\\</span><span class="s">sum_{k=1}^{n} a_k, </span><span class="se">\\</span><span class="s">qquad S(0)=0.
    $$

    Using the derived identities

    $$
    S(2n)   = (q+t)</span><span class="se">\\</span><span class="s">,S(n) + r</span><span class="se">\\</span><span class="s">,S(n-1) + (1-t)</span><span class="se">\\</span><span class="s">,a_1,
    $$
    $$
    S(2n+1) = S(2n) + r</span><span class="se">\\</span><span class="s">,a_n + t</span><span class="se">\\</span><span class="s">,a_{n+1},
    $$

    we can compute $S(N)$ by walking through the binary representation of $N$
    and maintaining the constant-size state

        (S(n-1), S(n), a_n, a_{n+1})

    which is updated according to whether the next binary digit corresponds to
    $n </span><span class="se">\\</span><span class="s">mapsto 2n$ (bit 0) or $n </span><span class="se">\\</span><span class="s">mapsto 2n+1$ (bit 1).

    Args:
        N:
            Target index (must satisfy N &gt;= 1).
        a1:
            Initial value $a_1$ of the sequence.
        q:
            Constant in the even-index recurrence $a_{2n} = q</span><span class="se">\\</span><span class="s">,a_n$.
        r:
            Constant in the odd-index recurrence $a_{2n+1} = r</span><span class="se">\\</span><span class="s">,a_n + t</span><span class="se">\\</span><span class="s">,a_{n+1}$.
        t:
            Constant in the odd-index recurrence $a_{2n+1} = r</span><span class="se">\\</span><span class="s">,a_n + t</span><span class="se">\\</span><span class="s">,a_{n+1}$.

    Returns:
        The prefix sum $S(N) = </span><span class="se">\\</span><span class="s">sum_{k=1}^{N} a_k$.

    Raises:
        ValueError: If N &lt; 1.

    Notes:
        - This implementation is numerically and type-wise </span><span class="sh">"</span><span class="s">honest</span><span class="sh">"</span><span class="s">: it supports
          `int` and `float` (and mixtures thereof) and returns `int | float`.
        - Runtime is O(log N) and memory usage is O(1).
    </span><span class="sh">"""</span>
    <span class="c1"># Guard against invalid input: the sequence is defined for N &gt;= 1.
</span>    <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">N must be &gt;= 1</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># Process the binary digits of N from left to right.
</span>    <span class="c1"># The leading '1' corresponds to n = 1, which we encode in the initial state,
</span>    <span class="c1"># so we iterate over the remaining digits only.
</span>    <span class="n">bits</span> <span class="o">=</span> <span class="nf">format</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">tail_bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Maintain the state at the current index n:
</span>    <span class="c1">#
</span>    <span class="c1">#   S_nm1 = S(n-1) = sum_{k=1}^{n-1} a_k
</span>    <span class="c1">#   S_n   = S(n)   = sum_{k=1}^{n}   a_k
</span>    <span class="c1">#   a_n   = a_n
</span>    <span class="c1">#   a_np1 = a_{n+1}
</span>    <span class="c1">#
</span>    <span class="c1"># Initialize at n = 1:
</span>    <span class="c1">#   S(0) = 0
</span>    <span class="c1">#   S(1) = a1
</span>    <span class="c1">#   a_1  = a1
</span>    <span class="c1">#   a_2  = q * a1
</span>    <span class="n">S_nm1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">S_n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">a1</span>
    <span class="n">a_n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">a1</span>
    <span class="n">a_np1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="n">a1</span>

    <span class="c1"># Update the state for each remaining bit.
</span>    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">tail_bits</span><span class="p">:</span>
        <span class="c1"># Precompute prefix sums at doubled indices:
</span>        <span class="c1">#
</span>        <span class="c1">#   S(2n)   = (q+t) S(n) + r S(n-1) + (1-t) a1
</span>        <span class="c1">#   S(2n+1) = S(2n) + r a_n + t a_{n+1}
</span>        <span class="c1">#
</span>        <span class="c1"># These are computed unconditionally; which one we "land on" depends on
</span>        <span class="c1"># the next binary digit.
</span>        <span class="n">S_2n</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">S_nm1</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">S_n</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">a1</span>
        <span class="n">S_2np1</span> <span class="o">=</span> <span class="n">S_2n</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">a_n</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">a_np1</span>

        <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="sh">"</span><span class="s">1</span><span class="sh">"</span><span class="p">:</span>
            <span class="c1"># Bit 1: n -&gt; 2n + 1
</span>            <span class="c1">#
</span>            <span class="c1"># Sequence updates:
</span>            <span class="c1">#   a_{2n+1} = r a_n + t a_{n+1}
</span>            <span class="c1">#   a_{2n+2} = q a_{n+1}
</span>            <span class="n">new_a_n</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">a_n</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">a_np1</span>
            <span class="n">new_a_np1</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="n">a_np1</span>

            <span class="c1"># Prefix sum updates:
</span>            <span class="c1">#   S((2n+1)-1) = S(2n)
</span>            <span class="c1">#   S(2n+1)     = S_2np1
</span>            <span class="n">S_nm1</span><span class="p">,</span> <span class="n">S_n</span> <span class="o">=</span> <span class="n">S_2n</span><span class="p">,</span> <span class="n">S_2np1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Bit 0: n -&gt; 2n
</span>            <span class="c1">#
</span>            <span class="c1"># Sequence updates:
</span>            <span class="c1">#   a_{2n}   = q a_n
</span>            <span class="c1">#   a_{2n+1} = r a_n + t a_{n+1}
</span>            <span class="n">new_a_n</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="n">a_n</span>
            <span class="n">new_a_np1</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">a_n</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">a_np1</span>

            <span class="c1"># Prefix sum updates:
</span>            <span class="c1">#   S(2n)   = S_2n
</span>            <span class="c1">#   S(2n-1) = S(2n) - a_{2n}
</span>            <span class="n">S_nm1</span><span class="p">,</span> <span class="n">S_n</span> <span class="o">=</span> <span class="n">S_2n</span> <span class="o">-</span> <span class="n">new_a_n</span><span class="p">,</span> <span class="n">S_2n</span>

        <span class="c1"># Advance the sequence state.
</span>        <span class="n">a_n</span><span class="p">,</span> <span class="n">a_np1</span> <span class="o">=</span> <span class="n">new_a_n</span><span class="p">,</span> <span class="n">new_a_np1</span>

    <span class="c1"># After all bits have been processed, S_n = S(N).
</span>    <span class="k">return</span> <span class="n">S_n</span>
</code></pre></div></div> <p>The function <code class="language-plaintext highlighter-rouge">prefix_sum_a</code> computes the prefix sum \(S(N)\) without ever constructing the full sequence.</p> <p>It walks through the binary digits of \(N\) and maintains the four values \(\bigl(S(n-1), S(n), a_n, a_{n+1}\bigr)\) as its internal state. For each bit, the state is updated according to whether the index transition is \(n \mapsto 2n\) or \(n \mapsto 2n+1\), using the closed-form recurrences derived earlier.</p> <p>Because each binary digit of \(N\) triggers only a constant amount of work, the overall runtime is proportional to the bit-length of \(N\). This allows exact prefix sums to be computed for values of \(N\) that are far beyond the reach of any direct summation approach.</p> <p>As a quick sanity check, we can compare the naive result (computed by explicitly building the sequence and its prefix sums) with the optimized function. For a moderate value of \(N\) both methods are feasible, so they should agree exactly.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Compare naive approach with optimized code for a (small) N.
</span><span class="n">slow</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
<span class="n">fast</span> <span class="o">=</span> <span class="nf">prefix_sum_a</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">naive S(N):</span><span class="sh">"</span><span class="p">,</span> <span class="n">slow</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">fast  S(N):</span><span class="sh">"</span><span class="p">,</span> <span class="n">fast</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="p">,</span> <span class="sh">"</span><span class="s">Mismatch between naive and optimized result!</span><span class="sh">"</span>
</code></pre></div></div> <p>To further increase confidence in the implementation, we can perform a full verification on a small range of indices. For a fixed, moderately sized bound \(N\), the naive method allows us to compute all prefix sums \(S(1), S(2), \dots, S(N)\) explicitly.</p> <p>The following loop compares these reference values against the optimized algorithm for <em>every</em> index up to \(N\). If the derivation and implementation are correct, all results must match exactly.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Verify that the optimized O(log n) algorithm matches the naive result
# for all n &lt;= N.
</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">fast</span> <span class="o">=</span> <span class="nf">prefix_sum_a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">slow</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">fast</span> <span class="o">!=</span> <span class="n">slow</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nc">AssertionError</span><span class="p">(</span>
            <span class="sa">f</span><span class="sh">"</span><span class="s">Mismatch at n=</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s">: </span><span class="sh">"</span>
            <span class="sa">f</span><span class="sh">"</span><span class="s">fast=</span><span class="si">{</span><span class="n">fast</span><span class="si">}</span><span class="s">, slow=</span><span class="si">{</span><span class="n">slow</span><span class="si">}</span><span class="sh">"</span>
        <span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Verification passed: optimized and naive prefix sums match for all n &lt;= </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s">.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p><br></p> <h3 id="demonstrating-the-power-of-the-optimized-algorithm">Demonstrating the Power of the Optimized Algorithm</h3> <p>The true strength of the approach becomes apparent when we push it far beyond the range where any naive method could possibly work.</p> <p>Since the optimized algorithm performs one constant-time update per binary digit of \(N\), its runtime depends only on the <strong>bit-length</strong> of \(N\), not on \(N\) itself. This makes it feasible to compute prefix sums for indices that are astronomically large.</p> <p>The following example evaluates \(S(N)\) for a selection of increasingly large values of \(N\)—ranging from millions to numbers with dozens of digits. Even the so-called “worst-case” bit patterns, where all binary digits are equal to one, are handled just as easily.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Demonstration: huge N is easy with the O(log N) method.
</span>
<span class="n">a1</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="o">-</span><span class="mi">33</span>

<span class="n">test_Ns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span>
    <span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">,</span>
    <span class="mi">10</span><span class="o">**</span><span class="mi">12</span><span class="p">,</span>
    <span class="mi">10</span><span class="o">**</span><span class="mi">15</span><span class="p">,</span>
    <span class="mi">10</span><span class="o">**</span><span class="mi">18</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">60</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>   <span class="c1"># ~1.15e18 (all 1-bits, "worst-case" bit-pattern)
</span>    <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">80</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="mi">10</span><span class="o">**</span><span class="mi">30</span><span class="p">,</span>          <span class="c1"># absurdly large, still fine
</span><span class="p">]</span>

<span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">test_Ns</span><span class="p">:</span>
    <span class="n">S_N</span> <span class="o">=</span> <span class="nf">prefix_sum_a</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">N=</span><span class="si">{</span><span class="n">N</span><span class="si">:</span><span class="o">&lt;</span><span class="mi">32</span><span class="si">}</span><span class="s">  bits=</span><span class="si">{</span><span class="n">N</span><span class="p">.</span><span class="nf">bit_length</span><span class="p">()</span><span class="si">:</span><span class="o">&gt;</span><span class="mi">3</span><span class="si">}</span><span class="s">  S(N)=</span><span class="si">{</span><span class="n">S_N</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>This final demonstration highlights the central takeaway: once the hidden structure of the recurrence is exposed, computing a sum of \(N\) terms no longer requires work proportional to \(N\)—only to the number of bits needed to write \(N\) down.</p> <p><br></p> <h2 id="summary">Summary</h2> <p>We started with a simple recurrence that defines a sequence by splitting indices into even and odd cases. While computing individual terms is easy, the task of summing the first \(N\) terms quickly becomes infeasible when \(N\) is large.</p> <p>By carefully analyzing how the recurrence behaves under index doubling, we derived closed formulas for the prefix sums \(S(2n)\) and \(S(2n+1)\). These relations reveal a hidden binary structure: prefix sums at large indices can be expressed entirely in terms of much smaller ones, together with a small amount of local state.</p> <p>This insight leads directly to an efficient algorithm that processes the binary representation of \(N\) and maintains only a constant-size state. As a result, the prefix sum \(S(N)\) can be computed exactly in time proportional to the number of bits of \(N\), rather than to \(N\) itself.</p> <p>The contrast between the naive and optimized implementations highlights a recurring theme in algorithmic mathematics: once the right structure is identified, problems that initially appear intractable can often be solved with surprising efficiency.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://blog.google/technology/ai/google-gemini-update-flash-ai-assistant-io-2024/" target="_blank" rel="external nofollow noopener">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://medium.com/@al-folio/displaying-external-posts-on-your-al-folio-blog-b60a1d241a0a?source=rss-17feae71c3c4------2" target="_blank" rel="external nofollow noopener">Displaying External Posts on Your al-folio Blog</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/pe-785p100-hexadecimal-digit-canon/">The Hexadecimal Digit Canon Challenge</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/pe-83p100-quanity-equal-parts/">Short Notes: Equal Partitions, Products, and Decimal Structure</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/pe-844p100-divisors-sets/">Short Notes: Summing Non-Isolated Divisors Across All Subsets</a> </li> <div id="giscus_thread" style="max-width: 1000px; margin: 0 auto;"> <br> <script defer src="/assets/js/giscus-setup.js"></script> <noscript> Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Markus Thill. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a> and from <a href="https://www.freepik.com/" rel="external nofollow noopener" target="_blank">Freepik</a>. Last updated: January 22, 2026. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?v=a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?v=85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?v=2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?v=b608866baffe761c7f8f7670a3310d0f"></script> <script defer src="/assets/js/copy_code.js?v=c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?v=d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?v=a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?v=2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/tabs.min.js?v=b8748955e1076bbe0dabcf28f2549fdc"></script> <script type="module" src="/assets/js/search/ninja-keys.min.js?v=a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?v=6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?v=6f508d74becd347268a7f822bca7309d"></script> </body> </html>