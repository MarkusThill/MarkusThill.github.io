<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> The Hexadecimal Digit Canon Challenge: Solution | Markus Thill </title> <meta name="author" content="Markus Thill"> <meta name="description" content=""> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' data: https:; media-src 'self' https:; frame-src 'self' https:; connect-src 'self' https:;"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?v=a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?v=f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?v=62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?v=591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8D%95&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?v=d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://markusthill.github.io/blog/2026/pe-785p100-hexadecimal-digit-canon-solution/"> <script src="/assets/js/theme.js?v=48c9b5bd7f2e0605e39e579400e22553"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?v=5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Markus</span> Thill </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/"> </a> </li> <li class="nav-item "> <a class="nav-link" href="/about">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/index.html">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/projects/">projects</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="fa-solid fa-magnifying-glass"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-half-sun-moon" id="light-toggle-system"></i> <i class="fa-solid fa-moon" id="light-toggle-dark"></i> <i class="fa-solid fa-sun" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">The Hexadecimal Digit Canon Challenge: Solution</h1> <p class="post-meta"> Created on January 29, 2026 </p> <p class="post-tags"> <a href="/blog/2026"> <i class="fa-solid fa-calendar fa-sm"></i> 2026 </a> ¬† ¬∑ ¬† <a href="/blog/tag/combinatorics"> <i class="fa-solid fa-hashtag fa-sm"></i> combinatorics</a> ¬† <a href="/blog/tag/discrete-math"> <i class="fa-solid fa-hashtag fa-sm"></i> discrete-math</a> ¬† <a href="/blog/tag/algorithms"> <i class="fa-solid fa-hashtag fa-sm"></i> algorithms</a> ¬† <a href="/blog/tag/optimization"> <i class="fa-solid fa-hashtag fa-sm"></i> optimization</a> ¬† <a href="/blog/tag/python"> <i class="fa-solid fa-hashtag fa-sm"></i> python</a> ¬† ¬∑ ¬† <a href="/blog/category/programming"> <i class="fa-solid fa-tag fa-sm"></i> programming</a> ¬† <a href="/blog/category/algorithms"> <i class="fa-solid fa-tag fa-sm"></i> algorithms</a> ¬† <a href="/blog/category/mathematics"> <i class="fa-solid fa-tag fa-sm"></i> mathematics</a> </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h3"><a href="#the-digitcanonical-function">The Digit‚ÄìCanonical Function</a></li> <li class="toc-entry toc-h3"><a href="#examples">Examples</a></li> <li class="toc-entry toc-h3"><a href="#the-cumulative-sum">The Cumulative Sum</a></li> <li class="toc-entry toc-h2"><a href="#challenge-levels-">Challenge Levels üèÖ</a></li> <li class="toc-entry toc-h2"> <a href="#solution-sketch">Solution Sketch</a> <ul> <li class="toc-entry toc-h3"><a href="#a-first-naive-implementation">A first (naive) implementation</a></li> <li class="toc-entry toc-h3"><a href="#computing-sn-by-enumerating-distinct-fd-values-and-their-multiplicities">Computing $S(n)$ by enumerating distinct $f(d)$ values (and their multiplicities)</a></li> <li class="toc-entry toc-h3"><a href="#from-brute-force-to-digit-dynamics-building-a-much-faster-solution">From Brute Force to Digit Dynamics: Building a Much Faster Solution</a></li> <li class="toc-entry toc-h3"><a href="#computing-bk-efficiently-dp">Computing $B(k)$ efficiently (DP)</a></li> <li class="toc-entry toc-h3"><a href="#eliminating-fractions-scaling-away-the-factorial-denominators">Eliminating Fractions: Scaling away the Factorial Denominators</a></li> <li class="toc-entry toc-h3"><a href="#modular-solution--part-i-using-modular-inverses-intentionally-unoptimized">Modular Solution ‚Äì Part I: Using Modular Inverses (Intentionally Unoptimized)</a></li> <li class="toc-entry toc-h3"><a href="#modular-solution--part-ii-practical-optimizations-caching--precomputation">Modular Solution ‚Äì Part II: Practical Optimizations (Caching &amp; Precomputation)</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <p>In the Hexadecimal Canon, every number is first stripped of all insignificant zeros and reordered into its most ‚Äúpure‚Äù form. The value of a number is not what it looks like at first glance, but what remains after this canonical purification.</p> <p>All numbers in this problem are written in <strong>base 16 (hexadecimal)</strong>. The available digits are</p> \[0,1,2,3,4,5,6,7,8,9,\text{A},\text{B},\text{C},\text{D},\text{E},\text{F},\] <p>with \(\text{A}=10,\dots,\text{F}=15.\)</p> <p><br></p> <h3 id="the-digitcanonical-function">The Digit‚ÄìCanonical Function</h3> <p>For any <strong>positive hexadecimal integer</strong> \(d &gt; 0\), define the function \(f(d)\) as follows:</p> <ol> <li>Write \(d\) in hexadecimal.</li> <li>Sort its hexadecimal digits in <strong>ascending order</strong>.</li> <li>Remove <strong>all zero digits</strong>.</li> <li>Interpret the remaining digits again as a hexadecimal number.</li> </ol> <p>Since $d &gt; 0$, removing zero digits always leaves at least one hexadecimal digit.</p> <p><br></p> <h3 id="examples">Examples</h3> <ul> <li> <p><strong>Example 1:</strong> \(d = \texttt{0x3A04}\). Digits: \(3, A, 0, 4.\) Sorted: \(0, 3, 4, A.\) Remove zeros ‚Üí \(3, 4, A\). Result: \(f(\texttt{0x3A04}) = \texttt{0x34A}\)</p> </li> <li> <p><strong>Example 2</strong> \(d = \texttt{0xF102}\). Digits: \(F, 1, 0, 2\). Sorted: \(0, 1, 2, F\). Remove zeros ‚Üí \(1, 2, F\). Result: \(f(\texttt{0xF102}) = \texttt{0x12F}\)</p> </li> <li> <p><strong>Example 3</strong> \(d = \texttt{0x800}\). Digits: \(8, 0, 0\). Sorted: \(0, 0, 8\). Remove zeros ‚Üí \(8\). Result: \(f(\texttt{0x800}) = \texttt{0x8}\)</p> </li> <li> <p><strong>Example 4:</strong> $d = \texttt{0xA11B0}$. Digits: $A,1,1,B,0$. Sorted: $0,1,1,A,B$. Remove zeros ‚Üí $1,1,A,B$. Result: $f(\texttt{0xA11B0}) = \texttt{0x11AB}$.</p> </li> </ul> <p><br></p> <h3 id="the-cumulative-sum">The Cumulative Sum</h3> <p>Let \(S(n)\) denote the sum of \(f(d)\) over <strong>all positive hexadecimal integers with at most \(n\) hexadecimal digits</strong>.</p> <p>For example:</p> <ul> <li>For \(n = \texttt{0x1}\), the result is \(S(\texttt{0x1}) = \texttt{0x78}\)</li> <li>For \(n = \texttt{0x3}\), the result is \(S(\texttt{0x3}) = \texttt{0x4077C0}\)</li> </ul> <blockquote> <p><strong>Important:</strong> All values of \(S(n)\) are to be reported <strong>in hexadecimal notation</strong>.</p> </blockquote> <p><br></p> <h2 id="challenge-levels-">Challenge Levels üèÖ</h2> <p>Compute \(S(n)\) for the following four difficulty tiers:</p> <table> <thead> <tr> <th>Tier</th> <th>Value of \(n\) (hexadecimal)</th> <th>Your Result (hexadecimal)</th> </tr> </thead> <tbody> <tr> <td>üéó Warm-up</td> <td>\(n = \; \texttt{0x5}\)</td> <td>\(S(n) = \;\_\_\_\_\_\_\_\_\_\_\_\_\)</td> </tr> <tr> <td>ü•â Bronze</td> <td>\(n = \; \texttt{0xA}\)</td> <td>\(S(n) = \;\_\_\_\_\_\_\_\_\_\_\_\_\)</td> </tr> <tr> <td>ü•à Silver</td> <td>\(n = \; \texttt{0xAA}\)</td> <td>\(S(n) = \;\_\_\_\_\_\_\_\_\_\_\_\_\, \,\) (first &amp; last 10 hex digits)</td> </tr> <tr> <td>ü•á Gold</td> <td>\(n = \; \texttt{0xAAA}\)</td> <td>\(S(n) \equiv \;\_\_\_\_\_\_\_\_\_\_\_\_ \pmod{\texttt{0x1FFFFFFFFFFFFFFF}}\)</td> </tr> </tbody> </table> <p><br></p> <p>For the <strong>silver</strong> medal, report <strong>only</strong> the <strong>first 10</strong> and <strong>last 10</strong> hexadecimal digits of \(S(n)\).<br> Here, ‚Äúfirst 10‚Äù means the first 10 digits of the standard hexadecimal representation of \(S(n)\), and ‚Äúlast 10‚Äù means the last 10 digits (equivalently \(S(n) \bmod 16^{10}\)). The problem is designed so that <strong>neither part has leading zeros</strong>, and both substrings consist of exactly 10 hexadecimal digits.</p> <p>For the <strong>gold</strong> medal, report your hexadecimal answer <strong>modulo</strong> \(\texttt{0x1FFFFFFFFFFFFFFF}.\)</p> <p><br></p> <hr> <h2 id="solution-sketch">Solution Sketch</h2> <h3 id="a-first-naive-implementation">A first (naive) implementation</h3> <p>Before attempting any optimizations, it is helpful to translate the problem statement <strong>as literally as possible</strong> into code. The following implementation does exactly that: it follows the definition of the function \(f(d)\) and the cumulative sum \(S(n)\) step by step, without attempting to reduce the computational cost. The core idea is straightforward:</p> <ul> <li>Enumerate <strong>all positive integers \(d\)</strong> with at most \(n\) digits in the chosen base (8, 10, or 16).</li> <li>For each \(d\): <ul> <li>Convert it to its digit representation in that base,</li> <li>Sort the digits in ascending order,</li> <li>Remove all zeros,</li> <li>Interpret the remaining digits again as a number to obtain \(f(d)\).</li> </ul> </li> <li>Accumulate the sum of all \(f(d)\) values to obtain \(S(n)\).</li> </ul> <p>This approach has several important characteristics:</p> <ul> <li>Conceptual clarity: Each operation in the code mirrors the mathematical definition directly, making it easy to reason about correctness.</li> <li>Generality: The same implementation works unchanged for base 8, base 10, and base 16, which is useful for experimentation and cross-checking small cases.</li> <li>Very poor scalability: The number of values that must be processed grows as \(\text{base}^n\). Even for modest values of \(n\), this results in an enormous number of iterations, rendering the method impractical for the actual challenge.</li> <li>Reference value generation: Despite its inefficiency, the naive solution plays an important role: it provides trustworthy results for small \(n\), which can later be used to validate faster, more sophisticated approaches.</li> </ul> <p>In the next sections, we will keep this implementation as a correctness baseline and progressively replace the brute-force enumeration by more efficient combinatorial and dynamic-programming techniques.</p> <p>For \(n = 3\), we can already confirm the result obtained above:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="c1"># We only need very lightweight helpers here; this is intentionally a
# *naive* reference implementation that favors clarity over performance.
</span>

<span class="k">def</span> <span class="nf">_format_base</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Return the base-`base` representation of `d` as a string.

    We restrict ourselves to bases 8, 10, and 16:
      - base 8  -&gt; octal digits 0‚Äì7
      - base 10 -&gt; decimal digits 0‚Äì9
      - base 16 -&gt; hexadecimal digits 0‚Äì9, a‚Äìf

    The returned string uses lowercase letters for hexadecimal digits.
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
        <span class="c1"># Decimal needs no special formatting
</span>        <span class="k">return</span> <span class="nf">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="c1"># Python's built-in octal formatter
</span>        <span class="k">return</span> <span class="nf">format</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="sh">"</span><span class="s">o</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
        <span class="c1"># Python's built-in hexadecimal formatter (lowercase)
</span>        <span class="k">return</span> <span class="nf">format</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="sh">"</span><span class="s">x</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># Any other base is deliberately rejected to keep the code simple
</span>    <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Unsupported base=</span><span class="si">{</span><span class="n">base</span><span class="si">}</span><span class="s">. Use one of: 8, 10, 16.</span><span class="sh">"</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">f_of_d</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Compute f(d) in the given base.

    This follows the problem definition *literally*:

      1) Write d in the chosen base.
      2) Sort the digits in ascending order.
      3) Remove all zero digits.
      4) Interpret the remaining digits again as a number in that base.

    Example (base 16):
      d = 0x3A04  -&gt; </span><span class="sh">"</span><span class="s">3a04</span><span class="sh">"</span><span class="s">
      digits     -&gt; [</span><span class="sh">"</span><span class="s">3</span><span class="sh">"</span><span class="s">, </span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="s">, </span><span class="sh">"</span><span class="s">0</span><span class="sh">"</span><span class="s">, </span><span class="sh">"</span><span class="s">4</span><span class="sh">"</span><span class="s">]
      sorted     -&gt; [</span><span class="sh">"</span><span class="s">0</span><span class="sh">"</span><span class="s">, </span><span class="sh">"</span><span class="s">3</span><span class="sh">"</span><span class="s">, </span><span class="sh">"</span><span class="s">4</span><span class="sh">"</span><span class="s">, </span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="s">]
      no zeros   -&gt; [</span><span class="sh">"</span><span class="s">3</span><span class="sh">"</span><span class="s">, </span><span class="sh">"</span><span class="s">4</span><span class="sh">"</span><span class="s">, </span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="s">]
      result     -&gt; int(</span><span class="sh">"</span><span class="s">34a</span><span class="sh">"</span><span class="s">, 16)
    </span><span class="sh">"""</span>
    <span class="c1"># Convert d to a string in the given base
</span>    <span class="n">s</span> <span class="o">=</span> <span class="nf">_format_base</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>

    <span class="c1"># Remove all '0' digits, because f(d) discards them by definition.
</span>    <span class="c1"># The result is a list of digit *characters*.
</span>    <span class="n">digits_no_zero</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">ch</span> <span class="o">!=</span> <span class="sh">"</span><span class="s">0</span><span class="sh">"</span><span class="p">]</span>

    <span class="c1"># Sort remaining digits in ascending order.
</span>    <span class="c1">#
</span>    <span class="c1"># Important subtlety:
</span>    <span class="c1"># - For base 8 and 10, lexicographic order equals numeric order.
</span>    <span class="c1"># - For base 16, Python uses characters '0'‚Äì'9','a'‚Äì'f', and their
</span>    <span class="c1">#   lexicographic order also matches numeric digit order.
</span>    <span class="n">digits_no_zero</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>

    <span class="c1"># There is always at least one non-zero digit:
</span>    <span class="c1"># any representation of a positive integer contains at least one
</span>    <span class="c1"># non-zero digit in any base.
</span>    <span class="n">canonical_str</span> <span class="o">=</span> <span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">digits_no_zero</span><span class="p">)</span>

    <span class="c1"># Convert back to an integer, interpreting the string in the same base
</span>    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">canonical_str</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">S_naive</span><span class="p">(</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">base</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">debug_target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">Naively compute S(n) by brute force.

    We enumerate *all* positive integers d with at most n digits in the
    given base, i.e.

        1 &lt;= d &lt; base**n

    For each such d, we compute f(d) and accumulate the sum.

    This function is intentionally slow and is meant only as:
      - a correctness reference
      - a debugging / sanity-check tool

    Returns:
      total:
          The value of S(n) as a Python integer.
      debug_hits:
          All d such that f(d) == debug_target (empty if debug_target is None).
      num_values:
          Total number of integers d that were enumerated.
      num_distinct:
          Number of distinct values taken by f(d).
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">n must be a positive integer.</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">base</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">base must be one of: 8, 10, 16.</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># All positive integers with &lt;= n digits in base `base` satisfy
</span>    <span class="c1">#   1 &lt;= d &lt; base**n
</span>    <span class="n">upper_exclusive</span> <span class="o">=</span> <span class="n">base</span><span class="o">**</span><span class="n">n</span>

    <span class="n">debug_hits</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Track which f(d) values we have seen so far
</span>    <span class="n">seen</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>

    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>           <span class="c1"># running sum S(n)
</span>    <span class="n">num_distinct</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c1"># number of distinct f(d) values
</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">upper_exclusive</span><span class="p">):</span>
        <span class="c1"># Compute f(d) directly from the definition
</span>        <span class="n">f_d</span> <span class="o">=</span> <span class="nf">f_of_d</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>

        <span class="c1"># Add contribution to the total sum
</span>        <span class="n">total</span> <span class="o">+=</span> <span class="n">f_d</span>

        <span class="c1"># Count distinct f(d) values (purely diagnostic)
</span>        <span class="k">if</span> <span class="n">f_d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="n">seen</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">f_d</span><span class="p">)</span>
            <span class="n">num_distinct</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Optional debugging hook:
</span>        <span class="c1"># record which original d map to a particular f(d)
</span>        <span class="k">if</span> <span class="n">debug_target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">f_d</span> <span class="o">==</span> <span class="n">debug_target</span><span class="p">:</span>
            <span class="n">debug_hits</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="c1"># Number of values enumerated (purely diagnostic)
</span>    <span class="n">num_values</span> <span class="o">=</span> <span class="n">upper_exclusive</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">total</span><span class="p">,</span> <span class="n">debug_hits</span><span class="p">,</span> <span class="n">num_values</span><span class="p">,</span> <span class="n">num_distinct</span>


<span class="k">def</span> <span class="nf">format_answer</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Format the final answer in the requested output base.

    This is useful because the *internal* computation uses Python integers,
    but the puzzle statement asks for answers written in base 8/10/16.
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="sh">"</span><span class="s">o</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
        <span class="c1"># Uppercase hex looks nicer and is common in math puzzles
</span>        <span class="k">return</span> <span class="nf">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="sh">"</span><span class="s">X</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Unsupported base=</span><span class="si">{</span><span class="n">base</span><span class="si">}</span><span class="s">.</span><span class="sh">"</span><span class="p">)</span>


<span class="c1"># ---------------------------------------------------------------------
# Example usage
# ---------------------------------------------------------------------
</span>
<span class="n">base</span> <span class="o">=</span> <span class="mi">16</span>          <span class="c1"># choose 8, 10, or 16
</span><span class="n">n</span> <span class="o">=</span> <span class="mh">0x3</span>              <span class="c1"># compute S(n)
</span>
<span class="c1"># Set to an integer (in base-10) to see which d map to that f(d),
# or set to None to disable debugging.
</span><span class="n">debug_target</span> <span class="o">=</span> <span class="mh">0xDF</span>

<span class="n">ans</span><span class="p">,</span> <span class="n">debug_hits</span><span class="p">,</span> <span class="n">num_values</span><span class="p">,</span> <span class="n">num_distinct</span> <span class="o">=</span> <span class="nc">S_naive</span><span class="p">(</span>
    <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
    <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span>
    <span class="n">debug_target</span><span class="o">=</span><span class="n">debug_target</span><span class="p">,</span>
<span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">num_values   =</span><span class="sh">"</span><span class="p">,</span> <span class="n">num_values</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">num_distinct =</span><span class="sh">"</span><span class="p">,</span> <span class="n">num_distinct</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">debug_hits   =</span><span class="sh">"</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">debug_hits</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">S(n)         =</span><span class="sh">"</span><span class="p">,</span> <span class="nf">format_answer</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">base</span><span class="p">))</span>
</code></pre></div></div> <p>Output:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>num_values   = 4095
num_distinct = 815
debug_hits   = 6
S(n)         = 4077C0
</code></pre></div></div> <p>If we change $n$ in above code to <code class="language-plaintext highlighter-rouge">0x5</code>, we already earn our first award (üéó Warm-up):</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>num_values   = 1048575
num_distinct = 15503
debug_hits   = 20
S(n)         = 286D8F92C0
</code></pre></div></div> <p><br></p> <p><em>Counting Distinct Values: Naive Approach</em></p> <p>As a small extension of the previous brute-force method, the following code counts how many <strong>distinct values of \(f(d)\)</strong> appear when considering all numbers with at most \(n\) digits in a given base (8, 10, or 16).</p> <p>The implementation again mirrors the definition directly: for each \(n\), it iterates over all integers \(1 \le d &lt; \text{base}^n,\) computes \(f(d)\), and inserts the result into a set to track distinct outcomes.</p> <p>This approach is useful for exploration, for example to observe how the number of distinct canonical digit strings grows with \(n\). However, it suffers from the same fundamental limitation as the full sum computation:</p> <ul> <li>The runtime grows as \(\Theta(\text{base}^n)\).</li> <li>Even for moderate values of \(n\), the total number of iterations becomes prohibitively large.</li> <li>The method is therefore <strong>unsuitable for large inputs</strong> and serves only as a reference and sanity-check tool.</li> </ul> <p>In the next step, we will replace this exhaustive enumeration by a purely combinatorial counting argument that avoids iterating over individual numbers altogether.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">distinct_counts_by_n</span><span class="p">(</span><span class="n">max_n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">Return [(n, num_distinct_for_S(n))] for n = 1..max_n.

    num_distinct_for_S(n) counts the number of distinct f(d) values
    among all d with at most n digits in the given base, i.e.

        1 &lt;= d &lt; base**n
    </span><span class="sh">"""</span>
    <span class="n">results</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">upper_exclusive</span> <span class="o">=</span> <span class="n">base</span><span class="o">**</span><span class="n">n</span>
        <span class="n">distinct</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">upper_exclusive</span><span class="p">):</span>
            <span class="n">distinct</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nf">f_of_d</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">base</span><span class="p">))</span>

        <span class="n">results</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">distinct</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">results</span>


<span class="c1"># --------------------------------------------------
# Example: observe growth for small n
# --------------------------------------------------
</span>
<span class="n">base</span> <span class="o">=</span> <span class="mi">16</span>  <span class="c1"># choose 8, 10, or 16
</span>
<span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="nf">distinct_counts_by_n</span><span class="p">(</span><span class="n">max_n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">n=</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s">  num_distinct=</span><span class="si">{</span><span class="n">cnt</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Output:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n=1  num_distinct=15
n=2  num_distinct=135
n=3  num_distinct=815
n=4  num_distinct=3875
n=5  num_distinct=15503
</code></pre></div></div> <p><br></p> <p><em>Counting Distinct Values: Closed Form</em></p> <p>We fix a base \(b \in \{8,10,16\}\) with digits \(0,1,\dots,b-1\). For a number \(d\) with exactly \(m\) digits in base \(b\), let</p> \[c_i = \#\text{occurrences of digit } i \quad (i=0,1,\dots,b-1), \qquad \sum_{i=0}^{b-1} c_i = m.\] <p>Recall that \(f(d)\) sorts digits and removes zeros. So the output is determined only by the non-zero multiplicities</p> \[(c_1,\dots,c_{b-1}), \qquad k := \sum_{i=1}^{b-1} c_i = m - c_0,\] <p>where \(k\) is the number of non-zero digits that survive.</p> <p>The goal is to count how many distinct outputs \(f(d)\) can take among all \(d\) with at most \(n\) digits.</p> <p>Fix an integer $k \ge 1$. We now count how many <strong>distinct outputs</strong> $f(d)$ are possible when exactly $k$ non-zero digits survive after removing zeros. Since $f(d)$ sorts digits in ascending order and discards all zeros, every output $f(d)$ with $k$ digits is a <strong>nondecreasing sequence</strong></p> \[1 \le d_1 \le d_2 \le \cdots \le d_k \le b-1.\] <p>Equivalently, each output corresponds to a multiset of size $k$ chosen from the $(b-1)$ non-zero digits ${1,2,\dots,b-1}$.</p> <p>This is precisely the combinatorial notion of a combination with replacement:</p> <ul> <li>we choose $k$ elements,</li> <li>from $(b-1)$ distinct types,</li> <li>repetitions are allowed,</li> <li>and order does not matter.</li> </ul> <p>A standard result in combinatorics states that the number of combinations with replacement of size $k$ from $N$ distinct elements is</p> \[\binom{N + k - 1}{k}.\] <p>Here $N = b-1$, so the number of distinct values of $f(d)$ with exactly $k$ non-zero digits is</p> \[\binom{(b-1) + k - 1}{k} = \binom{k + b - 2}{k} = \binom{k + b - 2}{\,b-2\,}.\] <p>Now allow all possible values of $k$. For numbers $d$ with <strong>at most $n$ digits</strong>, the number of non-zero digits satisfies</p> \[1 \le k \le n,\] <p>because removing zeros can only decrease the digit count, and at least one non-zero digit must remain.</p> <p>Therefore, the total number of distinct outputs of $f(d)$ is</p> \[\sum_{k=1}^{n} \binom{k + b - 2}{b - 2}.\] <p>This sum has a closed form via the hockey-stick identity:</p> \[\sum_{k=0}^{n} \binom{k + b - 2}{b - 2} = \binom{n + b - 1}{b - 1}.\] <p>Subtracting the $k=0$ term (which equals $\binom{b-2}{b-2}=1$ and corresponds to the invalid empty output), we obtain</p> \[\boxed{ \#\{\text{distinct } f(d) \text{ for } \le n \text{ digits}\} = \binom{n + b - 1}{b - 1} - 1 }\] <p><em>Special Cases</em></p> <ul> <li> <p>Base $b=10$ (decimal): \(\binom{n+9}{9}-1\)</p> </li> <li> <p>Base $b=8$ (octal): \(\binom{n+7}{7}-1\)</p> </li> <li> <p>Base $b=16$ (hexadecimal): \(\binom{n+15}{15}-1\)</p> </li> </ul> <p>This explains why the number of distinct values grows only polynomially in $n$, even though the total number of $n$-digit numbers grows exponentially.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="n">math</span> <span class="kn">import</span> <span class="n">comb</span>


<span class="k">def</span> <span class="nf">num_distinct_closed_form</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Number of distinct f(d) values among all positive integers with &lt;= n digits in `base`.

    Key idea:
      For a fixed digit-length k, the value f(d) is determined solely by how many times
      each *non-zero* digit appears (zeros are discarded).

      Let b = base. The non-zero digits are {1, 2, ..., b-1}.
      For length k we count solutions to

          c_1 + c_2 + ... + c_{b-1} = k,  with c_i &gt;= 0,

      i.e. the number of multisets of size k drawn from (b-1) symbols:

          C(k + (b-1) - 1, (b-1) - 1) = C(k + b - 2, b - 2).

      Summing over k = 1..n gives:

          sum_{k=1..n} C(k + b - 2, b - 2)
          = C(n + b - 1, b - 1) - 1

      (The </span><span class="sh">"</span><span class="s">-1</span><span class="sh">"</span><span class="s"> removes the k=0 case corresponding to the empty multiset.)
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">base</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">base must be one of 8, 10, 16.</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># Closed form: C(n + base - 1, base - 1) - 1
</span>    <span class="k">return</span> <span class="nf">comb</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">base</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">base</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">print_distinct_table</span><span class="p">(</span><span class="n">n_max</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Print a small table of num_distinct for n=1..n_max.</span><span class="sh">"""</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Base = </span><span class="si">{</span><span class="n">base</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">n=</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="mi">2</span><span class="n">d</span><span class="si">}</span><span class="s">  num_distinct=</span><span class="si">{</span><span class="nf">num_distinct_closed_form</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>


<span class="c1"># --------------------------------------------------
# Example usage
# --------------------------------------------------
</span>
<span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="p">):</span> <span class="c1"># could also add other bases like 8 or 10
</span>    <span class="nf">print_distinct_table</span><span class="p">(</span><span class="n">n_max</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">()</span>
</code></pre></div></div> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Base = 16
n= 1  num_distinct=15
n= 2  num_distinct=135
n= 3  num_distinct=815
n= 4  num_distinct=3875
n= 5  num_distinct=15503
n= 6  num_distinct=54263
n= 7  num_distinct=170543
n= 8  num_distinct=490313
n= 9  num_distinct=1307503
n=10  num_distinct=3268759
n=11  num_distinct=7726159
n=12  num_distinct=17383859
n=13  num_distinct=37442159
n=14  num_distinct=77558759
n=15  num_distinct=155117519
n=16  num_distinct=300540194
n=17  num_distinct=565722719
n=18  num_distinct=1037158319
n=19  num_distinct=1855967519
n=20  num_distinct=3247943159
</code></pre></div></div> <p>The key takeaway is that the number of distinct values of $f(d)$ grows only polynomially in $n$, even though the total number of $n$-digit numbers grows exponentially.</p> <p>For example, in base $16$ and $n=10$, the number of distinct values is</p> \[\binom{10 + 16 -1}{16-1}-1 = 3268759,\] <p>which is small enough to explicitly generate all distinct values of length up to 10 in practice.</p> <p>This observation will allow us, in the next section, to replace brute-force enumeration over all numbers by a much more efficient enumeration over all distinct $f(d)$ values.</p> <p><br></p> <h3 id="computing-sn-by-enumerating-distinct-fd-values-and-their-multiplicities">Computing $S(n)$ by enumerating distinct $f(d)$ values (and their multiplicities)</h3> <p>The definition of $f(d)$ is ‚Äúsort digits ascending and remove zeros‚Äù.<br> This means that many different numbers $d$ collapse to the same value $f(d)$: any permutation of the non-zero digits and any placement of zeros produces the same sorted, zero-free output.</p> <p>The key idea of the algorithm is therefore:</p> <blockquote> <p>Do not iterate over all $d &lt; b^n$. Instead, iterate only over the distinct outputs $f(d)$ and count how many original numbers map to each of them.</p> </blockquote> <p>This splits the problem into two conceptually clean parts.</p> <p><em>1) Enumerating all distinct outputs $f(d)$</em></p> <p>A value $f(d)$ is exactly a finite <strong>nondecreasing digit string</strong> over the alphabet ${1,2,\dots,b-1}$.</p> <p>Equivalently, each distinct output corresponds to a sequence</p> \[1 \le d_1 \le d_2 \le \cdots \le d_k \le b-1, \qquad 1 \le k \le n,\] <p>where $k$ is the number of non-zero digits.</p> <p>The algorithm generates these sequences via a FIFO queue:</p> <ul> <li>start with all one-digit sequences $1,2,\dots,b-1$,</li> <li>repeatedly append digits $\ge$ the current last digit (to preserve sorting),</li> <li>stop extending once the length reaches $n$.</li> </ul> <p>Each distinct value of $f(d)$ is generated exactly once.</p> <p><em>2) Counting how many numbers map to a fixed $f_d$</em></p> <p>Fix one distinct output $f_d$ and let:</p> <ul> <li>$k$ be the number of non-zero digits in $f_d$,</li> <li>$c_i$ be the number of occurrences of digit $i$ in $f_d$ for $i=1,\dots,b-1$.</li> </ul> <p>Now consider all original numbers $d$ that map to this fixed $f_d$.</p> <p><em>(a) Permuting the non-zero digits</em></p> <p>Ignoring zeros for the moment, the number of distinct permutations of the $k$ non-zero digits with multiplicities $(c_1,\dots,c_{b-1})$ is</p> \[\frac{k!}{\prod_{i=1}^{b-1} c_i!}.\] <p>This counts all ways the non-zero digits can appear relative to each other.</p> <p><em>(b) Inserting zeros without creating leading zeros</em></p> <p>Let $c_0$ denote the number of zeros inserted.<br> Then the total digit length of $d$ is</p> \[m = k + c_0, \qquad 1 \le m \le n.\] <p>Because $d$ must be an $m$-digit number, its leading digit cannot be zero.</p> <p>Among the $m$ digit positions, this means:</p> <ul> <li>position 1 must contain a non-zero digit,</li> <li>the remaining $m-1$ positions are free to hold zeros.</li> </ul> <p>So the number of valid ways to place $c_0$ identical zeros is</p> \[\binom{m-1}{c_0} = \binom{k+c_0-1}{c_0}.\] <p><em>3) Combining both contributions</em></p> <p>For a fixed $f_d$, the total number of original numbers $d$ mapping to it is</p> \[\left(\frac{k!}{\prod_{i=1}^{b-1} c_i!}\right) \cdot \sum_{c_0=0}^{n-k} \binom{k+c_0-1}{c_0}.\] <p>Since each such $d$ contributes the same value $f_d$ to the sum, the total contribution of this class is</p> \[f_d \times \text{multiplicity}(f_d).\] <p>Instead of iterating over all $b^n$ numbers, we only iterate over the distinct values of $f(d)$, whose number grows like</p> \[\binom{n+b-1}{b-1}.\] <p>This reduces an exponential problem to a polynomial one and makes it feasible to explicitly enumerate all distinct outputs, for example, up to $S(0xA)$, laying the groundwork for the even more efficient methods developed next.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="n">math</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="n">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>


<span class="k">def</span> <span class="nf">S</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">fmt</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Compute S(n) by enumerating distinct f(d) values and counting multiplicities.

    Structure (kept the same):
      1) Enumerate all distinct values of f(d) among numbers with &lt;= n digits.
         Each such value is a nondecreasing sequence of non-zero digits (1..base-1).
      2) For each distinct output f_d, count how many original numbers d (with &lt;= n digits)
         map to it, by:
           - counting multiset permutations of the k non-zero digits
           - inserting z zeros for z = 0..(n-k), while forbidding a leading zero

    Args:
        n: Maximum number of digits of d (in base `base`).
        base: Base b (e.g. 8, 10, 16).
        fmt: Python `format` specifier matching the base:
            - base=10 -&gt; </span><span class="sh">"</span><span class="s">d</span><span class="sh">"</span><span class="s">
            - base=16 -&gt; </span><span class="sh">"</span><span class="s">x</span><span class="sh">"</span><span class="s"> (or </span><span class="sh">"</span><span class="s">X</span><span class="sh">"</span><span class="s">)
            - base=8  -&gt; </span><span class="sh">"</span><span class="s">o</span><span class="sh">"</span><span class="s">

    Returns:
        S(n) as an exact integer.
    </span><span class="sh">"""</span>
    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="c1"># Phase 1: enumerate all distinct f(d) values for numbers with &lt;= n digits.
</span>    <span class="c1">#
</span>    <span class="c1"># A value f(d) is just the sorted non-zero digits of d. Therefore it is
</span>    <span class="c1"># fully determined by a nondecreasing digit string over {1,2,...,base-1}.
</span>    <span class="c1"># We generate all such strings of length 1..n with a FIFO queue (BFS).
</span>    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="n">max_value_exclusive</span> <span class="o">=</span> <span class="n">base</span><span class="o">**</span><span class="n">n</span>  <span class="c1"># any integer with &gt;= n digits in base `base` is &gt;= base**n
</span>
    <span class="n">fifo</span><span class="p">:</span> <span class="n">deque</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">base</span><span class="p">))</span>  <span class="c1"># seed with all 1-digit non-zero values
</span>    <span class="n">all_f_values</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">fifo</span><span class="p">:</span>
        <span class="n">f_d</span> <span class="o">=</span> <span class="n">fifo</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        <span class="n">all_f_values</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">f_d</span><span class="p">)</span>

        <span class="c1"># Try to extend by one digit (append in base `base`).
</span>        <span class="n">new_prefix</span> <span class="o">=</span> <span class="n">base</span> <span class="o">*</span> <span class="n">f_d</span>
        <span class="k">if</span> <span class="n">new_prefix</span> <span class="o">&gt;=</span> <span class="n">max_value_exclusive</span><span class="p">:</span>
            <span class="k">continue</span>  <span class="c1"># already length n, cannot extend further
</span>
        <span class="n">last_digit</span> <span class="o">=</span> <span class="n">f_d</span> <span class="o">%</span> <span class="n">base</span>
        <span class="k">for</span> <span class="n">next_digit</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">last_digit</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
            <span class="n">fifo</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">new_prefix</span> <span class="o">+</span> <span class="n">next_digit</span><span class="p">)</span>

    <span class="c1"># Optional sanity check (if available).
</span>    <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">all_f_values</span><span class="p">)</span> <span class="o">==</span> <span class="nf">num_distinct_closed_form</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>

    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="c1"># Helper: multiset permutations count = k! / prod_i c_i!
</span>    <span class="c1"># where c_i are multiplicities of equal digits in the k-digit string f_d.
</span>    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="k">def</span> <span class="nf">multinomial_coefficient</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">counts</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
            <span class="n">denom</span> <span class="o">*=</span> <span class="n">math</span><span class="p">.</span><span class="nf">factorial</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">math</span><span class="p">.</span><span class="nf">factorial</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">//</span> <span class="n">denom</span>

    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="c1"># Phase 2: sum contributions.
</span>    <span class="c1">#
</span>    <span class="c1"># For a fixed distinct f_d:
</span>    <span class="c1">#   - let k be its length (number of non-zero digits)
</span>    <span class="c1">#   - perms_nonzero counts how many different permutations of those k digits exist
</span>    <span class="c1">#
</span>    <span class="c1"># Now fix z zeros to insert (0 &lt;= z &lt;= n-k). The final length is L = k+z.
</span>    <span class="c1"># Constraint: d must be an L-digit number, so its first digit cannot be 0.
</span>    <span class="c1">#
</span>    <span class="c1"># Therefore we choose the z zero-positions among the remaining L-1 slots:
</span>    <span class="c1">#
</span>    <span class="c1">#   interleave_zeros(k, z) = C(L-1, z) = C(k+z-1, z).
</span>    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">f_d</span> <span class="ow">in</span> <span class="n">all_f_values</span><span class="p">:</span>
        <span class="n">f_d_str</span> <span class="o">=</span> <span class="nf">format</span><span class="p">(</span><span class="n">f_d</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span>  <span class="c1"># base-appropriate digit string
</span>        <span class="n">k</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">f_d_str</span><span class="p">)</span>

        <span class="c1"># Multiplicities of digits within f_d (e.g. "11227" -&gt; counts [2,1,1,1]).
</span>        <span class="n">counts</span> <span class="o">=</span> <span class="nc">Counter</span><span class="p">(</span><span class="n">f_d_str</span><span class="p">).</span><span class="nf">values</span><span class="p">()</span>

        <span class="c1"># Number of distinct permutations of these k digits.
</span>        <span class="n">perms_nonzero</span> <span class="o">=</span> <span class="nf">multinomial_coefficient</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>

        <span class="n">multiplicity</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Ways to insert z zeros into total length L=k+z without leading zero:
</span>            <span class="c1"># choose z positions among the last (L-1) positions.
</span>            <span class="n">interleave_zeros</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">comb</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>

            <span class="n">multiplicity</span> <span class="o">+=</span> <span class="n">perms_nonzero</span> <span class="o">*</span> <span class="n">interleave_zeros</span>

        <span class="n">total</span> <span class="o">+=</span> <span class="n">f_d</span> <span class="o">*</span> <span class="n">multiplicity</span>

    <span class="k">return</span> <span class="n">total</span>


<span class="c1"># Example usage: compute S(n) for hexadecimal numbers
</span><span class="k">for</span> <span class="n">n_test</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mh">0xA</span><span class="p">):</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nc">S</span><span class="p">(</span><span class="n">n_test</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="sh">"</span><span class="s">x</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">S(0x</span><span class="si">{</span><span class="nf">format_answer</span><span class="p">(</span><span class="n">n_test</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="si">}</span><span class="s">) in base 16 = 0x</span><span class="si">{</span><span class="nf">format_answer</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S(0x3) in base 16 = 0x4077C0
S(0x5) in base 16 = 0x286D8F92C0
S(0xA) in base 16 = 0x12C698E48B4FC2A01358
</code></pre></div></div> <p>This solution would already win us the Bronze ü•â medal.</p> <h3 id="from-brute-force-to-digit-dynamics-building-a-much-faster-solution">From Brute Force to Digit Dynamics: Building a Much Faster Solution</h3> <p>Fix a base $b$ ($b=16$) and a digit-count vector</p> \[(c_0,c_1,\dots,c_{b-1}), \qquad \sum_{i=0}^{b-1} c_i = m, \qquad k := \sum_{i=1}^{b-1} c_i = m - c_0.\] <p>So $m$ is the total number of digits, $c_0$ is the number of zeros, and $k$ is the number of non-zero digits (the ones that survive in $f(d)$).</p> <p><em>Step 1: Count all permutations of the multiset of digits</em></p> <p>If we ignore the ‚Äúno leading zero‚Äù rule, then the number of distinct permutations of the multiset containing:</p> <ul> <li>$c_0$ zeros,</li> <li>$c_1$ ones,</li> <li>$\dots$,</li> <li>$c_{b-1}$ digits $(b-1)$,</li> </ul> <p>is the standard multinomial count</p> \[N_{\text{all}} = \frac{m!}{c_0!\,c_1!\cdots c_{b-1}!}.\] <p><em>Step 2: Subtract permutations that start with zero</em></p> <p>A permutation is invalid if its first digit is $0$.</p> <p>To count those, we <strong>fix</strong> one zero in the leading position. That consumes one of the $c_0$ zeros, leaving:</p> <ul> <li>$c_0 - 1$ zeros to permute in the remaining $m-1$ positions,</li> <li>and the same $c_1,\dots,c_{b-1}$ non-zero counts.</li> </ul> <p>Hence the number of invalid permutations is</p> \[N_{\text{lead0}} = \frac{(m-1)!}{(c_0-1)!\,c_1!\cdots c_{b-1}!}.\] <p>So the number of valid $m$-digit numbers (no leading zero) with these digit counts is</p> \[N_{\text{valid}} = N_{\text{all}} - N_{\text{lead0}} = \frac{m!}{c_0!\,\prod_{i=1}^{b-1} c_i!} - \frac{(m-1)!}{(c_0-1)!\,\prod_{i=1}^{b-1} c_i!}.\] <p><em>Step 3: Factor out common terms</em></p> <p>Both terms share $(m-1)!$ and $\prod_{i=1}^{b-1} c_i!$:</p> \[N_{\text{valid}} = \frac{(m-1)!}{\prod_{i=1}^{b-1} c_i!} \left( \frac{m}{c_0!} - \frac{1}{(c_0-1)!} \right).\] <p>Now rewrite the second fraction using $(c_0-1)! = \frac{c_0!}{c_0}$, i.e.</p> \[\frac{1}{(c_0-1)!} = \frac{c_0}{c_0!}.\] <p>Substitute:</p> \[\frac{m}{c_0!} - \frac{1}{(c_0-1)!} = \frac{m}{c_0!} - \frac{c_0}{c_0!} = \frac{m-c_0}{c_0!}.\] <p>But $m - c_0$ is exactly $k$ (the number of non-zero digits). Therefore:</p> \[N_{\text{valid}} = \frac{(m-1)!}{\prod_{i=1}^{b-1} c_i!} \cdot \frac{k}{c_0!}.\] <p>So we have the clean intermediate form</p> \[N_{\text{valid}} = \frac{(m-1)! \, k}{c_0! \, \prod_{i=1}^{b-1} c_i!}.\] <hr> <p><em>Step 4: Express $c_0!$ via $m$ and $k$</em></p> <p>Since $c_0 = m-k$, we can rewrite</p> \[c_0! = (m-k)!.\] <p>Plugging this in yields the closed form:</p> \[\begin{align} \boxed{ N_{\text{valid}} = \frac{(m-1)! \, k}{(m-k)! \, \prod_{i=1}^{b-1} c_i!} }. \end{align}\] <p>This is exactly the number of base-$b$ $m$-digit integers (no leading zeros) whose digit multiplicities are $(c_0,c_1,\dots,c_{b-1})$.</p> <p><br> <em>Grouping by one fixed $f_d$ and summing over all lengths $m \le n$</em></p> <p>Fix one particular non-zero multiplicity vector</p> \[(c_1,c_2,\dots,c_{b-1}), \qquad k := \sum_{i=1}^{b-1} c_i,\] <p>and let $f(c_1,\dots,c_{b-1})$ denote the corresponding sorted ‚Äúzero-free‚Äù value, i.e. the number whose base-$b$ digit multiset contains digit $i$ exactly $c_i$ times.</p> <p>Our goal is to compute $S(n)$, i.e. the sum of $f(d)$ over all positive integers $d$ with at most $n$ digits.<br> Every $d$ that maps to this fixed vector contributes exactly the same value $f(c_1,\dots,c_{b-1})$ to the sum.</p> <p>So the contribution of this class is</p> \[f(c_1,\dots,c_{b-1}) \cdot \Big(\text{number of } d \text{ with } \le n \text{ digits that map here}\Big).\] <p><em>Why we sum over $m = k,\dots,n$</em></p> <p>Once zeros are removed, exactly $k$ digits remain. If the original number has $m$ digits and contains $c_0$ zeros, then</p> \[m = c_0 + k \quad\Longleftrightarrow\quad c_0 = m-k.\] <ul> <li>The smallest possible length is $m=k$, corresponding to $c_0=0$ (no zeros at all).</li> <li>Larger $m$ are possible by inserting zeros, i.e. $c_0 \ge 0$.</li> <li>Since we only consider numbers with at most $n$ digits, we must have $m \le n$.</li> </ul> <p>Therefore the valid range is exactly</p> \[m = k, k+1, \dots, n.\] <p>From the previous section, the number of valid $m$-digit numbers (no leading zero) with digit counts $(c_0,c_1,\dots,c_{b-1})$ is</p> \[N_{\text{valid}}(m; c_1,\dots,c_{b-1}) = \frac{(m-1)!\,k}{(m-k)!\,\prod_{i=1}^{b-1} c_i!}, \qquad\text{where } c_0=m-k.\] <p>Multiplying this by the common value $f(c_1,\dots,c_{b-1})$ gives the total contribution for this fixed $(c_1,\dots,c_{b-1})$ at length $m$:</p> \[f(c_1,\dots,c_{b-1}) \cdot \frac{(m-1)!\,k}{(m-k)!\,\prod_{i=1}^{b-1} c_i!}.\] <p>Now sum over all allowed lengths $m=k,\dots,n$:</p> \[\sum_{m=k}^{n} f(c_1,\dots,c_{b-1}) \cdot \frac{(m-1)!\,k}{(m-k)!\,\prod_{i=1}^{b-1} c_i!}.\] <p>Factor out the terms that do not depend on $m$. This is the desired intermediate form:</p> \[\begin{align} \boxed{ k \, \frac{f(c_1,\dots,c_{b-1})}{\prod_{i=1}^{b-1} c_i!} \;\cdot\; \sum_{m=k}^{n} \frac{(m-1)!}{(m-k)!} }. \end{align}\] <p>Define the purely length-dependent factor</p> \[\begin{align} A(k) := \sum_{m=k}^{n} \frac{(m-1)!}{(m-k)!}. \end{align}\] <p>For the fixed non-zero multiplicity pattern, define</p> \[\begin{align} B(k; c_1,\dots,c_{b-1}) := \frac{f(c_1,\dots,c_{b-1})}{\prod_{i=1}^{b-1} c_i!}. \end{align}\] <p>Then the contribution of this single pattern becomes</p> \[\begin{align} k \cdot A(k) \cdot B(k; c_1,\dots,c_{b-1}). \end{align}\] <p>In the next step, we will sum $B(k; c_1,\dots,c_{b-1})$ over all choices of $(c_1,\dots,c_{b-1})$ with $c_1+\cdots+c_{b-1}=k$, to obtain a quantity that depends only on $k$.</p> <p>Recall the pattern-dependent factor</p> \[B(k; c_1,\dots,c_{b-1}) = \frac{f(c_1,\dots,c_{b-1})}{\prod_{i=1}^{b-1} c_i!}, \qquad \text{where } \sum_{i=1}^{b-1} c_i = k.\] <p>For a fixed $k$, we now sum this over <strong>all</strong> nonnegative integer vectors $(c_1,\dots,c_{b-1})$ with total weight $k$ and define</p> \[\begin{align} \boxed{ B(k) := \sum_{\substack{c_1+\cdots+c_{b-1}=k \\ c_i \ge 0}} \frac{f(c_1,\dots,c_{b-1})}{\prod_{i=1}^{b-1} c_i!} }. \end{align}\] <p>This $B(k)$ depends only on $k$ (and the base $b$), because the sum ranges over <em>all</em> digit-multiplicity patterns of size $k$.</p> <p>With this definition, the full sum over all numbers with at most $n$ digits can be written as</p> \[\begin{align} \boxed{ S(n) = \sum_{k=1}^{n} k \cdot A(k) \cdot B(k). } \end{align}\] <p><em>Intuition for what $B(k)$ represents</em></p> <p>For each fixed $k$:</p> <ul> <li>the constraint $c_1+\cdots+c_{b-1}=k$ enumerates all possible <strong>multisets of $k$ non-zero digits</strong> (equivalently, all distinct values of $f(d)$ of length $k$),</li> <li>the factor $1/\prod c_i!$ is the ‚Äúmultiset correction‚Äù coming from the multinomial counting,</li> <li>and $f(c_1,\dots,c_{b-1})$ is the actual numeric value contributed by that multiset.</li> </ul> <p>So $B(k)$ is a weighted sum over all distinct outputs of $f(d)$ having exactly $k$ digits, capturing ‚Äúhow large those $f(d)$ values are on average‚Äù under the natural weights induced by the multinomial coefficients.</p> <p>In the next step we will show how to compute $B(k)$ efficiently without enumerating all $(c_1,\dots,c_{b-1})$ patterns explicitly.</p> <p><br></p> <h3 id="computing-bk-efficiently-dp">Computing $B(k)$ efficiently (DP)</h3> <p>Recall the definition (base $b$):</p> \[B(k) = \sum_{\substack{c_1+\cdots+c_{b-1}=k \\ c_i\ge 0}} \frac{f(c_1,\dots,c_{b-1})}{\prod_{i=1}^{b-1} c_i!},\] <p>where $f(c_1,\dots,c_{b-1})$ is the base-$b$ integer whose digit multiset contains digit $i$ exactly $c_i$ times, written in sorted order.</p> <p>A direct sum over all integer vectors $(c_1,\dots,c_{b-1})$ is expensive. The key trick is that the weight $\frac{1}{\prod c_i!}$ <strong>factorizes over digits</strong>, so we can build $B(k)$ by processing digits one-by-one with a small DP.</p> <p><em>1) Separate ‚Äúweights‚Äù from ‚Äúvalues‚Äù</em></p> <p>Introduce two sequences (indexed by length):</p> <ul> <li> <p>$W[t]$ = total weight of all patterns of total length $t$:</p> \[W[t] := \sum_{\substack{c_1+\cdots+c_{b-1}=t \\ c_i\ge 0}} \frac{1}{\prod_{i=1}^{b-1} c_i!}.\] </li> <li> <p>$B[t]$ = the weighted sum of values (this is exactly what we want when $t=k$):</p> \[B[t] := \sum_{\substack{c_1+\cdots+c_{b-1}=t \\ c_i\ge 0}} \frac{f(c_1,\dots,c_{b-1})}{\prod_{i=1}^{b-1} c_i!}.\] </li> </ul> <p>So $B(k)$ is just $B[k]$.</p> <p>We will compute both arrays up to $t=n$.</p> <hr> <p><br></p> <p><strong>&lt;Worked Example: Why we need the weight $W[t]$&gt;</strong></p> <p>Assume we are working in base $10$ for simplicity, and that at some DP stage we have the following weighted sum for patterns of length $t$:</p> \[B[t] = \frac{1122}{2!\,2!} + \frac{1112}{3!\,1!}.\] <p>This means we have two different digit-multiplicity patterns of length $t$, each contributing its numeric value divided by the product of factorials of its digit counts.</p> <p>Now suppose we want to <strong>append two copies of digit $3$</strong>, i.e. we append the suffix <code class="language-plaintext highlighter-rouge">33</code>. For any old value $x$, this transforms the number as</p> \[x \;\longmapsto\; x\cdot 10^2 + 33.\] <p>Because we are appending $c=2$ identical digits, this choice carries the weight factor $1/2!$.</p> <p>So the contribution to $B[t+2]$ is</p> \[B[t+2] = \frac{1}{2!} \left( \frac{1122\cdot 10^2 + 33}{2!\,2!} + \frac{1112\cdot 10^2 + 33}{3!\,1!} \right).\] <p>Split the sum into the ‚Äúold value‚Äù part and the ‚Äúnew suffix‚Äù part:</p> \[\begin{aligned} B[t+2] &amp;= \frac{1}{2!} \Bigg( 10^2 \left( \frac{1122}{2!\,2!} + \frac{1112}{3!\,1!} \right) + 33 \left( \frac{1}{2!\,2!} + \frac{1}{3!\,1!} \right) \Bigg). \end{aligned}\] <p>Now observe:</p> <ul> <li>The first parenthesis is exactly $B[t]$.</li> <li>The second parenthesis is the same sum <strong>without the numeric values</strong>. This motivates defining the <em>weight</em> </li> </ul> \[W[t] = \frac{1}{2!\,2!} + \frac{1}{3!\,1!}.\] <p>With this notation, the update becomes</p> \[\boxed{ B[t+2] = \frac{1}{2!} \left( 10^2\,B[t] + 33\,W[t] \right). }\] <p>In base $b$, appending $c$ copies of digit $d$:</p> <ul> <li>shifts old values by $b^c$,</li> <li>adds the suffix \(d\,(1+b+\dots+b^{c-1}) = d\,\frac{b^c-1}{b-1},\)</li> <li>and introduces the weight factor $1/c!$.</li> </ul> <p>Thus the general update rule is</p> \[\boxed{ B[t+c] \;\leftarrow\; B[t+c] + \left( B[t]\cdot b^c + W[t]\cdot d\cdot\frac{b^c-1}{b-1} \right)\cdot \frac{1}{c!}. }\] <p>This illustrates precisely why the auxiliary array $W[t]$ is needed: the constant suffix contribution must be multiplied by the <strong>total weight</strong> of all patterns of length $t$, not by their individual numeric values.</p> <p><strong>&lt;/ End of Example&gt;</strong></p> <p><em>2) Process digits incrementally</em></p> <p>Think of the pattern $(c_1,\dots,c_{b-1})$ as being constructed digit-by-digit. When we are currently processing digit $d$ (where $d\in{1,\dots,b-1}$), we choose how many times it appears: $c \ge 0$.</p> <p>This choice contributes a factor $\frac{1}{c!}$ to the weight. That is why the factorials are so convenient: they make the contribution of each digit independent and multiplicative.</p> <p>Suppose we have already processed digits $1,2,\dots,d-1$, and we have aggregated:</p> <ul> <li>$W[t]$: total weight for patterns of length $t$ using only digits $&lt; d$,</li> <li>$B[t]$: total weighted value sum for the same patterns.</li> </ul> <p>Now we extend these patterns by appending digit $d$ exactly $c$ times.</p> <p><em>3) How does appending digit $d$ change the numeric value?</em></p> <p>Let $x$ be the existing sorted digit string (using digits $&lt; d$) of length $t$. If we append $c$ copies of digit $d$, the new sorted string is:</p> \[x \;\Vert\; \underbrace{dd\cdots d}_{c\text{ times}}.\] <p>Interpreting strings as base-$b$ integers:</p> <ul> <li>Appending $c$ digits multiplies the old value by $b^c$.</li> <li>Then we add the value of the suffix consisting of $c$ copies of digit $d$.</li> </ul> <p>That suffix has value:</p> \[d \cdot (b^{c-1} + b^{c-2} + \cdots + b + 1) = d \cdot \frac{b^c - 1}{b - 1}.\] <p>Let us denote the repunit-like factor</p> \[R_c := 1 + b + b^2 + \cdots + b^{c-1} = \frac{b^c - 1}{b - 1}.\] <p>Then the update rule for a single pattern is:</p> \[f_{\text{new}} = f_{\text{old}} \cdot b^c + d \cdot R_c.\] <p><em>4) Translate this into DP updates for $W$ and $B$</em></p> <p>When we add $c$ copies of digit $d$:</p> <ul> <li>The total length increases from $t$ to $t+c$.</li> <li>Every existing pattern of length $t$ contributes a weight factor $\frac{1}{c!}$.</li> </ul> <p>So the weight update is:</p> \[W_{\text{new}}[t+c] \;\leftarrow\; W_{\text{new}}[t+c] + W_{\text{old}}[t]\cdot \frac{1}{c!}.\] <p>For the value-weighted sum, we take the old aggregated sum $B_{\text{old}}[t]$ and apply the value transform:</p> <ul> <li>The part coming from old values gets multiplied by $b^c$.</li> <li>The part coming from the new suffix is $d\cdot R_c$, multiplied by the total weight of old patterns $W_{\text{old}}[t]$.</li> </ul> <p>So:</p> \[B_{\text{new}}[t+c] \;\leftarrow\; B_{\text{new}}[t+c] + \left( B_{\text{old}}[t]\cdot b^c \;+\; W_{\text{old}}[t]\cdot d\cdot R_c \right)\cdot \frac{1}{c!}.\] <p>Initialization is:</p> \[W[0]=1,\quad B[0]=0,\] <p>representing the empty pattern of length $0$ with weight $1$.</p> <p>After processing all digits $d=1,\dots,b-1$, the array entry $B[k]$ equals the desired $B(k)$.</p> <p><em>5) Final assembly: $S(n)=\sum_{k=1}^n k\cdot A(k)\cdot B(k)$</em></p> <p>Separately, we define</p> \[A(k) := \sum_{m=k}^{n} \frac{(m-1)!}{(m-k)!}.\] <p>Then, from the earlier derivation,</p> \[S(n) = \sum_{k=1}^{n} k \cdot A(k) \cdot B(k).\] <p>So the entire computation reduces to:</p> <ol> <li>compute $A(1),\dots,A(n)$ (length-only factor),</li> <li>compute $B(1),\dots,B(n)$ via the digit-by-digit DP above,</li> <li>combine them in the final sum.</li> </ol> <p>This avoids explicit enumeration of all $(c_1,\dots,c_{b-1})$ patterns while still producing exactly the same $B(k)$ values.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="n">math</span>
<span class="kn">from</span> <span class="n">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>


<span class="k">def</span> <span class="nf">S</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Compute S(n) exactly using the A(k) / B(k) decomposition (rational DP).

    We use the identity

        S(n) = sum_{k=1..n}  k * A(k) * B(k),

    where

        A(k) = sum_{m=k..n} (m-1)! / (m-k)!,

    and B(k) is the weighted sum over all digit-multiplicity patterns
    (c_1, ..., c_{base-1}) with sum c_i = k:

        B(k) = sum_{c_1+...+c_{base-1}=k}  f(c_1,...,c_{base-1}) / prod_i c_i!.

    Instead of enumerating all (c_1,...,c_{base-1}), we compute B(k) via a DP
    over digits d = 1..base-1, maintaining two arrays:

      - W[t] = sum_{patterns of length t}  1 / prod c_i!
      - B[t] = sum_{patterns of length t}  f(pattern) / prod c_i!

    Both W and B are Fractions to keep the derivation exact.
    </span><span class="sh">"""</span>
    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="c1"># 1) Compute A[k] for k=1..n:
</span>    <span class="c1">#
</span>    <span class="c1">#    A(k) = sum_{m=k..n} (m-1)! / (m-k)!
</span>    <span class="c1">#
</span>    <span class="c1"># This quantity depends only on lengths, not on digit composition.
</span>    <span class="c1"># We store A[0]=0 unused for convenience.
</span>    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="n">A</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Fraction</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nc">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Sum over total lengths m (total digits, including zeros).
</span>        <span class="c1"># Note: (m-1)!/(m-k)! is an integer, but we keep Fraction for uniformity.
</span>        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="nc">Fraction</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">factorial</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">math</span><span class="p">.</span><span class="nf">factorial</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">k</span><span class="p">))</span>

    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="c1"># 2) Compute B[k] for k=0..n via DP over digits d=1..base-1.
</span>    <span class="c1">#
</span>    <span class="c1"># DP state after processing digits 1..(d-1):
</span>    <span class="c1">#   W[t] = sum_{c_1+...+c_{d-1}=t}  1 / (c_1! ... c_{d-1}!)
</span>    <span class="c1">#   B[t] = sum_{c_1+...+c_{d-1}=t}  f(c_1,...,c_{d-1}) / (c_1! ... c_{d-1}!)
</span>    <span class="c1">#
</span>    <span class="c1"># Initialization (no digits chosen yet):
</span>    <span class="c1">#   - empty pattern of length 0 has weight 1
</span>    <span class="c1">#   - its value-sum is 0 (there is no number yet)
</span>    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="n">W</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Fraction</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nc">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">B</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Fraction</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nc">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nc">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Process each possible non-zero digit exactly once.
</span>    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="n">newW</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Fraction</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nc">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">newB</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Fraction</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nc">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># We may append digit d exactly c times, where c &gt;= 0.
</span>        <span class="c1"># If current non-zero length is t, then t+c must be &lt;= n.
</span>        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">W</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">B</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Small skip: no patterns of this length exist in the current DP state.
</span>                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Each digit multiplicity contributes the factor 1/c!
</span>                <span class="n">coef</span> <span class="o">=</span> <span class="nc">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="p">.</span><span class="nf">factorial</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

                <span class="c1"># Appending c digits to the right in base `base` multiplies by base^c.
</span>                <span class="n">p_base</span> <span class="o">=</span> <span class="n">base</span><span class="o">**</span><span class="n">c</span>

                <span class="c1"># The suffix consisting of c copies of digit d has value:
</span>                <span class="c1">#   d * (1 + base + base^2 + ... + base^(c-1))
</span>                <span class="c1"># The geometric sum factor is:
</span>                <span class="c1">#   rep = (base^c - 1) / (base - 1)
</span>                <span class="c1"># Example (base 16): c=2 =&gt; rep = 1 + 16 = 0x11
</span>                <span class="n">rep</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_base</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">base</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Weight update:
</span>                <span class="c1">#   W_new[t+c] += W[t] * (1/c!)
</span>                <span class="n">newW</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="n">coef</span>

                <span class="c1"># Value-sum update:
</span>                <span class="c1">#
</span>                <span class="c1"># For each old pattern/value x of length t:
</span>                <span class="c1">#   new_value = x * base^c + d * rep
</span>                <span class="c1">#
</span>                <span class="c1"># Aggregating over all patterns of length t:
</span>                <span class="c1">#   B[t] aggregates sum(x / weight_den)
</span>                <span class="c1">#   W[t] aggregates sum(1 / weight_den)
</span>                <span class="c1">#
</span>                <span class="c1"># Thus:
</span>                <span class="c1">#   B_new[t+c] += (B[t] * base^c + W[t] * d * rep) * (1/c!)
</span>                <span class="n">newB</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="n">p_base</span> <span class="o">+</span> <span class="n">W</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">rep</span><span class="p">)</span> <span class="o">*</span> <span class="n">coef</span>

        <span class="n">W</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">newW</span><span class="p">,</span> <span class="n">newB</span>

    <span class="c1"># Now B[k] equals the desired B(k) after processing digits 1..base-1.
</span>
    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="c1"># 3) Assemble S(n) = sum_{k=1..n} k * A[k] * B[k]
</span>    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="n">total</span> <span class="o">=</span> <span class="nc">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="c1"># The math guarantees the result is an integer.
</span>    <span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>


<span class="c1"># Example usage: compute S(n) for hexadecimal numbers
# Example usage: compute S(n) for hexadecimal numbers
</span><span class="k">for</span> <span class="n">n_test</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mh">0xA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">):</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nc">S</span><span class="p">(</span><span class="n">n_test</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">S(0x</span><span class="si">{</span><span class="nf">format_answer</span><span class="p">(</span><span class="n">n_test</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="si">}</span><span class="s">) in base 16 = 0x</span><span class="si">{</span><span class="nf">format_answer</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Output:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S(0x3) in base 16 = 0x4077C0
S(0x5) in base 16 = 0x286D8F92C0
S(0xA) in base 16 = 0x12C698E48B4FC2A01358
S(0xAA) in base 16 = 0x26F887F38798EE82871999ED23144B390724614ECAF1D11BF47A1ECBE23E8CE07533AFFEACBFE440346B4335A5A30FCDE3A3DB92E838CB57FE2B4FA6795EA57ABD4FCFB80DB43E6001A7153FD484ACD473AFCDF93BEA247F908BE8B05F836C118486D59BB38D2349DAE0CAE1D7040F1B27CE2D2E45F0520D9EF0285FDF9BA9CBF46A2420B1DA749B761D2A9EFB8EC37F04D580D1210F929386720E61EF28351655758C184BF42958
</code></pre></div></div> <p>This is already good enough to secure the silver ü•à medal (although the code does run a few seconds already).</p> <p><br></p> <hr> <h3 id="eliminating-fractions-scaling-away-the-factorial-denominators">Eliminating Fractions: Scaling away the Factorial Denominators</h3> <p>The DP we derived for $B(k)$ used rational weights of the form $1/c!$, which naturally led to <code class="language-plaintext highlighter-rouge">Fraction</code> arithmetic:</p> <ul> <li>$W[t]$ aggregated $\sum 1/\prod c_i!$ over all patterns of length $t$,</li> <li>$B[t]$ aggregated $\sum f(\mathbf c)/\prod c_i!$ over the same patterns.</li> </ul> <p>This is mathematically clean but computationally expensive, because <code class="language-plaintext highlighter-rouge">Fraction</code> objects constantly normalize numerators/denominators via gcd. The key observation is that all denominators are factorials and therefore we can remove them by a global scaling.</p> <p><em>1) Define integer-scaled DP arrays</em></p> <p>Define scaled (integer) versions of the DP states by multiplying by $t!$:</p> \[\widetilde{W}[t] := t!\,W[t], \qquad \widetilde{B}[t] := t!\,B[t].\] <p>Intuition:</p> <ul> <li>Every term contributing to $W[t]$ looks like $1/\prod c_i!$.</li> <li>Multiplying by $t!$ converts this into the multinomial coefficient $t!/\prod c_i!$, which is an integer.</li> <li>Same for $B[t]$: each value gets multiplied by the same integer weight.</li> </ul> <p>So $\widetilde{W}[t]$ and $\widetilde{B}[t]$ can be maintained using pure integers.</p> <p>Initialization becomes</p> \[\begin{align*} \widetilde{W}[0] = 1 \qquad W[0] = 1, \\ \widetilde{B}[0] = 0 \qquad B[0] = 0. \end{align*}\] <p><em>2) Start from the rational DP update</em></p> <p>From the previous derivation, when processing digit $d$ and choosing multiplicity $c$, we had for each $t$:</p> \[W_{\text{new}}[t+c] \;\leftarrow \; W_{\text{new}}[t+c] + W[t]\cdot \frac{1}{c!},\] <p>and</p> \[B_{\text{new}}[t+c] \;\leftarrow\; B_{\text{new}}[t+c] + \left(B[t]\cdot b^c + W[t]\cdot d\cdot R_c \right)\cdot \frac{1}{c!}, \qquad R_c := \frac{b^c-1}{b-1}.\] <p>Now multiply the whole update for index $t+c$ by $(t+c)!$ to convert it to the scaled variables.</p> <p><em>3) Derive the integer coefficient</em></p> <p>For the weight update:</p> \[\widetilde{W}_{\text{new}}[t+c] := (t+c)!\,W_{\text{new}}[t+c].\] \[\widetilde{W}_{\text{new}}[t+c] \;\leftarrow\; \widetilde{W}_{\text{new}}[t+c] \;+\; (t+c)!\,W[t]\cdot \frac{1}{c!}.\] <p>Substitute $W[t] = \widetilde{W}[t]/t!$ (since our sequence gets longer we have to correct the factor by dividing through $t!$ and multiplying with $(t+c)!$):</p> \[\begin{align} \widetilde{W}_{\text{new}}[t+c] \; \leftarrow\; \widetilde{W}_{\text{new}}[t+c] + (t+c)!\,\frac{\widetilde{W}[t]}{t!}\cdot \frac{1}{c!} = \widetilde{W}[t]\cdot \frac{(t+c)!}{t!\,c!}. \end{align}\] <p>But</p> \[\frac{(t+c)!}{t!\,c!} = \binom{t+c}{c}.\] <p>So the scaled weight update is:</p> \[\boxed{ \widetilde{W}_{\text{new}}[t+c] \; \leftarrow\; \widetilde{W}_{\text{new}}[t+c] + \widetilde{W}[t]\cdot \binom{t+c}{c}. }\] <p><em>4) Derive the integer update for $\widetilde{B}$</em></p> <p>Start from the rational update and multiply by $(t+c)!$:</p> \[\widetilde{B}_{\text{new}}[t+c] \; \leftarrow \; \widetilde{B}_{\text{new}}[t+c] + (t+c)!\left(B[t]\cdot b^c + W[t]\cdot d\cdot R_c\right)\frac{1}{c!}.\] <p>Substitute $B[t]=\widetilde{B}[t]/t!$ and $W[t]=\widetilde{W}[t]/t!$:</p> \[\widetilde{B}_{\text{new}}[t+c] \; \leftarrow \; \widetilde{B}_{\text{new}}[t+c] + \frac{(t+c)!}{t!\,c!}\left(\widetilde{B}[t]\cdot b^c + \widetilde{W}[t]\cdot d\cdot R_c\right).\] <p>Again the prefactor is $\binom{t+c}{c}$, so:</p> \[\boxed{ \widetilde{B}_{\text{new}}[t+c] \; \leftarrow \; \widetilde{B}_{\text{new}}[t+c] + \left(\widetilde{B}[t]\cdot b^c + \widetilde{W}[t]\cdot d\cdot R_c\right)\binom{t+c}{c}. }\] <p><em>5) Recovering $B(k)$ and assembling $S(n)$</em></p> <p>By definition,</p> \[\widetilde{B}[k] = k!\,B(k).\] <p>So whenever the final formula requires $B(k)$, we can use</p> \[B(k) = \frac{\widetilde{B}[k]}{k!}.\] <p>The overall decomposition remains</p> \[S(n) = \sum_{k=1}^{n} k\cdot A(k)\cdot B(k),\] <p>so substituting $B(k)=\widetilde{B}[k]/k!$ yields the integer-friendly form</p> \[\boxed{ S(n) = \sum_{k=1}^{n} k\cdot A(k)\cdot \frac{\widetilde{B}[k]}{k!}. }\] <p>This is exactly why the last line in the reference code divides by <code class="language-plaintext highlighter-rouge">factorial(k)</code>.</p> <p><em>Why this is faster</em></p> <ul> <li>All intermediate DP values are integers (or later, integers modulo $M$).</li> <li>We avoid gcd reductions and normalization inherent to fractions (<code class="language-plaintext highlighter-rouge">Fraction</code> class in Python 3).</li> <li>The only ‚Äúdivision‚Äù left is by $k!$ at the very end, which can be handled either exactly (since the expression is guaranteed to be an integer) or, for the modular version, via modular inverses.</li> </ul> <p>This turns the elegant but slow rational DP into a practical integer DP that is ready to be upgraded to the final modulo-$M$ computation.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="n">math</span>


<span class="k">def</span> <span class="nf">S</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Compute S(n) exactly using the integer-scaled DP (no Fractions).

    We use the decomposition
        S(n) = sum_{k=1..n} k * A(k) * B(k),

    but compute B(k) via scaled integers:
        B_scaled[k] = k! * B(k).

    DP meaning (after processing digits 1..d):
      - W_scaled[t] = t! * sum_{patterns length t} 1 / prod c_i!
      - B_scaled[t] = t! * sum_{patterns length t} f(pattern) / prod c_i!

    The digit-extension update (append digit d exactly c times) becomes integer-only:
        coef = C(t+c, c)
        W_scaled_new[t+c] += W_scaled[t] * coef
        B_scaled_new[t+c] += (B_scaled[t] * base^c + W_scaled[t] * d * rep(c)) * coef

    where rep(c) = (base^c - 1)/(base - 1) = 1 + base + ... + base^(c-1).

    Finally, since B_scaled[k] = k! * B(k), we have:
        S(n) = sum_{k=1..n} k * A(k) * B_scaled[k] / k!

    The division is exact by construction.
    </span><span class="sh">"""</span>
    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="c1"># 1) Precompute A[k] = sum_{m=k..n} (m-1)!/(m-k)!   (pure integers)
</span>    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># (m-1)!/(m-k)! = (m-k)(m-k+1)...(m-1) is an integer rising product of length (k-1).
</span>        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">math</span><span class="p">.</span><span class="nf">factorial</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">math</span><span class="p">.</span><span class="nf">factorial</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>

    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="c1"># 2) Compute scaled B via DP over digits d=1..base-1.
</span>    <span class="c1">#
</span>    <span class="c1"># W_scaled[0]=1 represents the empty pattern (length 0) with weight 1.
</span>    <span class="c1"># B_scaled[0]=0 because the empty pattern has value 0.
</span>    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="n">W_scaled</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">B_scaled</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">W_scaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>  <span class="c1"># digits 1..9 (base10), 1..7 (base8), 1..15 (base16), ...
</span>        <span class="n">newW</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">newB</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># For each existing length t, we may add c copies of digit d, keeping total &lt;= n.
</span>        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">W_scaled</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">B_scaled</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># coef = (t+c)!/(t! c!) = C(t+c, c)
</span>                <span class="c1"># This is exactly the scaling factor that removes the 1/c! fractions
</span>                <span class="c1"># after we multiply everything by (t+c)!.
</span>                <span class="n">coef</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">comb</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

                <span class="c1"># Appending c digits shifts old values by base^c.
</span>                <span class="n">p_base</span> <span class="o">=</span> <span class="n">base</span><span class="o">**</span><span class="n">c</span>

                <span class="c1"># Value of suffix "ddd...d" (c times) in base `base`:
</span>                <span class="c1"># d * (1 + base + ... + base^(c-1)) = d * ((base^c - 1)/(base - 1))
</span>                <span class="n">rep</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_base</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">base</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Update weights (scaled): only depends on how many patterns we had at length t.
</span>                <span class="n">newW</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">W_scaled</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="n">coef</span>

                <span class="c1"># Update value-sums (scaled):
</span>                <span class="c1"># - old aggregated values shift by base^c
</span>                <span class="c1"># - plus the suffix contribution, scaled by the total weight mass W_scaled[t]
</span>                <span class="n">newB</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">B_scaled</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="n">p_base</span> <span class="o">+</span> <span class="n">W_scaled</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">rep</span><span class="p">)</span> <span class="o">*</span> <span class="n">coef</span>

        <span class="n">W_scaled</span><span class="p">,</span> <span class="n">B_scaled</span> <span class="o">=</span> <span class="n">newW</span><span class="p">,</span> <span class="n">newB</span>

    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="c1"># 3) Assemble S(n) using B_scaled[k] = k! * B(k)
</span>    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B_scaled</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">//</span> <span class="n">math</span><span class="p">.</span><span class="nf">factorial</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ans</span>


<span class="c1"># Example usage: compute S(n) for hexadecimal numbers
</span><span class="k">for</span> <span class="n">n_test</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mh">0xA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">):</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nc">S</span><span class="p">(</span><span class="n">n_test</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">S(0x</span><span class="si">{</span><span class="nf">format_answer</span><span class="p">(</span><span class="n">n_test</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="si">}</span><span class="s">) in base 16 = 0x</span><span class="si">{</span><span class="nf">format_answer</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Also here, we get the same output as before (but faster):</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S(0x3) in base 16 = 0x4077C0
S(0x5) in base 16 = 0x286D8F92C0
S(0xA) in base 16 = 0x12C698E48B4FC2A01358
S(0xAA) in base 16 = 0x26F887F38798EE82871999ED23144B390724614ECAF1D11BF47A1ECBE23E8CE07533AFFEACBFE440346B4335A5A30FCDE3A3DB92E838CB57FE2B4FA6795EA57ABD4FCFB80DB43E6001A7153FD484ACD473AFCDF93BEA247F908BE8B05F836C118486D59BB38D2349DAE0CAE1D7040F1B27CE2D2E45F0520D9EF0285FDF9BA9CBF46A2420B1DA749B761D2A9EFB8EC37F04D580D1210F929386720E61EF28351655758C184BF42958
</code></pre></div></div> <p>Also, let us compute the values for $S(n) \bmod \mbox{0x1FFFFFFFFFFFFFFF}$:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mod</span> <span class="o">=</span> <span class="mh">0x1FFFFFFFFFFFFFFF</span>
<span class="k">for</span> <span class="n">n_test</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mh">0xA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">):</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nc">S</span><span class="p">(</span><span class="n">n_test</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">S(0x</span><span class="si">{</span><span class="nf">format_answer</span><span class="p">(</span><span class="n">n_test</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="si">}</span><span class="s">) in base 16 = 0x</span><span class="si">{</span><span class="nf">format_answer</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Result:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S(0x3) in base 16 = 0x4077C0
S(0x5) in base 16 = 0x286D8F92C0
S(0xA) in base 16 = 0x18E48B4FC2A0A98C
S(0xAA) in base 16 = 0x6CFD29A04AFAB77
</code></pre></div></div> <p><br></p> <hr> <h3 id="modular-solution--part-i-using-modular-inverses-intentionally-unoptimized">Modular Solution ‚Äì Part I: Using Modular Inverses (Intentionally Unoptimized)</h3> <p>Up to this point, we have derived exact formulas for</p> \[S(n) = \sum_{k=1}^{n} k \cdot A(k) \cdot B(k),\] <p>where</p> \[A(k) = \sum_{m=k}^{n} \frac{(m-1)!}{(m-k)!} \quad\text{and}\quad B(k) = \sum_{\substack{c_1+\cdots+c_{b-1}=k}} \frac{f(c_1,\dots,c_{b-1})}{\prod_{i=1}^{b-1} c_i!}.\] <p>All previous formulations were exact (integer or rational).<br> However, for the actual problem we only need the result modulo a fixed integer $M = \mbox{0x1FFFFFFFFFFFFFFF}$. This allows us to switch to modular arithmetic and drastically reduce both memory usage and runtime.</p> <p><em>1. Replacing division by modular inverses</em></p> <p>In modular arithmetic, division by a number $x$ is replaced by multiplication with its modular inverse $x^{-1}$, defined by</p> \[x \cdot x^{-1} \equiv 1 \pmod{M}.\] <p>If $M$ is prime, then every $x \not\equiv 0 \pmod{M}$ has an inverse, and Fermat‚Äôs little theorem gives the explicit formula \(x^{-1} \equiv x^{M-2} \pmod{M}.\)</p> <p>This is exactly what we need, because all denominators in our formulas are of the form</p> <ul> <li>factorials $c!$ and $(m-k)!$,</li> <li>the constant factor $b-1$,</li> </ul> <p>and for a prime modulus $M &gt; n$, none of these are divisible by $M$.</p> <p><em>2. Modular form of $A(k)$</em></p> <p>The quantity</p> \[A(k) = \sum_{m=k}^{n} \frac{(m-1)!}{(m-k)!}\] <p>contains only factorial ratios.</p> <p>Modulo $M$, we compute each term as</p> \[\frac{(m-1)!}{(m-k)!} \equiv (m-1)! \cdot \bigl((m-k)!\bigr)^{-1} \pmod{M}.\] <p>Thus $A(k)$ can be accumulated term-by-term using modular factorials and modular inverses.</p> <p><em>3. Modular DP for $B(k)$</em></p> <p>Recall the digit-based DP for computing $B(k)$, which tracks two sequences:</p> <ul> <li>$W[t]$: total ‚Äúweight mass‚Äù of patterns of length $t$,</li> <li>$B[t]$: weighted sum of values of those patterns.</li> </ul> <p>In the exact (rational) formulation, each extension by $c$ copies of a digit introduces a factor $1/c!$. Modulo $M$, this becomes multiplication by the modular inverse $(c!)^{-1}$.</p> <p>When appending $c$ copies of digit $d$, the numeric transformation is</p> \[x \longmapsto x \cdot b^c + d \cdot \frac{b^c - 1}{b - 1}.\] <p>Both divisions are handled via modular inverses:</p> \[\frac{1}{c!} \equiv (c!)^{-1} \pmod{M}, \qquad \frac{1}{b-1} \equiv (b-1)^{-1} \pmod{M}.\] <p>As a result, the DP updates for $W$ and $B$ carry over unchanged in structure; only every division is replaced by a multiplication with the corresponding inverse modulo $M$.</p> <p><em>4. Final modular assembly</em></p> <p>Once $A(k)$ and $B(k)$ have been computed modulo $M$, the final sum is assembled as</p> \[S(n) \equiv \sum_{k=1}^{n} k \cdot A(k) \cdot B(k) \pmod{M}.\] <p>All operations are now modular, and no exact rational arithmetic is needed.</p> <p><em>5. Validity of the approach</em></p> <p>This modular formulation is mathematically sound provided that</p> <ul> <li>$M$ is prime, and</li> <li>$M &gt; n$.</li> </ul> <p>Under these conditions, every factorial and constant appearing in a denominator has a modular inverse, so all divisions are well-defined. For the given problem, the modulus $\mbox{0x1FFFFFFFFFFFFFFF}$ is prime (a so-called <a href="https://en.wikipedia.org/wiki/Mersenne_prime" rel="external nofollow noopener" target="_blank">Mersenne prime</a> with the value $2^{61}-1$) and much larger than $n = 18$, so the modular approach applies without restriction.</p> <p>At this point, we already have a fully correct modular solution. In the next section, we will refine it further by reducing redundant computations and improving performance, leading to the final optimized implementation.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="n">math</span>
<span class="kn">from</span> <span class="n">sympy</span> <span class="kn">import</span> <span class="n">totient</span>


<span class="k">def</span> <span class="nf">S</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">mod</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Compute S(n) modulo `mod` using the modular A(k)/B(k) decomposition.

    This is the modular analogue of the integer-scaled DP:

        S(n) = sum_{k=1..n} k * A(k) * B(k)  (mod mod)

    where
        A(k) = sum_{m=k..n} (m-1)! / (m-k)!,
    and B(k) is obtained via a digit-DP over digits 1..(base-1).

    Modular inverses are computed using Euler</span><span class="sh">'</span><span class="s">s theorem:
        a^{-1} ‚â° a^{œÜ(mod)-1} (mod mod),
    which requires gcd(a, mod) = 1 for all inverted values.
    </span><span class="sh">"""</span>

    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="c1"># Helpers
</span>    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="n">phi_mod</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">totient</span><span class="p">(</span><span class="n">mod</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">inv_mod</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">Modular inverse using Euler</span><span class="sh">'</span><span class="s">s theorem (assumes gcd(a, mod) = 1).</span><span class="sh">"""</span>
        <span class="k">return</span> <span class="nf">pow</span><span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="n">mod</span><span class="p">,</span> <span class="n">phi_mod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">factorial_mod</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">Compute m! modulo mod (naive O(m)).</span><span class="sh">"""</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="p">(</span><span class="n">acc</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span>
        <span class="k">return</span> <span class="n">acc</span>

    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="c1"># 1) Compute A(k) = sum_{m=k..n} (m-1)! / (m-k)!   (mod mod)
</span>    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">numerator</span> <span class="o">=</span> <span class="nf">factorial_mod</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="nf">factorial_mod</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">numerator</span> <span class="o">*</span> <span class="nf">inv_mod</span><span class="p">(</span><span class="n">denominator</span><span class="p">))</span> <span class="o">%</span> <span class="n">mod</span>

    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="c1"># 2) Compute B(k) via digit DP (fraction-style, but done modulo mod)
</span>    <span class="c1">#
</span>    <span class="c1"># W[t] = sum of weights for patterns of length t
</span>    <span class="c1"># B[t] = weighted sum of values for patterns of length t
</span>    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="n">W</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># empty pattern has weight 1
</span>    <span class="n">inv_base_minus_1</span> <span class="o">=</span> <span class="nf">inv_mod</span><span class="p">(</span><span class="n">base</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>  <span class="c1"># digits 1..(base-1)
</span>        <span class="n">newW</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">newB</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">W</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">B</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># coef = 1 / c!  (mod mod)
</span>                <span class="n">coef</span> <span class="o">=</span> <span class="nf">inv_mod</span><span class="p">(</span><span class="nf">factorial_mod</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

                <span class="c1"># base^c mod mod (shift old values)
</span>                <span class="n">p_base</span> <span class="o">=</span> <span class="nf">pow</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span>

                <span class="c1"># rep(c) = (base^c - 1) / (base - 1)
</span>                <span class="n">rep</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_base</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_base_minus_1</span> <span class="o">%</span> <span class="n">mod</span>

                <span class="c1"># Update weights
</span>                <span class="n">newW</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">newW</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">W</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="n">coef</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span>

                <span class="c1"># Update value sums
</span>                <span class="n">shifted_old</span> <span class="o">=</span> <span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="n">p_base</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span>
                <span class="n">suffix_part</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">rep</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span>
                <span class="n">newB</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">newB</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">shifted_old</span> <span class="o">+</span> <span class="n">suffix_part</span><span class="p">)</span> <span class="o">*</span> <span class="n">coef</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span>

        <span class="n">W</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">newW</span><span class="p">,</span> <span class="n">newB</span>

    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="c1"># 3) Assemble final answer
</span>    <span class="c1"># -------------------------------------------------------------------------
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">ans</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">%</span> <span class="n">mod</span>

    <span class="k">return</span> <span class="n">ans</span>


<span class="c1"># Example usage: compute S(n) for hexadecimal numbers
</span><span class="n">base</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">mod</span> <span class="o">=</span> <span class="mh">0x1FFFFFFFFFFFFFFF</span>
<span class="k">for</span> <span class="n">n_test</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mh">0xA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">):</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nc">S</span><span class="p">(</span><span class="n">n_test</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">mod</span><span class="o">=</span><span class="n">mod</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">S(0x</span><span class="si">{</span><span class="nf">format_answer</span><span class="p">(</span><span class="n">n_test</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="si">}</span><span class="s">) in base 16 = 0x</span><span class="si">{</span><span class="nf">format_answer</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>If we compare the output to the above result (mod 0x1FFFFFFFFFFFFFFF) we see that our modular approach is correct. However, it is still fairly slow. In fact, it is slower than the approach above where we eliminated the fractions.</p> <p>Output:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S(0x3) in base 16 = 0x4077C0
S(0x5) in base 16 = 0x286D8F92C0
S(0xA) in base 16 = 0x18E48B4FC2A0A98C
S(0xAA) in base 16 = 0x6CFD29A04AFAB77
</code></pre></div></div> <hr> <p><br></p> <h3 id="modular-solution--part-ii-practical-optimizations-caching--precomputation">Modular Solution ‚Äì Part II: Practical Optimizations (Caching &amp; Precomputation)</h3> <p>The modular DP from Part I is already mathematically clean, but a direct implementation can still be slow if we repeatedly recompute the same building blocks inside the inner loops. The biggest cost drivers are:</p> <ul> <li>factorials $c! \bmod M$,</li> <li>modular inverses $(c!)^{-1} \bmod M$,</li> <li>powers $b^c \bmod M$,</li> <li>and the geometric sum \(R_c = \frac{b^c-1}{b-1} \pmod M.\)</li> </ul> <p>Since $n$ is fixed (and small compared to $M$), all of these quantities depend only on $c \in {0,\dots,n}$ and can be precomputed once.</p> <p>Below is a summary of the optimizations performed.</p> <p><em>1) Precompute factorials once: $i! \bmod M$</em></p> <p>Instead of recomputing factorials in $O(i)$ repeatedly, we precompute the array</p> \[\texttt{fact}[i] \equiv i! \pmod M \qquad (0 \le i \le n)\] <p>via the recurrence</p> \[\texttt{fact}[0]=1,\qquad \texttt{fact}[i]=\texttt{fact}[i-1]\cdot i \pmod M.\] <p>This turns many factorial evaluations from ‚Äúloop work‚Äù into an $O(1)$ lookup.</p> <p><em>2) Precompute inverse factorials in $O(n)$ (only one expensive exponentiation)</em></p> <p>The naive modular approach computed $(c!)^{-1}$ by an exponentiation for every $c$. Instead, we compute all inverse factorials with only <strong>one</strong> exponentiation.</p> <p>First compute</p> \[\texttt{inv_fact}[n] \equiv (n!)^{-1} \equiv (n!)^{M-2} \pmod M\] <p>(using Fermat since $M$ is prime), then use the backward recurrence</p> \[\texttt{inv_fact}[i-1] = \texttt{inv_fact}[i]\cdot i \pmod M.\] <p>This works because</p> \[(i-1)!^{-1} = (i!)^{-1}\cdot i.\] <p>As a result, the frequent coefficient \(\frac{1}{c!} \pmod M\) becomes a simple lookup $\texttt{inv_fact}[c]$.</p> <p><em>3) Precompute $b^c \bmod M$ for all $c \le n$</em></p> <p>Inside the DP, we repeatedly need the shift factor $b^c$. We precompute</p> \[\texttt{pow_base}[c] \equiv b^c \pmod M\] <p>using</p> \[\texttt{pow_base}[0]=1,\qquad \texttt{pow_base}[c]=\texttt{pow_base}[c-1]\cdot b \pmod M.\] <p>This removes all repeated modular exponentiations from the inner loop.</p> <p><em>4) Precompute the geometric repunit factor $R_c$</em></p> <p>The appended suffix of $c$ copies of digit $d$ uses</p> \[R_c = 1 + b + \cdots + b^{c-1} = \frac{b^c-1}{b-1}.\] <p>We compute $(b-1)^{-1} \bmod M$ once:</p> \[(b-1)^{-1} \equiv (b-1)^{M-2} \pmod M,\] <p>and then precompute</p> \[\texttt{rep}[c] \equiv (b^c-1)\cdot (b-1)^{-1} \pmod M.\] <p>So the suffix contribution in the DP, \(d\cdot R_c,\) becomes a fast lookup-and-multiply.</p> <p><em>5) Reuse cached values in the DP inner loops</em></p> <p>After precomputations, the DP update for each $(t,c)$ only uses:</p> <ul> <li>$\texttt{inv_fact}[c]$ for $1/c!$,</li> <li>$\texttt{pow_base}[c]$ for $b^c$,</li> <li>$\texttt{rep}[c]$ for $(b^c-1)/(b-1)$,</li> </ul> <p>and does only $O(1)$ modular multiplications/additions.</p> <p>This preserves the same DP logic, but removes the ‚Äúhidden‚Äù heavy costs (exponentiation, factorial loops, repeated inverses) from the hot path.</p> <p><em>6) Faster computation of $A(k)$ via cached factorials</em></p> <p>Similarly,</p> \[A(k) = \sum_{m=k}^{n} \frac{(m-1)!}{(m-k)!} \equiv \sum_{m=k}^{n} (m-1)!\cdot ((m-k)!)^{-1} \pmod M\] <p>becomes</p> \[A(k) \equiv \sum_{m=k}^{n} \texttt{fact}[m-1]\cdot \texttt{inv_fact}[m-k] \pmod M,\] <p>again turning factorial and inverse computations into array lookups.</p> <p>All optimizations are ‚Äúmechanical‚Äù (precompute and reuse), but together they remove nearly all expensive operations from the inner loops.</p> <ul> <li>no repeated factorial loops,</li> <li>no repeated modular exponentiation inside the DP,</li> <li>no repeated modular inverse computation per iteration,</li> <li>only cheap modular arithmetic in the hot path.</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="n">sympy</span> <span class="kn">import</span> <span class="n">totient</span>


<span class="k">def</span> <span class="nf">S</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">mod</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Compute S(n) modulo `mod` using the modular A(k)/B(k) decomposition.

    Same logic as above version, but faster by caching:
      - factorials (0!..n!) modulo mod
      - inverse factorials via pow(fact[n], phi-1) and downward recurrence
      - powers base^c modulo mod for c=0..n
      - rep(c) = (base^c - 1)/(base-1) modulo mod for c=0..n

    NOTE: This assumes all inverses exist (e.g. mod is prime and mod &gt; n, or at
    least gcd(denominator, mod)=1 for all denominators we invert).
    </span><span class="sh">"""</span>
    <span class="n">phi_mod</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">totient</span><span class="p">(</span><span class="n">mod</span><span class="p">))</span>

    <span class="c1"># ---------------------------------------------------------------------
</span>    <span class="c1"># Precompute factorials and inverse factorials up to n
</span>    <span class="c1"># ---------------------------------------------------------------------
</span>    <span class="n">fact</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>      <span class="c1"># fact[i] = i! mod mod
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">fact</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fact</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span>

    <span class="c1"># inv_fact[i] = (i!)^{-1} mod mod, computed in O(n) using one pow() + recurrence
</span>    <span class="n">inv_fact</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">inv_fact</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nf">pow</span><span class="p">(</span><span class="n">fact</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">phi_mod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span>  <span class="c1"># (n!)^{-1}
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># (i-1)!^{-1} = i!^{-1} * i
</span>        <span class="n">inv_fact</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">inv_fact</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span>

    <span class="c1"># Also cache (base-1)^{-1} mod mod, used in rep(c)
</span>    <span class="n">inv_base_minus_1</span> <span class="o">=</span> <span class="nf">pow</span><span class="p">(</span><span class="n">base</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">phi_mod</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span>

    <span class="c1"># ---------------------------------------------------------------------
</span>    <span class="c1"># Precompute powers and rep(c) for c=0..n
</span>    <span class="c1"># ---------------------------------------------------------------------
</span>    <span class="n">pow_base</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># pow_base[c] = base^c mod mod
</span>    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">pow_base</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pow_base</span><span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">base</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span>

    <span class="c1"># rep[c] = (base^c - 1)/(base-1) mod mod
</span>    <span class="n">rep</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">rep</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pow_base</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_base_minus_1</span> <span class="o">%</span> <span class="n">mod</span>

    <span class="c1"># coef[c] = 1/c! mod mod  (used very frequently in the DP)
</span>    <span class="n">inv_c_fact</span> <span class="o">=</span> <span class="n">inv_fact</span>  <span class="c1"># alias to make intent clearer
</span>
    <span class="c1"># ---------------------------------------------------------------------
</span>    <span class="c1"># 1) Compute A(k) = sum_{m=k..n} (m-1)! / (m-k)!   (mod mod)
</span>    <span class="c1">#    =&gt; (m-1)! * ((m-k)!)^{-1}
</span>    <span class="c1"># ---------------------------------------------------------------------
</span>    <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="p">(</span><span class="n">acc</span> <span class="o">+</span> <span class="n">fact</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">inv_fact</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="n">k</span><span class="p">])</span> <span class="o">%</span> <span class="n">mod</span>
        <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">acc</span>

    <span class="c1"># ---------------------------------------------------------------------
</span>    <span class="c1"># 2) Compute B(k) via digit DP (fraction-style, modulo arithmetic)
</span>    <span class="c1"># ---------------------------------------------------------------------
</span>    <span class="n">W</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="n">newW</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">newB</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">wt</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
            <span class="n">bt</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wt</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">bt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Append c copies of digit d, with 0 &lt;= c &lt;= n-t
</span>            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">coef</span> <span class="o">=</span> <span class="n">inv_c_fact</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>         <span class="c1"># 1/c!
</span>                <span class="n">p</span> <span class="o">=</span> <span class="n">pow_base</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>              <span class="c1"># base^c
</span>                <span class="n">r</span> <span class="o">=</span> <span class="n">rep</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>                   <span class="c1"># (base^c - 1)/(base-1)
</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">c</span>

                <span class="c1"># newW[idx] += W[t] * coef
</span>                <span class="n">newW</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">newW</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">wt</span> <span class="o">*</span> <span class="n">coef</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span>

                <span class="c1"># newB[idx] += (B[t] * base^c + W[t] * d * rep(c)) * coef
</span>                <span class="n">shifted_old</span> <span class="o">=</span> <span class="p">(</span><span class="n">bt</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span>
                <span class="n">suffix_part</span> <span class="o">=</span> <span class="p">(</span><span class="n">wt</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span>
                <span class="n">suffix_part</span> <span class="o">=</span> <span class="p">(</span><span class="n">suffix_part</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span>
                <span class="n">newB</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">newB</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">shifted_old</span> <span class="o">+</span> <span class="n">suffix_part</span><span class="p">)</span> <span class="o">*</span> <span class="n">coef</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span>

        <span class="n">W</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">newW</span><span class="p">,</span> <span class="n">newB</span>

    <span class="c1"># ---------------------------------------------------------------------
</span>    <span class="c1"># 3) Assemble final answer: sum_{k=1..n} k * A[k] * B[k]
</span>    <span class="c1"># ---------------------------------------------------------------------
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">ans</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">%</span> <span class="n">mod</span>

    <span class="k">return</span> <span class="n">ans</span>


<span class="c1"># Example usage (kept close to yours)
</span><span class="n">base</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">mod</span>  <span class="o">=</span> <span class="mh">0x1FFFFFFFFFFFFFFF</span>
<span class="k">for</span> <span class="n">n_test</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mh">0xA</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">):</span>
     <span class="n">value</span> <span class="o">=</span> <span class="nc">S</span><span class="p">(</span><span class="n">n_test</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">mod</span><span class="o">=</span><span class="n">mod</span><span class="p">)</span>
     <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">S(0x</span><span class="si">{</span><span class="nf">format_answer</span><span class="p">(</span><span class="n">n_test</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="si">}</span><span class="s">) in base 16 = 0x</span><span class="si">{</span><span class="nf">format_answer</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S(0x3) in base 16 = 0x4077C0
S(0x5) in base 16 = 0x286D8F92C0
S(0xA) in base 16 = 0x18E48B4FC2A0A98C
S(0xAA) in base 16 = 0x6CFD29A04AFAB77
</code></pre></div></div> <p>Also, now we can finally compute $S(0xAAA)$ (although it might also need a minute or so):</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="o">=</span> <span class="nc">S</span><span class="p">(</span><span class="mh">0xAAA</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">mod</span><span class="o">=</span><span class="n">mod</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">S(0xAAA) in base 16 = 0x</span><span class="si">{</span><span class="nf">format_answer</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Output:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S(0xAAA) in base 16 = 0x103528902352939
</code></pre></div></div> <p>which finally earns us the Gold!!! ü•á medal üéâü•≥!</p> <p>While there is still some room for further optimization, we stop here, as the final solution already runs in feasible time. Additional speed-ups are left to the interested reader.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://blog.google/technology/ai/google-gemini-update-flash-ai-assistant-io-2024/" target="_blank" rel="external nofollow noopener">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://medium.com/@al-folio/displaying-external-posts-on-your-al-folio-blog-b60a1d241a0a?source=rss-17feae71c3c4------2" target="_blank" rel="external nofollow noopener">Displaying External Posts on Your al-folio Blog</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/mini-sudoku-asm/">Solving a Mini Sudoku in 6502 Assembly</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/pe-785p100-hexadecimal-digit-canon/">The Hexadecimal Digit Canon Challenge</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/pe-83p100-quanity-equal-parts/">Short Notes: Equal Partitions, Products, and Decimal Structure</a> </li> <div id="giscus_thread" style="max-width: 1000px; margin: 0 auto;"> <br> <script defer src="/assets/js/giscus-setup.js"></script> <noscript> Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> ¬© Copyright 2026 Markus Thill. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a> and from <a href="https://www.freepik.com/" rel="external nofollow noopener" target="_blank">Freepik</a>. Last updated: January 31, 2026. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?v=a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?v=85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?v=2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?v=b608866baffe761c7f8f7670a3310d0f"></script> <script defer src="/assets/js/copy_code.js?v=c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?v=d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?v=a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?v=2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/tabs.min.js?v=b8748955e1076bbe0dabcf28f2549fdc"></script> <script type="module" src="/assets/js/search/ninja-keys.min.js?v=a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?v=6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?v=ccc841c459bfc0e64c1c2b5acd10df02"></script> </body> </html>