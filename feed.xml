<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://markusthill.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://markusthill.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-16T21:12:48+00:00</updated><id>https://markusthill.github.io/feed.xml</id><title type="html">blank</title><subtitle>Personal notes and code snippets on math, ML &amp; programming. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Optimizing Lagged Fibonacci Generators for Large-Scale Computations</title><link href="https://markusthill.github.io/blog/2024/lagged-fibo-sequences/" rel="alternate" type="text/html" title="Optimizing Lagged Fibonacci Generators for Large-Scale Computations"/><published>2024-12-16T01:16:00+00:00</published><updated>2024-12-16T01:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/lagged-fibo-sequences</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/lagged-fibo-sequences/"><![CDATA[<p>Lagged Fibonacci Generators (LFGs) are widely used in simulations and cryptography for generating pseudo-random sequences. While the naive implementation is straightforward, it becomes inefficient for large indices ($n$) due to its iterative nature and growing computational costs.</p> <p>To address these challenges, we introduce an optimized approach using matrix exponentiation and modular arithmetic. By encoding the recurrence relation in a transformation matrix $\mathbf{Q}$, the sequence can be computed efficiently through binary exponentiation. This method scales well, especially with GPU acceleration via libraries like cupy, enabling faster computations for large-scale problems.</p> <p>With a foundation in linear algebra, this approach not only improves runtime but also demonstrates the power of combining mathematical insights with computational techniques for efficient random number generation. Although the approach presented below is already pretty good, it has some shortcomings like large memory requirements. Other approaches such as generating functions, representing the series as the coefficients of a power series, might be advantageous in practice.</p> <p>Follow along in the Jupyter notebook below:</p> <style>.jupyter-child-ext{width:112%;position:relative;left:calc(-10%)}</style> <div class="jupyter-child-ext"> <div class="jupyter-notebook" style="position: relative; width: 100%; margin: 0 auto;"> <div class="jupyter-notebook-iframe-container"> <iframe src="/assets/jupyter/MarkusThill.github.io-jupyter/2024_12_16_pe_200p58.ipynb.html" style="position: absolute; top: 0; left: 0; border-style: none;" width="100%" height="100%" onload="this.parentElement.style.paddingBottom = (this.contentWindow.document.documentElement.scrollHeight + 10) + 'px'"></iframe> </div> </div> </div>]]></content><author><name></name></author><category term="math"/><category term="fibonacci"/><category term="sequences"/><summary type="html"><![CDATA[Lagged Fibonacci Generators (LFGs) are powerful tools for generating pseudo-random sequences in simulations and cryptography. While traditional implementations become inefficient when computing sparse terms at large indices, this blog explores an optimized approach using matrix exponentiation and modular arithmetic. By encoding the recurrence relation in a transformation matrix and leveraging GPU acceleration, the method achieves scalability and speed, making it ideal for large-scale applications.]]></summary></entry><entry><title type="html">Some Interesting Properties of the Exclusive Or (XOR)</title><link href="https://markusthill.github.io/blog/2024/a-few-properties-of-the-exclusive-or/" rel="alternate" type="text/html" title="Some Interesting Properties of the Exclusive Or (XOR)"/><published>2024-12-13T08:16:00+00:00</published><updated>2024-12-13T08:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/a-few-properties-of-the-exclusive-or</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/a-few-properties-of-the-exclusive-or/"><![CDATA[<p>The exclusive-OR – sometimes also exclusive disjunction (short: XOR) or antivalence – is a boolean operation which only outputs true if only exactly one of its both inputs is true (so if both inputs differ). There are many applications where the XOR is used, for instance in cryptography, gray codes, parity and CRC checks and certainly many more. Commonly, the \(\oplus\) symbol is used to denote the XOR operation. Here, we will use the \(\nleftrightarrow\) symbol for the Exclusive-OR and \(\leftrightarrow\) for its negation, the biconditional operator. In this blog post we will look at a few of its interesting properties which can be useful.</p> <p>Let us start with the truth table of the Exclusive-OR (\(\nleftrightarrow\)) and the biconditional:</p> <table> <thead> <tr> <th style="text-align: right">a</th> <th style="text-align: center">b</th> <th style="text-align: center">a \(\nleftrightarrow\) b</th> <th style="text-align: left">a \(\leftrightarrow\) b</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">0</td> <td style="text-align: center">0</td> <td style="text-align: center">0</td> <td style="text-align: left">1</td> </tr> <tr> <td style="text-align: right">0</td> <td style="text-align: center">1</td> <td style="text-align: center">1</td> <td style="text-align: left">0</td> </tr> <tr> <td style="text-align: right">1</td> <td style="text-align: center">0</td> <td style="text-align: center">1</td> <td style="text-align: left">0</td> </tr> <tr> <td style="text-align: right">1</td> <td style="text-align: center">1</td> <td style="text-align: center">0</td> <td style="text-align: left">1</td> </tr> </tbody> </table> <h3 id="definition">Definition</h3> <p>From this table we can extract the following equations, which is the most commonly used definition of the XOR operation:</p> \[\begin{align} a \nleftrightarrow b = \bar a b \vee a \bar b \quad \mbox{and} \quad a \leftrightarrow b = \bar a \bar b \vee a b \label{eq:definition} \end{align}\] <h3 id="inverse-element">Inverse Element</h3> <p>Note that the logical AND operation (\(a \wedge b\)) is written as \(ab\). Both operations have an inverse element (1 and 0) so that</p> \[\begin{align} a \nleftrightarrow 1 = \bar a \quad \mbox{and} \quad a \leftrightarrow 0 = \bar a \\ a \nleftrightarrow \bar a = 1 \quad \mbox{and} \quad a \leftrightarrow \bar a = 0 \end{align}\] <h3 id="neutral-element">Neutral Element</h3> <p>For the Exclusive-OR and the biconditional also a neutral element exists (0 and 1):</p> \[\begin{align} a \nleftrightarrow 0 = a \quad \mbox{and} \quad a \leftrightarrow 1 = a \\ \end{align}\] <h3 id="idempotency">Idempotency</h3> <p>It can easily be shown that the the XOR does not fulfil the idempotency property, which states that for any operation \(\circ\) we have \(a \circ a = a\). From the truth table we can see that</p> <p>\(\begin{align} a \nleftrightarrow a = 0 \quad \mbox{and} \quad a \leftrightarrow a = 1. \\ \end{align}\).</p> <h3 id="inverse-of-the-exclusive-or">Inverse of the Exclusive OR</h3> <p>We have already mentioned that the inverse of the XOR is the biconditional operator. This can also be easily seen from the truth table. However, it is also possible to show this formally:</p> \[\begin{align} a \nleftrightarrow b = \overline{a \leftrightarrow b} \quad \mbox{and} \quad a \leftrightarrow b = \overline{a \nleftrightarrow b} \label{eq:inverseXOR} \end{align}\] <p>since – using Eq. \eqref{eq:definition} :</p> \[\begin{align*} &amp; a \nleftrightarrow b = \bar a b \vee a \bar b = \overline{ \overline{\bar a b} \wedge \overline{a \bar b}} = \overline{(a \vee \bar b) \wedge (\bar a \vee b)} \\ &amp;= \overline{a(\bar a \vee b) \vee \bar b (\bar a \vee b)} = \overline{ab \vee \bar a \bar b}\\ &amp;= \overline{a \leftrightarrow b} \end{align*}\] <h3 id="commutativity">Commutativity</h3> <p>Commutativity is given in both cases as well:</p> \[\begin{align} a \nleftrightarrow b = b \nleftrightarrow a \quad \mbox{and} \quad a \leftrightarrow b = b \leftrightarrow a \label{eq:Commutativity} \end{align}\] <p>since</p> \[\begin{align} a \nleftrightarrow b = \bar a b \vee a \bar b = \bar b a \vee b \bar a = b \nleftrightarrow a \quad (\mbox{analogously for} \leftrightarrow )\\ \end{align}\] <h3 id="associativity">Associativity</h3> <p>Also the associative property is fulfilled:</p> \[\begin{align} a \nleftrightarrow b \nleftrightarrow c = (a \nleftrightarrow b) \nleftrightarrow c = a \nleftrightarrow (b \nleftrightarrow c) \\ a \leftrightarrow b \leftrightarrow c = (a \leftrightarrow b) \leftrightarrow c = a \leftrightarrow (b \leftrightarrow c) \\ \end{align}\] <p>since – using rules \eqref{eq:definition} and \eqref{eq:inverseXOR}.</p> \[\begin{align*} &amp; a \nleftrightarrow (b \nleftrightarrow c) = a \nleftrightarrow (\bar b c \vee b \bar c) = \bar a (\bar b c \vee b \bar c) \vee a \overline{\bar b c \vee b \bar c} \\ &amp;= \bar a \bar b c \vee \bar a b \bar c \vee a( b \vee \bar c) (\bar b \vee c) = \bar a \bar b c \vee \bar a b \bar c \vee abc \vee a \bar b \bar c \\ &amp;= (ab \vee \bar a \bar b)c \vee (\bar a b \vee a \bar b)\bar c = \overline{a \nleftrightarrow b} c \vee (a \nleftrightarrow b) \bar c \\ &amp;= (a \nleftrightarrow b) \nleftrightarrow c = a \nleftrightarrow b \nleftrightarrow c \end{align*}\] <h3 id="distributivity">Distributivity</h3> <p>As we will see later, the conjunction (AND) and Exclusive-OR (biconditional) represent the multiplication and addition operations of a Galois field GF(2), and in such a field they follow the distributive law:</p> \[\begin{align} a(b \nleftrightarrow c) = ab \nleftrightarrow ac \quad \mbox{and} \quad a(b \leftrightarrow c) = ab \leftrightarrow ac \end{align}\] <p>since – with Eq. \eqref{eq:inverseXOR}:</p> \[\begin{align*} a(b \nleftrightarrow c) &amp;\overset{!}{=} ab \nleftrightarrow ac \\ a( b \bar c \vee \bar b c) &amp;\overset{!}{=} ab \overline{ac} \vee \overline{ab} bc \\ a b \bar c \vee a \bar b c &amp;\overset{!}{=} ab (\bar a \vee \bar c) \vee (\bar a \vee \bar b) ac \\ a b \bar c \vee a \bar b c &amp;= ab \bar c \vee a \bar b c \end{align*}\] <p>This holds accordingly for the biconditional operator.</p> <h3 id="inverting-a-single-operand">Inverting a single Operand</h3> \[\begin{align} \bar a \nleftrightarrow b = \overline{a \nleftrightarrow b} \quad \mbox{and} \quad \bar a \leftrightarrow b = \overline{a \leftrightarrow b} \label{eq:invOne} \end{align}\] <p>since – with Eq. \eqref{eq:inverseXOR}:</p> \[\begin{align*} \bar a \nleftrightarrow b = ab \vee \bar a \bar b = a \leftrightarrow b = \overline{a \nleftrightarrow b}. \end{align*}\] <h3 id="inverting-both-operands">Inverting both Operands</h3> \[\begin{align} \bar a \nleftrightarrow \bar b = a \nleftrightarrow b \quad \mbox{and} \quad \bar a \leftrightarrow \bar b = a \leftrightarrow b \label{eq:invBoth} \end{align}\] <p>which can be shown trivially with \eqref{eq:definition}:</p> \[\begin{align*} \bar a \nleftrightarrow \bar b = a \bar b \vee \bar a b = a \nleftrightarrow b \\ \end{align*}\] <h3 id="expressing-the-logical-or-in-terms-of-the-exclusive-or">Expressing the Logical OR in Terms of the Exclusive-OR</h3> <p>We can find the following expression:</p> \[\begin{align} a \vee b = (a \nleftrightarrow b) \vee ab \label{eq:OR-XOR} \end{align}\] <p>since – by expanding a and b, with \((ab \vee a\bar b) = a(b \vee \bar b) = a\):</p> \[\begin{align*} a\vee b &amp;= (ab \vee a\bar b) \vee (ab \vee \bar a b) = \bar a b \vee a \bar b \vee ab \\ &amp;= (a \nleftrightarrow b) \vee ab \end{align*}\] <p>Since the above equation again contains a disjunction (OR), this does not appear like any improvement, however, this rule can be helpful in deriving many other relations. For example, let us apply the rule \eqref{eq:OR-XOR} to itself:</p> <p>Let us first identify:</p> \[\begin{align*} A &amp;= a \nleftrightarrow b \\ B &amp;= ab \end{align*}\] <p>Then we have (inserting the original expressions for \(A\) and \(B\) after some time again):</p> \[\begin{align*} A \vee B &amp;= (A \nleftrightarrow B) \vee AB \\ &amp;= (A \nleftrightarrow B) \vee (a \nleftrightarrow b)ab \\ &amp;= (A \nleftrightarrow B) \vee (\bar a b \vee a \bar b)ab \\ \end{align*}\] <p>Since the terms \(\bar a b\) and \(a \bar b\) are disjunct to \(ab\), the above expression simplifys to:</p> \[\begin{align*} (A \nleftrightarrow B) \vee (\bar a b \vee a \bar b)ab &amp;= A \nleftrightarrow B \\ \end{align*}\] <p>This leads finally to some interesting relation:</p> \[\begin{align} a \vee b &amp;= (a \nleftrightarrow b) \vee ab \nonumber\\ &amp;= A \nleftrightarrow B \\ &amp;= a \nleftrightarrow b \nleftrightarrow ab \nonumber \end{align}\] <h3 id="expressing-the-logical-and-in-terms-of-the-exclusive-or">Expressing the Logical AND in Terms of the Exclusive-OR</h3> <p>Analogously to the previous paragraph, one can derive some interesting relations for the logical AND (conjunction):</p> \[\begin{align} a \wedge b = (a \leftrightarrow b) \wedge (a \vee b) \end{align}\] <p>and</p> \[\begin{align} a \wedge b = a \leftrightarrow b \leftrightarrow (a \vee b) \end{align}\] <h3 id="the-logical-or-of-pairwise-disjunct-terms">The Logical OR of pairwise disjunct Terms</h3> <p>Using the rule \eqref{eq:OR-XOR} we can find another interesting relation for disjunctive forms where all terms are pairwise disjunct. Consider the following easy example – applying rule \eqref{eq:OR-XOR}:</p> \[\begin{align} \bar a b\vee a \bar b &amp;= (\bar a b \nleftrightarrow a \bar b) \vee (\bar a b\wedge a \bar b) \nonumber \\ &amp;= \bar a b \nleftrightarrow a \bar b \label{eq:xorAbsurdum} \end{align}\] <p>As a side note, we can also write above relation backwards, so that:</p> \[\begin{align} \bar a b \nleftrightarrow a \bar b &amp;= \bar a b\vee a \bar b \nonumber \\ &amp;= a \nleftrightarrow b \end{align}\] <p>With Eq.\eqref{eq:xorAbsurdum} we have an important relation that states that all OR operations in an disjunctive form can be simply replaced with an XOR, if all terms are pairwise disjunct. For example, the rule can be applied to the following disjunctive form:</p> \[\begin{align*} abc \vee \bar a bc \vee ab \bar c \\ = abc \nleftrightarrow \bar a bc \nleftrightarrow ab \bar c. \end{align*}\] <h3 id="the-logical-biconditional-and-exclusive-or-revisited">The Logical Biconditional and Exclusive-OR revisited</h3> <p>Sometimes it is possible to replace all biconditional operations in an equation by Exclusive-ORs. Consider the following example – with Eq. \eqref{eq:inverseXOR} and Eq. \eqref{eq:invOne}:</p> \[\begin{align*} a \leftrightarrow b \leftrightarrow c &amp;= \overline{a \nleftrightarrow b} \leftrightarrow c \\ &amp;= \overline{(a \nleftrightarrow b) \leftrightarrow c} \\ &amp;= a \nleftrightarrow b \nleftrightarrow c. \end{align*}\] <p>Or, in short:</p> \[\begin{align} a \leftrightarrow b \leftrightarrow c &amp;= a \nleftrightarrow b \nleftrightarrow c. \label{eq:BicondEqXOR} \end{align}\] <h3 id="the-combined-associative-property-of-the-logical-biconditional-and-the-exclusive-or">The combined Associative Property of the Logical Biconditional and the Exclusive-OR</h3> <p>Similarly to before, where we showed the associative property of the biconditional and the exclusive-OR for both cases separately, we can also show that the associative property also holds for mixed terms – with Eq.\eqref{eq:inverseXOR}, \eqref{eq:invOne} and \eqref{eq:BicondEqXOR}:</p> \[\begin{align*} (a \nleftrightarrow b) \leftrightarrow c &amp;\overset{!}{=} a \nleftrightarrow (b \leftrightarrow c) \\ \overline{a \leftrightarrow b} \leftrightarrow c &amp;\overset{!}{=} a \nleftrightarrow \overline{b \nleftrightarrow c} \\ \overline{a \leftrightarrow b \leftrightarrow c} &amp;\overset{!}{=} \overline{a \nleftrightarrow b \nleftrightarrow c} \\ a \leftrightarrow b \leftrightarrow c &amp;= a \nleftrightarrow b \nleftrightarrow c \\ \end{align*}\] <p>This allows us to state: \(\begin{align} (a \nleftrightarrow b) \leftrightarrow c = a \nleftrightarrow (b \leftrightarrow c) = a \nleftrightarrow b \leftrightarrow c \label{eq:mixedassociative} \end{align}\)</p> <h3 id="the-combined-commutative-property-of-the-logical-biconditional-and-the-exclusive-or">The combined Commutative Property of the Logical Biconditional and the Exclusive-OR</h3> <p>After we showed the combined associative property of the logical biconditional and the exclusive-OR, we accordingly show commutativity. We only need Eq. \eqref{eq:Commutativity} and \eqref{eq:mixedassociative}. The argumentation is then rather trivial:</p> \[\begin{align*} &amp;a \nleftrightarrow b \leftrightarrow c = (a \nleftrightarrow b) \leftrightarrow c = (b \nleftrightarrow a) \leftrightarrow c \\ = &amp;b \nleftrightarrow a \leftrightarrow c = b \nleftrightarrow (a \leftrightarrow c) = b \nleftrightarrow (c \leftrightarrow a) \\ = &amp;b \nleftrightarrow c \leftrightarrow a = (b \nleftrightarrow c) \leftrightarrow a = (c \nleftrightarrow b) \leftrightarrow a \\ = &amp; c \nleftrightarrow b \leftrightarrow a = \cdots \\ = &amp;a \nleftrightarrow b \leftrightarrow c = (a \nleftrightarrow b) \leftrightarrow c = c \leftrightarrow (a \nleftrightarrow b) \\ = &amp; c \leftrightarrow a \nleftrightarrow b = (c \leftrightarrow a) \nleftrightarrow b = b \nleftrightarrow (c \leftrightarrow a) \\ = &amp; b \nleftrightarrow c \leftrightarrow a = (b \nleftrightarrow c) \leftrightarrow a = a \leftrightarrow (b \nleftrightarrow c) \\ = &amp; a \leftrightarrow b \nleftrightarrow c = \cdots \end{align*}\] <p>In summary, we can write:</p> \[\begin{align} a \nleftrightarrow b \leftrightarrow c = b \nleftrightarrow a \leftrightarrow c = b \nleftrightarrow c \leftrightarrow a = c \nleftrightarrow b \leftrightarrow a = \cdots \nonumber \\ = c \leftrightarrow a \nleftrightarrow b = b \nleftrightarrow c \leftrightarrow a = a \leftrightarrow b \nleftrightarrow c = \cdots \label{eq:combinedCommutative} \end{align}\] <p>Hence, all terms in an mixed expression of XORs and biconditionals are pairwise interchangeable. This is a very important observation which can often help in practice.</p> <h3 id="replacing-exclusive-or-operations-in-an-expression-with-biconditionals">Replacing Exclusive-Or Operations in an Expression with Biconditionals</h3> <p>Assume, we have an expression in the form</p> \[\begin{align*} f(x_1, x_2, \ldots, x_n) = x_1 \nleftrightarrow x_2 \nleftrightarrow \ldots \nleftrightarrow x_n. \end{align*}\] <p>We want to replace all \(\nleftrightarrow\) operations with \(\leftrightarrow\). How can we achieve this? Actually, it is not that difficult. We can recursively apply the rules \eqref{eq:inverseXOR}, \eqref{eq:invOne} and \eqref{eq:mixedassociative} in the following way:</p> \[\begin{align*} f(x_1, x_2, \ldots, x_n) &amp;= \overline{x_1 \leftrightarrow (x_2 \nleftrightarrow x_3 \nleftrightarrow \ldots \nleftrightarrow x_n)} \\ &amp;= \overline{x_1 \leftrightarrow x_2 \nleftrightarrow x_3 \nleftrightarrow \ldots \nleftrightarrow x_n} \\ &amp;= \overline{x_1 \leftrightarrow \overline{x_2 \leftrightarrow (x_3 \nleftrightarrow \ldots \nleftrightarrow x_n)}} \\ &amp;= \overline{x_1 \leftrightarrow \overline{x_2 \leftrightarrow x_3 \nleftrightarrow \ldots \nleftrightarrow x_n}} \\ &amp;= \overline{ \overline{x_1 \leftrightarrow x_2 \leftrightarrow x_3 \nleftrightarrow \ldots \nleftrightarrow x_n}} \\ &amp;= x_1 \leftrightarrow x_2 \leftrightarrow x_3 \nleftrightarrow \ldots \nleftrightarrow x_n \\ &amp;= x_1 \leftrightarrow x_2 \leftrightarrow x_3 \leftrightarrow \overline{\ldots \nleftrightarrow x_n} \\ &amp;= \cdots \end{align*}\] <p>You can see where this is going: After replacing the first XOR we had a negation in the expression which vanished again after replacing the second XOR and then came back with the replacement of the third XOR. So, depending on the number of variables \(n\), we either have a negation left in the end or not. This can be expressed with:</p> \[\begin{align} f(x_1, x_2, \ldots, x_n) &amp;= x_1 \nleftrightarrow x_2 \nleftrightarrow \ldots \nleftrightarrow x_n \label{eq:replaceXOR} \\ \nonumber &amp;= \begin{cases} x_1 \leftrightarrow x_2 \leftrightarrow \ldots \leftrightarrow x_n,&amp; \text{if n is odd} \\ \nonumber \\ \overline{x_1 \leftrightarrow x_2 \leftrightarrow \ldots \leftrightarrow x_n},&amp; \text{if n is even} \end{cases}\\ \end{align}\] <p>Similarly, we find the following relation when we replace the biconditionals in an expression with the XOR operation:</p> \[\begin{align} f(x_1, x_2, \ldots, x_n) &amp;= x_1 \leftrightarrow x_2 \leftrightarrow \ldots \leftrightarrow x_n \label{eq:replaceBiconditional} \\ \nonumber &amp;= \begin{cases} x_1 \nleftrightarrow x_2 \nleftrightarrow \ldots \nleftrightarrow x_n,&amp; \text{if n is odd} \\ \nonumber \\ \overline{x_1 \nleftrightarrow x_2 \nleftrightarrow \ldots \nleftrightarrow x_n},&amp; \text{if n is even} \end{cases}\\ \end{align}\] <h3 id="mixed-representations-of-biconditionals-and-exclusive-ors">Mixed Representations of Biconditionals and Exclusive-ORs</h3> <p>Sometimes, one has mixed representations of biconditionals and exclusive-ORs, which cannot be implemented that efficiently in a digital circuit. In these cases it is possible to find representations consisting solely of XORs or solely of biconditionals. First, we have to bring our original representation in a form:</p> \[f_\nleftrightarrow(x_1,x_2,\ldots,x_m) \circ f_\leftrightarrow(x_{m+1}, x_{m+1}, \ldots, x_n)\] <p>where \(f_\nleftrightarrow\) just consists of XOR operations and \(f_\leftrightarrow\) just consists of biconditionals. For the \(\circ\) symbol, either \(\nleftrightarrow\) is inserted in case we want the final relation to consist of XORs, otherwise \(\leftrightarrow\) is inserted. Note that the above representation with \(f_\nleftrightarrow\) and \(f_\leftrightarrow\) can be easily achieved by simply applying the commutative property from Eq. \eqref{eq:combinedCommutative} to your original relation. Then you are almost done: You just have to apply \eqref{eq:replaceXOR} to \(f_\nleftrightarrow(x_1,x_2,\ldots,x_m)\) or \eqref{eq:replaceBiconditional} to \(f_\leftrightarrow(x_1,x_2,\ldots,x_m)\) – depending which operator you prefer – and finally you have a nice representation containing either just XORs or just biconditionals.</p> <h4 id="example">Example</h4> <p>\(\begin{align*} f(x_1,x_2,x_3,x_4) &amp;= x_1 \leftrightarrow x_2 \nleftrightarrow x_3 \leftrightarrow x_4 \\ &amp;= x_1 \leftrightarrow x_2 \leftrightarrow x_3 \nleftrightarrow x_4 \\ &amp;= f_\leftrightarrow(x_1,x_2,x_3) \nleftrightarrow x_4 \\ \end{align*}\)</p> <p>We replace the biconditionals in \(f_\leftrightarrow\) with XORs:</p> \[\begin{align*} f_\leftrightarrow(x_1,x_2,x_3) &amp;= x_1 \leftrightarrow x_2 \leftrightarrow x_3 \\ &amp;= x_1 \nleftrightarrow x_2 \nleftrightarrow x_3 \end{align*}\] <p>and insert back into the original equation:</p> \[\begin{align*} f(x_1,x_2,x_3,x_4) &amp;= f_\leftrightarrow(x_1,x_2,x_3) \nleftrightarrow x_4 \\ &amp;= x_1 \nleftrightarrow x_2 \nleftrightarrow x_3 \nleftrightarrow x_4 \end{align*}\]]]></content><author><name></name></author><category term="xor"/><category term="boolean algebra"/><category term="digital systems"/><summary type="html"><![CDATA[The exclusive-OR — also known as exclusive disjunction (short: XOR) or antivalence — is a Boolean operation that outputs true only when exactly one of its two inputs is true (i.e., when the inputs differ). XOR has numerous applications, including cryptography, Gray codes, parity checks, and CRC checks, among others. In this blog post, we will explore some of its interesting properties that can be useful in practice.]]></summary></entry><entry><title type="html">Efficient Computation of Sparse Fibonacci Subsequences</title><link href="https://markusthill.github.io/blog/2024/fibo-subsequences/" rel="alternate" type="text/html" title="Efficient Computation of Sparse Fibonacci Subsequences"/><published>2024-12-13T01:16:00+00:00</published><updated>2024-12-13T01:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/fibo-subsequences</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/fibo-subsequences/"><![CDATA[<p>The Fibonacci sequence is defined as:<br/> \(F_0 = 0, \ F_1 = 1,\) and \(F_n = F_{n-1} + F_{n-2}\) for \(n &gt; 1\).</p> <p>The first few elements of the sequence are:<br/> \(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \ldots\)</p> <p>Using the classical recurrence relation above, we need to know all preceding elements of the series up to \(n-1\) in order to obtain \(F_n\). For example, to compute \(F_{10} = 55\), we first calculate \(F_9 = 34\) and \(F_8 = 21\), which themselves depend on earlier values in the sequence.</p> <p>Here, we aim to explore the possibility of generating an arbitrary subsequence of the Fibonacci sequence without the need to calculate all preceding terms. For example, we may be interested in computing only \(F_{100}\), \(F_{555}\), \(F_{1000}\), and \(F_{2000}\). Is it possible to compute these specific terms directly, without generating the entire sequence up to \(F_{2000}\)?<br/> As we will see, this is indeed possible.</p> <p>In the example below, we attempt to find one thousand Fibonacci numbers modulo $m$ for every 10th prime number greater than \(10^{15}\):</p> \[S = \{F_{p_{10k}} \bmod m \mid p_{10k} \text{ is the } 10k\text{-th prime number such that } p_{10k} &gt; 10^{15}, \, 0 \leq k &lt; 1000 \}.\] <p>Follow along in the Jupyter notebook below:</p> <style>.jupyter-child-ext{width:112%;position:relative;left:calc(-10%)}</style> <div class="jupyter-child-ext"> <div class="jupyter-notebook" style="position: relative; width: 100%; margin: 0 auto;"> <div class="jupyter-notebook-iframe-container"> <iframe src="/assets/jupyter/MarkusThill.github.io-jupyter/2024_12_14_pe_204p100_fibo_subsequences.ipynb.html" style="position: absolute; top: 0; left: 0; border-style: none;" width="100%" height="100%" onload="this.parentElement.style.paddingBottom = (this.contentWindow.document.documentElement.scrollHeight + 10) + 'px'"></iframe> </div> </div> </div>]]></content><author><name></name></author><category term="math"/><category term="fibonacci"/><category term="sequences"/><summary type="html"><![CDATA[The Fibonacci sequence is a cornerstone of mathematics, defined by its elegant recurrence relation. While traditionally computed iteratively or recursively, obtaining specific terms like the 1000th or 2000th number seems to require calculating all preceding terms. But is this really necessary? In this post, we explore a powerful technique to compute arbitrary Fibonacci terms directly — bypassing the need for sequential computation. We’ll also tackle an exciting challenge: efficiently finding one thousand Fibonacci numbers modulo a given value, corresponding to every 10th prime greater than a trillion.]]></summary></entry><entry><title type="html">Don’t Drink and Derive: A Simple Proof that 1 = 2</title><link href="https://markusthill.github.io/blog/2024/a-simple-proof-that-1-2/" rel="alternate" type="text/html" title="Don’t Drink and Derive: A Simple Proof that 1=2"/><published>2024-12-12T13:16:00+00:00</published><updated>2024-12-12T13:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/a-simple-proof-that-1-2</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/a-simple-proof-that-1-2/"><![CDATA[<p>Let \(\begin{align} a,b,c \in \mathbb{R} \backslash \{ 0\}. \end{align}\)</p> <p>Now let us define a simple equation \(\begin{align} a=b+c \label{eq:start} \end{align}\)</p> <p>and play around with it a little bit.</p> \[\begin{align*} a &amp;= b+c &amp; &amp; \vert\ \cdot a\\ a^2 &amp;= ab + ac &amp; &amp; \vert\ -b^2, -c^2\\ a^2-b^2-c^2 &amp;= ab + ac - b^2 -c^2 &amp; &amp; \vert\ -2bc\\ a^2-b^2-c^2 -2bc &amp;= ab + ac - b^2 -c^2 -2bc &amp; &amp; \\ a^2-b^2-c^2 -2bc &amp;= ab - b^2 - bc + ac - bc - c^2 &amp; &amp; \\ a^2-b^2-c^2 -2bc &amp;= b(a - b - c) + c(a - b - c) &amp; &amp; \\ \end{align*}\] <p>We then add the terms \(ab\) and \(ac\) to the left side of the equation and then subtract them again and rearrange the terms of the equation:</p> \[\begin{align*} a^2-b^2-c^2 -2bc + ab -ab +ac -ac &amp;= b(a - b - c) + c(a - b - c) &amp; &amp; \\ a^2 + ab +ac -ab -b^2 -bc -ac -bc -c^2 &amp;= b(a - b - c) + c(a - b - c) &amp; &amp; \\ (a^2 + ab +ac) - (ab +b^2 +bc) - (ac +bc +c^2) &amp;= b(a - b - c) + c(a - b - c) &amp; &amp; \\ a(a + b +c) - b(a +b + c) - c(a +b +c) &amp;= b(a - b - c) + c(a - b - c) &amp; &amp; \\ (a + b +c) (a-b-c) &amp;= b(a - b - c) + c(a - b - c) &amp; &amp; \vert\ \div (a-b-c)\\ \end{align*}\] <p>Now, the equation simplifies to:</p> \[\begin{align*} a+b+c &amp;= b+c \\ a+ (b+c) &amp;= (b+c) \\ \end{align*}\] <p>If we use our original relation \(a=b+c\) from Eq. \eqref{eq:start} and insert \(a\) for the term \(b+c\) we finally get:</p> \[\begin{align*} a+ a &amp;= a &amp; &amp; \\ 2a &amp;= a &amp; &amp; \vert\ \div a \\ 2 &amp;= 1 \end{align*}\] <p>So, starting with Eq. \eqref{eq:start} we could prove that actually \(1=2\). Or is there something wrong up there?</p>]]></content><author><name></name></author><category term="math"/><summary type="html"><![CDATA[In this blog post, we present a fun little proof that 1 is actually equal to 2. Or is it?]]></summary></entry><entry><title type="html">CUDA Basics: Decoding DTMF Signals</title><link href="https://markusthill.github.io/blog/2024/dtmf-cuda/" rel="alternate" type="text/html" title="CUDA Basics: Decoding DTMF Signals"/><published>2024-12-12T09:16:00+00:00</published><updated>2024-12-12T09:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/dtmf-cuda</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/dtmf-cuda/"><![CDATA[<p>This post explores the fundamentals of CUDA programming using a dual-tone multi-frequency signaling (DTMF) example. Chosen for its manageable complexity and well-defined structure, the example provides an excellent introduction to parallel computing concepts and optimization techniques.</p> <p>DTMF, developed in the 1960s, is a telephone dialing system where each key is represented by the superposition of two harmonic tones. For example, pressing “5” generates frequencies of 770 Hz and 1336 Hz.</p> <p>In this blog post we demonstrate how to:</p> <ul> <li>Generate DTMF dialing sequences using Python (scipy and numpy) and save them as .wav audio files.</li> <li>Design a filter bank of FIR bandpass filters, each isolating one DTMF frequency.</li> <li>Decode the dialed key sequence from the audio file through filtering and post-processing.</li> </ul> <p>A CUDA/C++ implementation (dtmfCuda.cu) is included, showcasing how CUDA can accelerate the decoding process.</p> <h2 id="sample-files">Sample Files</h2> <p>Here are three .wav files containing DTMF signals to help you get started (you will find the files in the GitHub repository listed below). Each file encodes a sequence of telephone keypresses as audio, with each key represented by a unique combination of two frequencies.</p> <p>These files are designed as an introductory example for experimenting with DTMF decoding. You can use them to test your signal processing pipeline, design and evaluate filter banks, or simply gain hands-on experience with DTMF-based signaling.</p> <p>For a fun challenge, try decoding the signals using just your ears and a phone to generate reference sounds! Can you identify the dialed sequence from the characteristic dual-tone sounds? Play the files and give it a try!</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <audio src="/assets/jupyter/DTMFCuda/wav/dial.wav" controls=""/> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <audio src="/assets/jupyter/DTMFCuda/wav/dial2.wav" controls=""/> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <audio src="/assets/jupyter/DTMFCuda/wav/dial3.wav" controls=""/> </figure> </div> </div> <div class="caption"> Three examples of noisy DTMF signals. In this post, we demonstrate how to decode these signals and identify the corresponding telephone keys. </div> <style>.jupyter-child-ext{width:112%;position:relative;left:calc(-10%)}</style> <div class="jupyter-child-ext"> <div class="jupyter-notebook" style="position: relative; width: 100%; margin: 0 auto;"> <div class="jupyter-notebook-iframe-container"> <iframe src="/assets/jupyter/DTMFCuda/dtmf_example.ipynb.html" style="position: absolute; top: 0; left: 0; border-style: none;" width="100%" height="100%" onload="this.parentElement.style.paddingBottom = (this.contentWindow.document.documentElement.scrollHeight + 10) + 'px'"></iframe> </div> </div> </div>]]></content><author><name></name></author><category term="CUDA"/><category term="DTMF"/><category term="DSP"/><category term="FIR"/><category term="code"/><summary type="html"><![CDATA[Discover the fundamentals of CUDA programming through a dual-tone multi-frequency (DTMF) signaling example. Learn how to generate DTMF signals, save them as .wav files, design FIR bandpass filters, and decode dialed keys. This project includes a CUDA/C++ implementation (dtmfCuda.cu) to showcase the power of parallel computing for signal processing.]]></summary></entry><entry><title type="html">A few Bit-Twiddling Tricks</title><link href="https://markusthill.github.io/blog/2024/soa-few-bit-twiddling-tricks/" rel="alternate" type="text/html" title="A few Bit-Twiddling Tricks"/><published>2024-12-11T15:16:00+00:00</published><updated>2024-12-11T15:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/soa-few-bit-twiddling-tricks</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/soa-few-bit-twiddling-tricks/"><![CDATA[<p>When working with bit-fields, there are several techniques that can significantly speed up code — beyond the inherent performance benefits that bit-fields provide for many problems. In this post, I will introduce a few bit-twiddling tricks that I occasionally use, which can be useful for a variety of tasks.</p> <h2 id="swapping-variables-with-the-bitwise-exclusive-or">Swapping Variables with the bitwise Exclusive Or</h2> <p>A very common programming problem is swapping the values of two variables, \(x\) and \(y\). The most common approach is to introduce a temporary variable, \(z\), as follows:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">67</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
  <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span></code></pre></figure> <p>In practice, many compilers optimize this code and eliminate the temporary variable. However, there is also an elegant approach to perform this manually using the bitwise exclusive OR (XOR) operator:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">67</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">// x = 96</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">// y = 67</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">// x = 35 </span></code></pre></figure> <p>This uses the property of the exclusive or that \(x \oplus x = 0\) and its associative and commutative property, so that for instance \(x \oplus y \oplus x = x \oplus x \oplus y = (x \oplus x) \oplus y = 0 \oplus y = y\). One could similarily solve the problem with (as a side note):</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">67</span><span class="p">;</span>
 <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">;</span>
 <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
 <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span></code></pre></figure> <p>To be precise, this method works for all Abelian groups that satisfy the properties of commutativity, associativity, the existence of an identity element, and the existence of an inverse for each element (or where each element is its own inverse).</p> <h2 id="shifting-and-rotating">Shifting and Rotating</h2> <p>Commonly used bitwise operations include the shifting operations. There are two main types in C: the right shift <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> and the left shift <code class="language-plaintext highlighter-rouge">&lt;&lt;</code>. In C, the right shift is typically an arithmetic operation, shifting all bits to the right while preserving the sign (padding with the most significant bit). The left shift, on the other hand, pads the least significant bits with zeros. However, this behavior is implementation-dependent; some compilers may perform a logical right shift, where padding is done with zeros.</p> <p>In Java, the arithmetic right shift is also represented by <code class="language-plaintext highlighter-rouge">&gt;&gt;</code>, where the padding is done with the most significant bit to preserve the sign. Java also provides the logical right shift using <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>, which pads with zeros. Arithmetically, a left shift by one is equivalent to multiplying an integer by 2, while an arithmetic right shift by one corresponds to integer division by 2.</p> <p>Most CPUs also support left and right rotating operations. In this case, bits that are shifted out from one side of the bit-field are wrapped around and padded on the other side. However, many high-level programming languages do not support these operations directly. With the following inline assembler code, you can also perform left and right rotations on X86_X64 platforms.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/*
 * Rotatate 64bit variable x by y bits. Note that this is not a shift-operation but a real
 * roll-left
 ****/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">rol</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__asm__</span> <span class="p">(</span><span class="s">"rolq %1, %0"</span> <span class="o">:</span> <span class="s">"+g"</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="s">"cJ"</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">n</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
 * Same as rol, only rotates right instead of left.
 ****/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">ror</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span> <span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">__asm__</span> <span class="p">(</span><span class="s">"rorq %1, %0"</span> <span class="o">:</span> <span class="s">"+g"</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="s">"cJ"</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">n</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <h2 id="how-to-setdelete-a-bit-in-a-bit-field">How to set/delete a Bit in a Bit Field</h2> <p>Many programmers often wonder how to set, remove, or invert a bit in a bit-field. This can be easily achieved using the bitwise OR and AND operators, as demonstrated by the following functions:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/*
 * Sets a bit (sets it to 1)
 ****/</span>
<span class="kt">uint64_t</span> <span class="nf">setBit</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">b</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*
 * Deletes a bit (sets it to 0)
 ****/</span>
<span class="kt">uint64_t</span> <span class="nf">deleteBit</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">b</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*
 * Inverts a bit (sets it to 1)
 ****/</span>
<span class="kt">uint64_t</span> <span class="nf">invertBit</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">b</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure> <h2 id="counting-the-set-bits-in-a-bit-field">Counting the set Bits in a Bit Field</h2> <p>If you want to count the bits in a bit-field, a naive approach might involve masking out one bit at a time and checking if it is set. However, if only a few bits are set, the following function will perform much faster. In fact, it only requires as many iterations as there are set bits in the variable. This function is designed for 64-bit values but can easily be adjusted for 32-bit or 16-bit variables.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/*
 * Fast way to count the one-bits in a 64bit variable.
 * Only requires as many iterations as bits are set.
 ****/</span>
<span class="kt">int</span> <span class="nf">bitCount</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">ZERO</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">c</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <h2 id="find-the-position-of-a-set-bit">Find the Position of a set Bit</h2> <p>Sometimes, you may want to find the position of a single set bit in a bit-field. A naive approach would involve iterating through all the bits and checking each one to see if it is set. However, this results in linear time complexity. For a 64-bit variable, you would require 64 iterations in the worst case. We can improve on this.</p> <p>The following approach is similar to the divide-and-conquer strategies commonly used in many problems. First, we check which half of the bit-field contains the set bit. Then, we split that half into two parts and check which one contains the set bit, continuing this process iteratively. With this approach, we can locate the bit in logarithmic time. For a 64-bit variable, this would take just 6 iterations, which is significantly faster than the 64 iterations required by the naive method.</p> <p>Note, however, that this function assumes only a single bit is set in the entire bit-field. Mathematically, this function computes the binary logarithm of a value that is a power of two.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">B32</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p32</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">B16</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p16</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">B08</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">B04</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">B02</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">B01</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">B_LVL</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">B01</span><span class="p">,</span> <span class="n">B02</span><span class="p">,</span> <span class="n">B04</span><span class="p">,</span> <span class="n">B08</span><span class="p">,</span> <span class="n">B16</span><span class="p">,</span> <span class="n">B32</span><span class="p">};</span>

<span class="cm">/*
 * Determines the position of a single bit in a 64bit variable in logarithmic time.
 * Basically the same as the binary logarithm of a power of two.
 ****/</span>
<span class="kt">int</span> <span class="nf">bitPos</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">bPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">B_LVL</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">ZERO</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">nBits</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">B01</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">nBits</span><span class="p">;</span>
            <span class="n">bPos</span> <span class="o">+=</span> <span class="n">nBits</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">bPos</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <h2 id="modulo-operations-for-divisors-of-powers-of-two">Modulo Operations for Divisors of Powers of Two</h2> <p>Similar to the decimal system, where a modulo operation with a divisor of 10 returns the last digit (assuming the dividend is positive), and a modulo operation with 100 returns the last two digits (and so on), a modulo operation with a binary \((10)_2\) (which is 2 in the decimal system) and \((100)_2\) (which is 4 in the decimal system) would return the last binary digit and the last two binary digits, respectively.</p> <p>Thus, a modulo operation by a power of two can be implemented efficiently and can save significant computation time when used repeatedly. For example, if you have a hash table with \(2^n\) entries, you can easily map a hash value to an index in the table using such a modulo operation. If the hash table is accessed many millions of times, using an efficient modulo implementation can save considerable time. Note that many compilers’ optimizers do not take into account the special case where the divisor is a power of two.</p> <p>A modulo function that computes \(x \, \mbox{mod} \, 2^n\) might look like this:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">uint64_t</span> <span class="nf">modPow2</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><category term="bit"/><category term="twiddling"/><category term="hacks"/><category term="performance"/><category term="speed"/><summary type="html"><![CDATA[When working with bit-fields, there are several techniques that can significantly speed up code — beyond the inherent performance benefits that bit-fields provide for many problems. In this post, I will introduce a few bit-twiddling tricks that I occasionally use, which can be useful for a variety of tasks.]]></summary></entry><entry><title type="html">The Monkey and Coconut Problem</title><link href="https://markusthill.github.io/blog/2024/the-sailors-problem/" rel="alternate" type="text/html" title="The Monkey and Coconut Problem"/><published>2024-05-26T00:00:00+00:00</published><updated>2024-05-26T00:00:00+00:00</updated><id>https://markusthill.github.io/blog/2024/the-sailors-problem</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/the-sailors-problem/"><![CDATA[<p>Three sailors, stranded on a deserted island with a monkey, gather a pile of coconuts to be divided among themselves the next morning. During the night, one of the sailors wakes up, secretly divides the pile into three equal parts, and finds an extra coconut, which he gives to the monkey. He hides his share and combines the remaining coconuts back into a single heap. Later that night, the second sailor does the same: dividing the pile into three equal parts, giving the leftover coconut to the monkey, hiding his share, and returning the rest to the heap. The third sailor repeats the process in the same manner.</p> <p>The next morning, the sailors divide the remaining pile of coconuts into three equal parts, once again finding an extra coconut, which they give to the monkey.</p> <p>The question is: how many coconuts were originally in the pile?</p> <p>Additionally, a general solution should be determined for \(n\) coconuts, \(k\) sailors, and \(m\) monkeys.</p> <h2 id="derivation">Derivation</h2> <p>So, let us start writing down the given information in a more mathematical form, but without too much strict math.</p> <p>To summarize, we have a number of sailors: \(\begin{align} k \in \mathbb{N_+} \backslash \{ 1\} \end{align}\) where \(\mathbb{N_+}\) is the set of positive natural numbers, and \(k = 1\) is excluded since only one sailor is not interesting for this problem.</p> <p>The number of coconuts collected by the sailors before the night: \(\begin{align} n \in \mathbb{N_+}, \end{align}\) which must also be a positive natural number.</p> <p>Finally, the number of monkeys is given by: \(\begin{align} m \in \mathbb{N_+}, \ m &lt; k, \end{align}\) indicating that there are fewer monkeys than sailors.</p> <p>The first sailor, who wakes up first, divides the number of coconuts by the number of sailors. He gives the remaining coconuts to the monkeys. This results in \(k\) shares, each of size \((n-m)/k\). The first sailor buries his (stolen) share, leaving behind the following number of coconuts:<br/> \begin{align} n_1 = \frac{n-m}{k}(k-1)=(n-m)\frac{k-1}{k} \label{eq:n1} \end{align}</p> <p>The second sailor, who wakes up next, repeats the procedure of the first sailor: \(\begin{align} n_2 &amp;= (n_1-m)\frac{k-1}{k}=\big((n-m)\frac{k-1}{k} -m \big) \frac{k-1}{k} \\ &amp;= (n-m) \big(\frac{k-1}{k} \big)^2 - m\frac{k-1}{k} \end{align}\)</p> <p>Then, the third sailor wakes up and performs the same process: \(\begin{align} n_3 &amp;= \Bigg(\bigg((n-m)\frac{k-1}{k}-m\bigg)\frac{k-1}{k} - m\Bigg) \frac{k-1}{k} \\ &amp;= (n-m) \Big(\frac{k-1}{k}\Big)^3 - m\Big(\frac{k-1}{k}\Big)^2 - m\frac{k-1}{k} \end{align}\)</p> <p>For the \(i\)-th sailor, where \(1 \leq i \leq k\), we derive the general recursive rule: \(\begin{align} n_i = (n_{i-1}-m)\frac{k-1}{k}. \end{align}\)</p> <p>For every sailor, we subtract \(m\) coconuts from the previous count \(n_{i-1}\), and then multiply by \(\frac{k-1}{k}\). This relationship can also be expressed as (for \(i &gt; 1\)):</p> <p>\(\begin{align} n_i &amp;= (n-m)\bigg(\frac{k-1}{k} \bigg)^i - m\bigg(\frac{k-1}{k} \bigg)^{i-1} - \ldots - m\frac{k-1}{k} \\ &amp;= (n-m)\bigg(\frac{k-1}{k} \bigg)^i - m\sum_{\substack{j=1 \\ i&gt;1}}^{i-1}\bigg(\frac{k-1}{k} \bigg)^j \end{align}\) For our convenience, we define the initial number of coconuts as \(n_0 = n\). Hence, we can write \(n_i\) for all \(0 \leq i\leq k\) as: \(\begin{align} n_i=\begin{cases} n, &amp; \mbox{for} \ i=0 \\ (n-m)\bigg(\frac{k-1}{k} \bigg)^i - m\sum\limits_{\substack{j=1 \\ i&gt;1}}^{i-1}\bigg(\frac{k-1}{k} \bigg)^j, &amp; \mbox{else} \end{cases} \label{eq:iterativeForm} \end{align}\)</p> <p>In order to find an initial amount of coconuts \(n\), we have to ensure that all \(n_i\) are dividable by \(k\) with a remainder of one (which is given to the monkey). Hence, it has to be ensured that: \(\begin{align} \forall i \in \{ 0, \ldots, k\}: \ n_i \equiv m\mod k \label{eq:forallI} \end{align}\) Remember that in the morning, after all \(k\) sailors have woken up, the remaining coconuts are divided among all sailors. So, as stated above, \(n_k\) must have a remainder of one when divided by \(k\). For \(n_0 = n\), it is sufficient to ensure that \(n\) is a multiple of \(k\) plus \(m\).</p> <p>For larger \(i\), the situation becomes slightly more complex. We need to find an \(n\) that satisfies Eq. \eqref{eq:iterativeForm} such that Eq. \eqref{eq:forallI} is also satisfied. To achieve this, let us first simplify the complicated expression (assuming \(i &gt; 1\)) in Eq. \eqref{eq:iterativeForm} using the geometric series specified in the Appendix:</p> \[\begin{align} &amp; \ \ (n-m)\bigg(\frac{k-1}{k} \bigg)^i - m\sum\limits_{\substack{j=1 \\ i&gt;1}}^{i-1}\bigg(\frac{k-1}{k} \bigg)^j \label{eq:probWithSum} \\ &amp;= (n-m)\bigg(\frac{k-1}{k} \bigg)^i - m\frac{ \Big(\frac{k-1}{k}\Big)^i - \frac{k-1}{k}}{\frac{k-1}{k} - 1} \\ &amp;= (n-m)\bigg(\frac{k-1}{k} \bigg)^i - m\frac{ \Big(\frac{k-1}{k}\Big)^i - \frac{k-1}{k}}{-\frac{1}{k}} \\ &amp;= (n-m)\bigg(\frac{k-1}{k} \bigg)^i + mk \bigg(\frac{k-1}{k} \bigg)^i-mk+m \\ &amp;= (n-m+mk)\bigg(\frac{k-1}{k} \bigg)^i -mk+m. \label{eq:iterativeSimple} \end{align}\] <p>Now we can try to find an \(n\) that suffices Eq. \eqref{eq:forallI}:</p> \[\begin{align} (n-m+mk)\bigg(\frac{k-1}{k} \bigg)^i -mk+m &amp;\equiv m \mod k \\ (n-m+mk)\bigg(\frac{k-1}{k} \bigg)^i -mk &amp;\equiv 0 \mod k \\ (n-m+mk)\bigg(\frac{k-1}{k} \bigg)^i &amp;\equiv 0 \mod k \label{eq:modulo} \end{align}\] <p>Note that we cannot get rid of the term \(mk\), since the power of the fraction is smaller than one and not a natural number. The left-hand side of Eq. \eqref{eq:modulo} should hence be a multiple of \(k\). This can be expressed as:</p> \[\begin{align} (n-m+mk)\bigg(\frac{k-1}{k} \bigg)^i = r\cdot k, \end{align}\] <p>where for now we choose \(r \in \mathbb{Z}\) and then solve for \(n\):</p> \[\begin{align} (n-m+mk)\bigg(\frac{k-1}{k} \bigg)^i &amp;= r\cdot k \\ n-m+mk &amp;= r\cdot k \bigg(\frac{k}{k-1} \bigg)^i \\ n &amp;= r\cdot k \bigg(\frac{k}{k-1} \bigg)^i - mk + m \\ n &amp;= r\cdot \frac{k^{k+1}}{(k-1)^i} - m(k -1) \label{eq:firstN}. \end{align}\] <p>Although we can now compute different values for \(n\) according to \eqref{eq:firstN} which will suffice Eq. \eqref{eq:modulo}, we can observe a problem: For example, with \(i=k=3\) and \(m=r=1\) we receive a value of \(n=8.125\), which – although it suffices Eq. \eqref{eq:modulo} – is not a natural number. This is due to the fraction in Eq. \eqref{eq:firstN}. However, we show in the Appendix that numerator and denominator are relatively prime to each other, hence, the fraction cannot be reduced. So, in order to obtain a natural number for \(n\), we can drag the denominator to \(r\) and assume that \(r\) is a multiple of it by replacing \(r/(k-1)^i\) with \(q \in \mathbb{N_+}\):</p> \[\begin{align} n &amp;= r\cdot \frac{k^{k+1}}{(k-1)^i} - m(k -1) \\ &amp;= \frac{r}{(k-1)^i} \cdot k^{k+1} - m(k -1) \\ &amp;= q \cdot k^{k+1} - m(k -1). \label{eq:finalSolution} \end{align}\] <p>Note that in Eq. \eqref{eq:finalSolution} we have an expression which is independent of \(i\) and hence fulfills Eq. \eqref{eq:forallI} for all \(i \in \{2, \ldots, k \}\).</p> <p>You might have noticed that we actually only solved the problem for \(i &gt; 1\), since the sum in Eq. \eqref{eq:probWithSum} is only evaluated for \(i &gt; 1\). However, Eq. \eqref{eq:forallI} requires that the condition holds for all \(i \in \{0, \ldots, k\}\) – meaning it must also be satisfied for \(i = 0\) and \(i = 1\) – ensuring that \(n_i \equiv m \mod k\).</p> <p>We can directly observe that Eq. \eqref{eq:finalSolution} is a valid solution for the case \(i = 0\). Furthermore, we can show that the case \(i = 1\), as specified in Eq. \eqref{eq:n1}, is merely a special case of Eq. \eqref{eq:firstN}, with:</p> \[\begin{align} (n-m)\frac{k-1}{k} &amp;\equiv m\mod k \\ \Rightarrow (n-m)\frac{k-1}{k} &amp;= s \cdot k + m \\ n &amp;= s \cdot k\frac{k}{k-1} + m\frac{k}{k-1} + m \\ &amp;= \frac{sk^2+mk}{k-1} + m \label{eq:casen1} \end{align}\] <p>and:</p> \[\begin{align} \frac{sk^2+mk}{k-1} + m &amp;= r\cdot \frac{k^{k+1}}{(k-1)^1} - mk + m \\ sk^2+mk &amp;= r k^{k+1} - mk(k-1) \\ sk +m &amp;= rk^k - mk + m \\ s &amp;= rk^{k-1} - m \in \mathbb{N}. \end{align}\] <p>Hence, if we insert \(s\) into Eq. \eqref{eq:casen1} we obtain Eq. \eqref{eq:firstN} which then leads to the general solution in Eq. \eqref{eq:finalSolution}.</p> <h2 id="verification">Verification</h2> <p>To make sure that we have obtained a correct solution, let us run some simulations where we try many values for \(n=n_0\) and check if these values correspond to Eq. \eqref{eq:finalSolution}.</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Number of Sailors</span><span class="w">
</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">3</span><span class="w">

</span><span class="c1"># Number of Monkeys on the island</span><span class="w">
</span><span class="n">m</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">2</span><span class="w">

</span><span class="c1"># Range of coconuts to try (1 2 3 ... n_max):</span><span class="w">
</span><span class="n">n_max</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1e6</span><span class="w">

</span><span class="c1"># There should be less monkeys than sailors</span><span class="w">
</span><span class="n">stopifnot</span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">

</span><span class="c1"># Recursive function simulating the sailors behaviour</span><span class="w">
</span><span class="n">divideCocos</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">sailor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="k">if</span><span class="p">(</span><span class="n">sailor</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
  </span><span class="k">if</span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">%%</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">divideCocos</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="n">sailor</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">))</span><span class="w">
  </span><span class="kc">FALSE</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">tryN</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="n">n_max</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">divideCocos</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">))</span><span class="w">
</span><span class="n">realN</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">which</span><span class="p">(</span><span class="n">tryN</span><span class="p">)</span><span class="w">

</span><span class="c1"># Compare with formula</span><span class="w">
</span><span class="n">formulaNCocos</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">q</span><span class="o">*</span><span class="n">k</span><span class="o">^</span><span class="p">(</span><span class="n">k</span><span class="m">+1</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="m">-1</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="n">formulaN</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">realN</span><span class="p">),</span><span class="w"> </span><span class="n">formulaNCocos</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w">

</span><span class="c1"># Check if the simulated results fit to the formula we obtained</span><span class="w">
</span><span class="n">anyError</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">which</span><span class="p">(</span><span class="n">formulaN</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">realN</span><span class="p">)</span><span class="w">
</span><span class="n">stopifnot</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">anyError</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w">

</span><span class="n">cat</span><span class="p">(</span><span class="s2">"Formula appears to be correct!!!\n"</span><span class="p">)</span><span class="w">
</span><span class="n">cat</span><span class="p">(</span><span class="s2">"\nSome numbers n that work:"</span><span class="p">,</span><span class="w"> </span><span class="n">realN</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="nf">min</span><span class="p">(</span><span class="m">25</span><span class="p">,</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">realN</span><span class="p">))])</span></code></pre></figure> <p>We can run this R-script for different settings of sailors and monkeys and check if there are any differences between the simulated results and the formula. In such a case, the formula would be wrong.<br/> However, after trying several combinations, we can be quite confident that the formula is correct (although the computer simulation is certainly not a real proof). For our initial setup with \(k = 3\) sailors and \(m = 1\) monkey, we get the following result with the R script:</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">Formula</span><span class="w"> </span><span class="n">appears</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">correct</span><span class="o">!!!</span><span class="w">
</span><span class="n">Some</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">work</span><span class="o">:</span><span class="w"> </span><span class="m">79</span><span class="w"> </span><span class="m">160</span><span class="w"> </span><span class="m">241</span><span class="w"> </span><span class="m">322</span><span class="w"> </span><span class="m">403</span><span class="w"> </span><span class="m">484</span><span class="w"> </span><span class="m">565</span><span class="w"> </span><span class="m">646</span><span class="w"> </span><span class="m">727</span><span class="w"> </span><span class="m">808</span><span class="w"> </span><span class="m">889</span><span class="w"> </span><span class="m">970</span><span class="w"> </span><span class="m">1051</span><span class="w"> </span><span class="m">1132</span><span class="w"> </span><span class="m">1213</span><span class="w"> </span><span class="m">1294</span><span class="w"> </span><span class="m">1375</span><span class="w"> </span><span class="m">1456</span><span class="w"> </span><span class="m">1537</span><span class="w"> </span><span class="m">1618</span><span class="w"> </span><span class="m">1699</span><span class="w"> </span><span class="m">1780</span><span class="w"> </span><span class="m">1861</span><span class="w"> </span><span class="m">1942</span><span class="w"> </span><span class="m">2023</span></code></pre></figure> <h1 id="summary">Summary</h1> <p>As we found, it is possible to find a general algebraic solution to the coconut and monkey problem described at the beginning. The number of coconuts that were initially collected, for \(k\) sailors and \(m\) monkeys, is given by:</p> \[\begin{align} n = q \cdot k^{k+1} - m(k -1), \end{align}\] <p>where \(q\) is a natural number larger than 0, since there are infinitely many solutions.</p> <h1 id="appendix">Appendix</h1> <h2 id="geometric-series">Geometric Series</h2> <p>In this appendix we briefly mention several properties of the geometric series which are required for the derivations in other dependencies. For \(q \neq 1\) and \(j&lt;N\) the geometric series can be derived as:</p> \[\begin{equation} \begin{split} S = q^{j}+q^{j+1}+ \cdots + q^{N-1} \\ qS = q^{j+1} + q^{j+2} + \cdots + q^N \\ qS - S = q^N - q^j \\ S(q-1) = q^N - q^j \\ S = \frac{q^N - q^j}{q-1} = \frac{q^j-q^N}{1-q} \end{split} \label{eq:geometricSeries1} \end{equation}\] <p>More generally, the geometric series can be written as:</p> \[\begin{equation} \begin{split} a_0 \sum_{i=j}^{N-1} {q^i} = a_0 \frac{q^N - q^j}{q-1} \end{split} \label{eq:geometricSeries2} \end{equation}\] <p><strong>Special cases</strong></p> <p>If the series starts with \(i=0\) we retrieve:</p> \[\begin{equation} \begin{split} a_0 \sum_{i=0}^{N-1} {q^i} = a_0 \frac{1- q^N}{1-q} \end{split} \label{eq:geometricSeries2a} \end{equation}\] <p>For \(q=1\) we obtain: \begin{equation} \begin{split} a_0 \sum_{i=j}^{N-1} {1^i} = a_0 (N-j) \end{split} \label{eq:geometricSeries3} \end{equation} For an infinite series with \(N=\infty\), convergence is achieved for values \(|q|&lt;1\): \begin{equation} \begin{split} a_0 \sum_{i=j}^{\infty} {q^i} = a_0 \frac{q^j}{1-q} \end{split} \label{eq:geometricSeries4} \end{equation}</p> <h2 id="powers-of-neighbored-natural-numbers-are-relatively-prime">Powers of neighbored natural numbers are relatively prime</h2> <p>In this appendix we briefly show that two neighbored natural numbers \(k\) and \(k+1\) are relatively prime, as well as their powers. This can be done with a proof by contradiction: Let us assume that there exists a divisor \(t&gt;1\) for which:</p> \[\begin{align} k &amp;= q \cdot t\\ k+1 &amp;= r \cdot t \end{align}\] <p>This also implies: \(\begin{align} r &gt; q \\ r - q \geq 1 \end{align}\)</p> <p>We can also write:</p> \[\begin{align} q \cdot t + 1 &amp;= r \cdot t \\ 1 &amp;= r \cdot t - q \cdot t \\ 1 &amp;= (r- q) \cdot t \\ &amp; \Rightarrow r - q = 1 \wedge t = 1. \end{align}\] <p>Since we required \(t&gt;1\), we have a contradiction, which means that the two neighbored numbers \(k\) and \(k+1\) are relatively prime and a fraction containing these two numbers in the numerator and denominator cannot be reduced. Furthermore, since the prime factorization of \(k\) and \(k+1\) returns two disjoint sets of primes \(P_{k}\) and \(P_{k+1}\) (\(P_{k} \cap P_{k+1} = \emptyset\)), it can also be trivially shown that the powers \(k^i\) and \((k+1)^j\), with \(i,j \in \mathbb{N_+}\) are also relatively prime.</p>]]></content><author><name></name></author><category term="math"/><category term="riddles"/><summary type="html"><![CDATA[Three sailors and a monkey are stranded on a deserted island. They gather a pile of coconuts to divide the next morning. During the night, each sailor wakes up, divides the pile into three parts, gives the extra coconut to the monkey, hides his share, and restacks the remaining coconuts. In the morning, the remaining coconuts are again divided into three parts, with one coconut left over, which is given to the monkey. The question is: how many coconuts were originally in the pile?]]></summary></entry><entry><title type="html">Short Notes: Gradient of the Softmax Function for the Cross-Entropy Loss</title><link href="https://markusthill.github.io/blog/2024/gradient-softmax-function-with-cross-entropy/" rel="alternate" type="text/html" title="Short Notes: Gradient of the Softmax Function for the Cross-Entropy Loss"/><published>2024-05-03T17:29:40+00:00</published><updated>2024-05-03T17:29:40+00:00</updated><id>https://markusthill.github.io/blog/2024/gradient-softmax-function-with-cross-entropy</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/gradient-softmax-function-with-cross-entropy/"><![CDATA[<p>In practice, the so-called softmax function is often used for the last layer of a neural network when several output units are required. Its purpose is to squash all outputs into the range of \([0,1]\) in a way that they sum up to one. This is particularly useful in classification tasks, where each output represents the probability of the input vector belonging to a specific class. When training the neural network weights using the classical backpropagation algorithm, it’s necessary to compute the gradient of the loss function. In the following, we demonstrate how to compute the gradient of a softmax function for the cross-entropy loss, assuming the softmax function is utilized in the output layer of the neural network.</p> <p>The softmax function for a unit \(z_j\) is defined as:</p> \[\begin{eqnarray*} o_j = \frac{\mbox{e}^{z_j}}{\sum_k \mbox{e}^{z_k}}, \end{eqnarray*}\] <p>where \(k\) iterates over all output units. The cross-entropy loss for a softmax unit with \(p\) output units \(o_j\) and targets \(y^*_j\) is defined as:</p> \[\begin{eqnarray*} E=-\sum_j^{p} y^*_j\cdot \mbox{log}(o_j). \end{eqnarray*}\] <p>In order to compute the gradient of \(E\) with respect to \(z_i\), we can start with:</p> \[\begin{align} \frac{\partial E}{\partial z_i}&amp;=- \sum_j^{p} y^*_j\cdot \frac{\partial}{\partial z_i}\mbox{log}(o_j) \nonumber \\ &amp;=- \sum_{j \neq i}^{p} y^*_j\cdot \frac{\partial}{\partial z_i}\mbox{log}(o_j) - y^*_i\cdot \frac{\partial}{\partial z_i}\mbox{log}(o_i). \label{eq:partialSoftmax} \end{align}\] <p>Now we compute both partial derivatives of \(o_j\) and \(o_i\), which lead to different results:</p> \[\begin{align} \frac{\partial}{\partial z_i} o_j &amp;= \frac{\partial}{\partial z_i} \frac{\mbox{e}^{z_j}}{\sum_k \mbox{e}^{z_k}}\nonumber \\ &amp;= \mbox{e}^{z_j} \frac{\partial}{\partial z_i} \Bigg(\sum_k \mbox{e}^{z_k} \Bigg)^{-1} \nonumber \\ &amp;= -\mbox{e}^{z_j} \Bigg(\sum_k \mbox{e}^{z_k} \Bigg)^{-2} \mbox{e}^{z_i} \nonumber \\ &amp;= -o_j \cdot o_i, \label{eq:partialOj} \end{align}\] <p>and</p> \[\begin{align} \frac{\partial}{\partial z_i} o_i &amp;= \frac{\partial}{\partial z_i} \frac{\mbox{e}^{z_i}}{\sum_k \mbox{e}^{z_k}} \nonumber \\ &amp;= \frac{\mbox{e}^{z_i}}{\sum_k \mbox{e}^{z_k}} + \mbox{e}^{z_i}\frac{\partial}{\partial z_i} \frac{1}{\sum_k \mbox{e}^{z_k}} \nonumber \\ &amp;= \frac{\mbox{e}^{z_i}}{\sum_k \mbox{e}^{z_k}} - \mbox{e}^{z_i} \Big(\sum_k \mbox{e}^{z_k}\Big)^{-2} \mbox{e}^{z_i} \nonumber \\ &amp;= o_i - o_i^2. \label{eq:partialOi} \end{align}\] <p>We can simplify Eq. \eqref{eq:partialSoftmax} with these two partial derivatives:</p> \[\begin{align} \frac{\partial E}{\partial z_i}&amp;=-\sum_{j \neq i}^{p} y^*_j\cdot \frac{\partial}{\partial z_i}\mbox{log}(o_j) - y^*_i\cdot \frac{\partial}{\partial z_i}\mbox{log}(o_i) \nonumber \\ &amp;= -\sum_{j \neq i}^{p} y^*_j \frac{1}{o_j} \frac{\partial}{\partial z_i}o_j - y^*_i \frac{1}{o_i} \frac{\partial}{\partial z_i}o_i. \label{eq:partialSoftmax2} \end{align}\] <p>Finally, we insert \eqref{eq:partialOj} and \eqref{eq:partialOi} into \eqref{eq:partialSoftmax2}:</p> \[\begin{align*} \frac{\partial E}{\partial z_i} &amp;= \sum_{j \neq i}^{p} y^*_j \frac{1}{o_j} o_j \cdot o_i - y^*_i \frac{1}{o_i} (o_i - o_i^2)\\ &amp;= \sum_{j \neq i}^{p} y^*_j o_i - y^*_i (1 - o_i)\\ &amp;= o_i\sum_{j \neq i}^{p} y^*_j - y^*_i + y^*_i o_i \\ &amp;= o_i \underbrace{\sum_{j =1}^{p} y^*_j }_{=1} - y^*_i \\ &amp;= o_i - y^*_i. \end{align*}\]]]></content><author><name></name></author><category term="stats"/><category term="ML"/><category term="math"/><category term="softmax"/><category term="cross-entropy"/><category term="gradient"/><category term="backprop"/><summary type="html"><![CDATA[The softmax function in neural networks ensures outputs sum to one and are within [0,1]. Here's how to compute its gradients when the cross-entropy loss is applied.]]></summary></entry><entry><title type="html">Obfuscating a Function – How not to write Code</title><link href="https://markusthill.github.io/blog/2024/obsfucated-c-code/" rel="alternate" type="text/html" title="Obfuscating a Function – How not to write Code"/><published>2024-05-02T13:01:50+00:00</published><updated>2024-05-02T13:01:50+00:00</updated><id>https://markusthill.github.io/blog/2024/obsfucated-c-code</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/obsfucated-c-code/"><![CDATA[<p>Some time ago, I had to write a pretty simple function that converts an integer value into a new “format.” The function ended up being easy-to-read code. For reasons I do not remember, I decided to obfuscate the purpose of the function slightly, and I ended up with the following:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">char</span><span class="o">*</span> <span class="nf">whatDoIdo</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">v</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">z</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mh">0x49</span><span class="p">,</span><span class="mh">0x56</span><span class="p">,</span><span class="mh">0x58</span><span class="p">,</span><span class="mh">0x4c</span><span class="p">,</span><span class="mh">0x43</span><span class="p">,</span><span class="mh">0x44</span><span class="p">,</span><span class="mh">0x4d</span><span class="p">};</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="sc">'\0'</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">x</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">v</span><span class="o">/=</span><span class="mi">5</span><span class="o">/</span><span class="p">((</span><span class="n">i</span><span class="o">--+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">v</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">x</span><span class="o">-=</span><span class="n">v</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;&amp;</span><span class="n">x</span><span class="o">&gt;=</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">v</span><span class="o">-</span><span class="n">v</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">x</span><span class="o">-=</span><span class="n">p</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="p">)])</span><span class="o">+</span><span class="mi">1</span>
          <span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">t</span><span class="p">[</span><span class="mi">200</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d : %s"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">whatDoIdo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <p>If you run the code for different values of <code class="language-plaintext highlighter-rouge">x</code> in the function <code class="language-plaintext highlighter-rouge">main(),</code> you will quickly discover the function’s purpose, <code class="language-plaintext highlighter-rouge">whatDoIdo().</code> If you are more dedicated, you can decrypt the code and guess its functionality without running it once. Indeed, you should prevent writing code like this at work or university since your colleagues/classmates or others who have to read your code most likely won’t appreciate this kind of programming style.</p> <p>If you do not have a compiler at hand, you can take a look at some sample outputs that should appear familiar.</p> <details><summary>Click here to see some examples</summary> <figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">  1  : I
  5  : V
  50 : L
  </code></pre></figure> </details> <p><br/></p> <p>Any guess? If not, then take a look at some more outputs:</p> <details><summary>Click here to see more examples</summary> <figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">  87   : LXXXVII
  123  : CXXIII
  1846 : MDCCCXLVI
  </code></pre></figure> </details> <p><br/></p> <p>There is even an <a href="https://www.ioccc.org/">annual contest for obfuscated C code</a> on <a href="https://www.ioccc.org/">https://www.ioccc.org/</a>. IIf you are interested in submitting an entry for the next contest, the degree of obfuscation should be significantly higher than in this trivial example. The winning entries of the past years are really worth looking at.</p>]]></content><author><name></name></author><category term="Programming"/><summary type="html"><![CDATA[A while back, I created a straightforward function to convert an integer into a new format, resulting in clear code. However, I inexplicably chose to obscure its purpose, leading to the following outcome: Read more in this post...]]></summary></entry><entry><title type="html">Short Notes: Eigendecomposition of a Matrix</title><link href="https://markusthill.github.io/blog/2024/eigendecomposition/" rel="alternate" type="text/html" title="Short Notes: Eigendecomposition of a Matrix"/><published>2024-05-01T09:16:00+00:00</published><updated>2024-05-01T09:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/eigendecomposition</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/eigendecomposition/"><![CDATA[<p>A vector \(\mathbf{v}_i \in \mathbb{C}^{n}\) is called the \(i\)-th eigenvector of a matrix \(\mathbf{A} \in \mathbb{R}^{n \times n}\), if it satisfies the simple equation</p> \[\begin{align} \mathbf{A} \mathbf{v}_i = \lambda_i \mathbf{v}_i, \label{eq:eigvalues} \end{align}\] <p>for a scalar value \(\lambda_i \in \mathbb{C}\), called an eigenvalue. (Assuming the matrix \(\mathbf{A}\) is real-valued, the eigenvalues and eigenvectors might still be complex.) Let us further assume that the \(n\) eigenvectors of matrix \(\mathbf{A}\) are linearly independent.</p> <p>We can now ‘horizontally’ stack the eigenvectors into a matrix \(\mathbf{Q} \in \mathbb{C}^{n \times n}\):</p> \[\begin{align} \mathbf{Q} = \big[\mathbf{v}_1, \mathbf{v}_2, \ldots, \mathbf{v}_n \big]. \label{eq:Q} \end{align}\] <p>Multiplying \(\mathbf{A}\) with \(\mathbf{Q}\) gives us:</p> \[\begin{align} \mathbf{A}\mathbf{Q} = \big[\mathbf{A}\mathbf{v}_1, \mathbf{A}\mathbf{v}_2, \ldots, \mathbf{A}\mathbf{v}_n \big]. \label{eq:AQ} \end{align}\] <p>If we compare Eq. \eqref{eq:AQ} with Eq. \eqref{eq:eigvalues}, we can see that:</p> \[\begin{align} \mathbf{A}\mathbf{Q} = \big[\lambda_1\mathbf{v}_1, \lambda_2\mathbf{v}_2, \ldots, \lambda_n\mathbf{v}_n \big]. \label{eq:AQ_2} \end{align}\] <p>If we now define a diagonal matrix carrying the eigenvalues \(\lambda_i\) as</p> \[\begin{align} \mathbf{\Lambda} = \begin{bmatrix} \lambda_1 &amp; 0 &amp; \ldots &amp; 0\\ 0 &amp; \lambda_2 &amp; \ldots &amp; 0 \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; \ldots &amp; \lambda_n \end{bmatrix}, \label{eq:Lambda} \end{align}\] <p>we see that</p> \[\begin{align} \mathbf{Q}\mathbf{\Lambda} = \big[\lambda_1\mathbf{v}_1, \lambda_2\mathbf{v}_2, \ldots, \lambda_n\mathbf{v}_n \big] \label{eq:AQ_3} \end{align}\] <p>which is equal to Eq. \eqref{eq:AQ_2}:</p> \[\begin{align} \mathbf{Q}\mathbf{\Lambda} = \mathbf{A}\mathbf{Q}. \label{eq:AQ_4} \end{align}\] <p>One final rearrangement – post-multiplying Eq. \eqref{eq:AQ_4} with \(\mathbf{Q}^{-1}\) – and we are done:</p> \[\begin{align} \mathbf{A} = \mathbf{Q}\mathbf{\Lambda}\mathbf{Q}^{-1}. \label{eq:eigendecomposition} \end{align}\] <p>Eq. \eqref{eq:eigendecomposition} is also called the eigendecomposition of matrix \(\mathbf{A}\).</p> <style>.jupyter-child-ext{width:112%;position:relative;left:calc(-10%)}</style> <div class="jupyter-child-ext"> <div class="jupyter-notebook" style="position: relative; width: 100%; margin: 0 auto;"> <div class="jupyter-notebook-iframe-container"> <iframe src="/assets/jupyter/MarkusThill.github.io-jupyter/2024_05_01_eigendecomposition_example.ipynb.html" style="position: absolute; top: 0; left: 0; border-style: none;" width="100%" height="100%" onload="this.parentElement.style.paddingBottom = (this.contentWindow.document.documentElement.scrollHeight + 10) + 'px'"></iframe> </div> </div> </div>]]></content><author><name></name></author><category term="math"/><category term="code"/><category term="eigendecomposition"/><category term="python"/><summary type="html"><![CDATA[The derivation of the eigendecomposition is surprisingly simple. Read more here!]]></summary></entry></feed>